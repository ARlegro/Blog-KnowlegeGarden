---
{"dg-publish":true,"permalink":"/Computer_Science/Computer_Data/3.1, 3.2 - 역사적 관점, 프로그램 인코딩/","noteIcon":"","created":"2025-07-28T15:27:36.872+09:00","updated":"2025-08-16T16:04:33.255+09:00"}
---


이전 : [[Computer_Science/Computer_Data/3.0 시작\|3.0 시작]]


## 3.1 - 역사적 관점 
### x86
- **Intel CPU 계열의 명령어 집합 구조**(ISA)
- Intel 8086 CPU에서 시작된 아키텍처의 계보로, 그것을 따르는 CPU 명령어 체계 전체를 의미
- **32비트 명령어 체계**로 되어있다.
	- 레지스터, 주소공간, 명령어 형식 등을 포함 
	  
- Intel, AMD 모두 **x86 아키텍쳐를 기반으로 CPU를 생산**한다

>[!QUESTION] X86-64 는??
>- **64비트 확장 명령어 체계**로, AMD가 가장 먼저 확장했다.
>- 32비트 CPU에 비해 더 많은 메모리 사용, 더 빠른 처리, 더 넓은 공간 등의 이점을 제공 
>- 종류 : AMD64(원조), Intel 64비트 

### x86 아키텍쳐의 흐름 

> x86 마이크로프로세서는 수십 년 동안 성장해왔다.
![Pasted image 20250728161801.png](/img/user/supporter/image/Pasted%20image%2020250728161801.png)
- 사진은 인텔 CPU의 트렌지스터 수를 그래프로 나타낸 것이다.
- **트렌지수터가 많으면 좋은 점** 
	- **더 많은 연산 가능** : CPU나 GPU가 한 번에 처리할 수 있는 작업이 늘어남 
	- **병렬 처리 향상** : 코어 수 증가, 스레드 수 증가 → 멀티태스킹 성능 상승 
	- **더 복잡한 회로 설계 가능** : 인공지능, 3D 게임, 고속 통신 등 고성능 연산 가능   
	- **캐시 메모리 확장** : CPU 내부의 **빠른 임시 저장소**도 트랜지스터로 구성됨 
	- 등등 

### 멀티 코어의 등장 
- Intel은 오래 걸렸지만 64bit로 전환하는 데 성공하며 꾸준한 단일 CPU의 속도향상을 이뤄왔다.
- 하지만, 이 과정에서 겪게 된 것은 "**칩의 전력 소모**"였다 💢
	- 당시 칩들은 100W에 육박하는 전력을 소모 ➡ 엄청 뜨거움
	- 더 높은 성능의 프로세스를 개발하려는데 전력을 더 소모하면 안된다고 판단
- **해결책 - 멀티 코어** 
	- 전력 소모같은 한계로 인해서 단일 프로세서로는 더 이상 빠르게 만들 수 없다고 판단하여 **'하나의 칩에 여러 개의 프로세스를 넣는' 멀티코어** 개념을 도입
	- 현대의 대부분 CPU는 여러 코어로 되어있을 것이다.

### 최신 프로세서의 구조와 특징 

#### 최신 칩 구조 
#CPU코어 #캐시 

- 일반 데스크탑 기준으로 **하나의 칩에 4개의 CPU 코어**가 들어있다.
- 이 **4개의 코어는 캐시 메모리를 공유 ➡ 효율성을 높임** 

![Pasted image 20250802192614.png](/img/user/supporter/image/Pasted%20image%2020250802192614.png)
#### 칩의 다양한 연결 포트들 
#하나의칩 #통합

>- ❌CPU는 단순 계산만 하는 것이 아니다.
>- ✅외부 장치와 직접 소통하는 **I/O 회로도 함께 포함**된다


![Pasted image 20250802193028.png](/img/user/supporter/image/Pasted%20image%2020250802193028.png)


| 포트 종류 | 기능                    |
| ----- | --------------------- |
| DDR   | DRAM같은 메인 메모리와 연결     |
| PCI   | 그래픽/사운드 카드 등 확장 장치 연결 |
| SATA  | SSD, HDD 같은 디스크 연결    |
| USB   | USB 장치 연결             |
| 이더넷   | 인터넷 및 네트워크 연결         |

> 이런 모든 포트 연결 기능이 **하나의 칩 안에 통합**되어 있다. 즉, 최근 CPU는 확장된 역할을 하게 된 것 



## 3.2 - 프로그램 인코딩 

`gcc -g -0g -o p p1.c p2.c`  
- 파일 p1.c, p2.c를 컴파일 한다고 가정할 때의 명령어 
- `-0g` : **디버깅 가능한 최적화 모드**로, 실전 디버깅할 때 많이 쓰이는 **실속형 옵셔너**. 디버깅을 위해 **중요 정보는 유지**, **가벼운 최적화**는 적용
	- 반면, `-01`, `-02`, `-03` 이거는 최적화 수준을 더 높인 것. **But** 이러면 원본 코드와 너무 달라서 이해하기 어렵도록 심하게 변환된 코드가 생성될 수 있다.
- `-o p` : 컴파일 결과 실행 파일을 p라는 이름으로 저장 
- `p1.c, p2.c` : 컴파일 할 C 소스 코드 파일들

### GCC 내부적으로 하는 일 

> 참고 : [[Computer_Science/Preview_CS/1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.\|1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.]]

#컴파일4단계

1. *전처리기 실행*
	- `#include, #define, typedef, extern` 과 같은 구문을 처리하여 **매크로를 확장하고 필요한 헤더 파일을 삽입**한다.
	- **주요 작업**
		- `#include` 로 지정된 **헤더 파일 삽입** 
		- `#define`으로 정의된 **모든 매크로 치환/확장**
		- **조건부 컴파일 처리** (`#ifdef` 등 )
	- 결과 : `?.i`라는 파일이 생성 (But 디스크에는 저장 ❌)
	  
2. *컴파일 단계*
	- 전처리된 코드(`*.i`)를 **어셈블리어 코드(`*.s`)로 변환**한다.
	- 문법 분석, 중간 코드 생성, 최적화가 수행된다. 
	- **최적화 옵션**  ex. 불필요한 명령어 제거 등
		- `-0g`같은 옵션이 있으면 **최적화를 적용**한다  (디버깅 친화적 최적화)
		- `-02, -03` : 성능 엄청 최적화 
	  
3. *어셈블 단계*
	- 어셈블리어 ➡ 실행 가능한 **기계어로 변환** 
	- **생성 파일** : 실행 불가능한 객체 파일(`.o`파일)
	- 아직 실행 불가능한 객체 코드 💢
	  
4. *링크 단계 
	- 여러 개의 목적 파일(`.o`)과 라이브러리를 **연결하여 하나의 실행 가능한 파일을 생성**한다
	- **주요 작업**
		- 함수 호출의 실제 위치 연결 (라이브러리와)

	- **결과**
		- 기본값 : a.out 
		- `-o filename` 으로 지정한 실행 파일 형태로 결과가 나온다. 


### 기계 수준 코드 

> 컴퓨터 시스템은 구현의 세부 사항을 숨기는 여러 가지 추상화 형태를 사용한다. 대표적으로 2가지를 볼 것 

#### 추상화 1. ISA
#명령어_집합구조
> 기계 수준 프로그램의 형식과 동작은 ISA(Instruction Set Architecture)에 의해 정의됨

- **정의**
	- CPU가 **이해하고 실행할 수 있는 명령어들의 집합(문법과 규칙)** 
	- H/W(CPU)와 S/W(프로그램) 사이의 **약속된 인터페이스** #계약서같은 
		- ISA는 CPU 설명서 같은 것 : 레지스터, 명령어 형식, 명령어 의미를 알려주고 각 명령어가 CPU 상태에 어떤 영향을 주는지 알려준다.
- **S/W는 이 ISA에 맞춰 코드를 짜거나 컴파일됨** 
- **컴파일러가 기계에게** 정확히 무엇을 해야 하는지 알려주는
- **CPU는 특정 ISA를 구현한다** ex. Intel Core i7 ➡ x86-64 ISA를 구현 	  
- **효과** ⭐⭐
	- 레지스터, 명령어 등의 복잡한 내부를 몰라도 쉽게 코드를 짤 수 있다.
- **종류** 
	- X86 : 인텔의 전통적인 복잡한 명령어 집합 
	- x86-64
	- ARM : 스마트폰, 테블릿 등에서 많이 사용. 효율적이고 단순 
	- RISC-V : 오픈소스, 최근에 각광 받는 중 


>[!tip] 컴파일러의 도움 
>- 컴파일러가 C코드의 추상적 실행 모델을 실제 기계 수준 명령어로 바꿔준다.
>- C에서 쓰는 `for`, `if`, `malloc`같은 추상 코드 ➡ **ISA 수준의 낮은 수준 명령어로 변환** 


#### 추상화 2. 가상 메모리 
> 기계 수준 프로그램에서 사용하는 메모리 주소는 가상 주소 

참고 
- [[Computer_Science/Preview_CS/1.7(1) 운영체제는 하드웨어를 관리한다\|1.7(1) 운영체제는 하드웨어를 관리한다]], [[Computer_Science/Preview_CS/1.7(2) 운영체제는 하드웨어를 관리한다\|1.7(2) 운영체제는 하드웨어를 관리한다]]
- [[Computer_Science/Virtual_Memory/Virtual Memory\|Virtual Memory]]

![Pasted image 20250715144758.png](/img/user/supporter/image/Pasted%20image%2020250715144758.png)
- C 코드에서 사용하는 포인터, 배열 인덱스 등은 **진짜 물리적 주소가 아니라 가상 주소**이다.
- OS와 H/W가 이 **가상 주소를 실제 주소와 매핑**해주는 것 


### 기계 코드 수준에서 드러나는 프로세서 상태 
> - 기계 수준 코드를 보면 C개발자는 볼 수 없는 프로세서 상태의 일부가 보인다.
> - 즉, C와 같은 고급 언어에서는 숨겨진 프로세서 내부의 상태를 **기계 수준에서는 직접 확인하고 제어해야** 하는 것이다(ex. C는 H/W 상태를 전혀 신경 안 씀) 
> - 예를 들어, 기계어를 조작하면 **추상화 되어 있던 H/W 자원이 구체적으로 드러날 것** 


#### 1. Program Counter(PC)
- **다음에 실행할 명령어의 메모리 주소를 보관**하는 **CPU 내부 레지스터** 
- 명령어가 실행될 때마다 변한다.
- x86-64 아키텍쳐에서는 이걸 `%rip`이라고 부름 (RIP = Register Instruction Pointer)
- **어셈블리에서는** 
	- Program Counter를 확인하면서 **분기 흐름을 정확히 추적할 수 있다.**

####  2. 범용 레지스터
> 프로그래머가 실제로 사용하는 부분 
- C언어에서 **변수, 주소, 함수 인자 등을 저장할 때 컴파일러가 이 레지스터들을 활용**한다.
- 단순, 함수 전달/리턴 값 저장 외에도 **스택 포인터, 기준 포인터 등 중요한 시스템에도 쓰인다.**
- **용도**
	- 연산 중간 결과 저장 
	- 포인터 주소 저장
	- 함수 인자 전달
	- 리턴값 저장
	- 스텍 프레임 관리 
	  
- **총 16개**  
	- 64비트까지 뭐든 담을 수 있는 16개의 명명된 위치가 포함되어 있다.
	- 각각 이름도 있다 ex. `%rax`, `%rbx`, `%rcx`
	  ![Pasted image 20250731140326.png](/img/user/supporter/image/Pasted%20image%2020250731140326.png)****
	- 각 레지스터가 뭘 하는지는 [[Computer_Science/Computer_Data/3.3, 3.4 - 데이터 형식, 정보 접근\|3.3, 3.4 - 데이터 형식, 정보 접근]] 에서 함 

#### 3. 조건 코드(상태 비트) 레지스터
- 몇 비트에 불과한 상태로 **최근 명령어의 결과를 나타낸다.**
	- **최근 명령어의 실행 결과에 따라 CPU 내부에 설정되는 Flag 비트들.**
	- 이를 바탕으로 **조건 분기 명령이 실행될지 여부를 결정** 하는 데 사용

	
#### 4. 백터 레지스터 세트
- **하나 이상의 정수 or 부동 소수점 값을 보관**할 수 있다.
	- **여러 개의 정수나 부동소수점을 한 번에 처리**할 수 있다
- **활용** : 이미지 처리, 영상 디코딩, 행렬 연산 등에서 필수 

### 컴파일 과정 : C ➡ 어셈블리 코드 
> **목표** : 컴파일의 기본 개념을 보여주는 함수를 통해 어떻게 변환되는지 확인할 것 

**✔기본 함수** 
```c
long plus(long x, long y);

vois sumstore(long x, long y, long *dest) {
    long t = plus(x, y);
    *dest = t;}
```

위의 C코드를 컴파일(`gcc -Og -S -o add.s add.c`)하면 아래처럼 된다
- `-S` : 어셈블리 파일(`.s`)생성 

**✔생성된 어셈블리어** 
> 참고 : 실제 어셈블리어는 아래처럼 깔끔하지 않음 
```asm 
sumstore:
	pushq  %rbx
	movq   %rdx, %rbx
	call   plus
	movq   %rax, (%rbx)
	popq   %rbx
	ret   
```
- `%r`로 시작하는 것들은 **레지스터의 실제 이름** 
- 각 명령어 의미
	- `pushq` : **스택에 무언가를 push**한다는 의미 
	- `mov` : 한 위치에서 다른 위치로 데이터를 **이동(복사)하는 것** 
	- `call` : 어떤 **프로시저를 호출**하는 것  *프로시저 : 하나의 이름으로 묶인 명령어(코드)의 집합*
	- `pop` : push의 반대 
	- `ret` : **현재 함수에서 나가고 값을 반환** 
- 레지스터 기반으로 동작(고속 저장 장치 저장소) 
- **간혹 `.`으로 시작하는 것들**이 있는데 이것들은 **실제 명령어가 아니라는 표시**이다.
	- `.`으로 시작하는 지시어는 디버그에 필요한 정보 or 링커에게 알려 주는 정보 등 굳이 신경 쓸 필요 없는 것들이다. 

> 당연히 이해하기 힘들 것. 지금은 그냥 이런게 이렇게 변하는구나 정도만 이해 ㄱ 




### 어셈블리어(기계어) 특징 (vs C)

#### 특징 1. 일련의 바이트 취급  

|                   | C언어                                              | 기계어                               |
| ----------------- | ------------------------------------------------ | --------------------------------- |
| 타입별 선언/메모리        | 서로 다른 데이터 타입(int, float) 선언하고 메모리에 저장            | 메모리는 단순히 큰 바이트 배열일 뿐 **타입 개념 없음** |
| 집합(배열/구조체) 데이터 처리 | 타입별로 메모리 해석을 다르게 한다.                             | 집합도 **단순히 연속된 바이트일뿐**             |
| 스칼라 데이터 유형 처리     | `int`, `unsigned int`, `int*` 등 부호/포인터 여부 엄격히 구분 | 그냥 **전부 비트어리 취급**                 |

>[!tip] 정리
>- **C 언어** : 타입 기반 추상화
>- **기계어** : 물리적 메모리 주소 기반 처리 


> 머신이 실행하는 프로그램은 **단순히 일련의** 명령어를 인코딩하는 **바이트 시퀀스**

#### 특징 2. 명령어 기능 매우 제한적 
- ❌**동시에 여러 명령어를 할 수 없다**. (ex. 데이터 이동과 연산 동시에 불가)


### 디스어셈블링을 통한 기계어 수준 해석

> 기계어(바이너리 코드)를 사람이 읽을 수 있는 **어셈블리어**로 역변환(reverse translation)하는 프로그램 또는 기능
- ✅오직 **바이트 시퀀스에만 기반하여 어셈블리 코드를 결정** 
- **❌프로그램 소스 접근 불가** 
- gcc가 생성한 어셈블리 코드와 약간 다른 명령어 명명 규칙을 사용. ex. 접미사 생략 

```bash
linux> objdump -d prog  
# prog = 디스어셈블리 할 파일명 
```

 
![Pasted image 20250731125616.png](/img/user/supporter/image/Pasted%20image%2020250731125616.png)
- 위는 기계어로 변환된 파일을 어셈블리어로 추출한 내용이다.
- **각 명령어의 Byte도 표시**되어 있다 (표시 하나당 `1byte`)
	- ex. 53 -> 1byte,  48 80 d3 -> 3byte
- **❌디스어셈블러는 원본 소스에 접근 불가**
	- 그래서 원본 소스의 변수는 다 사라짐 
- 기계어, 어셈블리어를 알면 이 내용을 해석할 수 있음
- **해석 예시** 
	- 최종 메모리 주소 : `0000~~~400540 <multistore>` ⬅ 이를 링커가 해준 것 
	- 함수간 호출 연결을 링커가 해줬다 : `callq 40058b <mult2>`
		- 컴파일 단계에서는 다른 함수의 정확한 위치를 몰라서 call 명령어는 비어있는 상태이다.
		- 하지만 링크는 이 위치를 알고 있으므로 call 명령어에 대한 정확한 상대 주소를 채워 넣어서 저렇게 된 것 

> 이렇게 **머신의 저수준 기능에 접근하기 위해서**는 **어세블리 코드로** 직접 내려가야 한다.

> [!INFO] 어셈블리 코드 형식은 1가지가 아니다.
> - 기본적으로 gcc, objdump 등은 기본 형식인 ATT로 어셈블리 코드를 보여준다.
> - 하지만, MS or Intel의 문서는 Intel형식의 어셈블리 코드를 보여준다.
> 	- Intel형식 코드 보려면 `gcc -Og -S -masm=intel mstore.c`


### 프로그램 메모리 구조 


메모리 영역 구성 중 일부
![Pasted image 20250729130102.png](/img/user/supporter/image/Pasted%20image%2020250729130102.png)

| 영역                              | 설명                                                                    |
| ------------------------------- | --------------------------------------------------------------------- |
| **실행 코드 영역**                    | **실행 가능한 기계 명령어**가 포함되어 있다.<br>(값이 변하지 않는 데이터)                        |
| **데이터 영역**                      | 전역/ 정적 변수를 저장<br>(값이 변하지 않는 데이터)                                      |
| **OS 정보 영역** <br>(커널, 공유 라이브러리) | 시스템 호출, 라이브러리 참조 등 관리 정보 포함                                           |
| **스택 영역**                       | **함수의 호출**과 관계되는 **지역변수, 매개변수, 리턴 주소 등**이 저장되는 영역. (함수 호출이 완료되면 소멸 됨) |
| **힙 영역**                        | 프로그래머가 **할당/해제하는 동적 메모리 공간** (`malloc`, `calloc`)                     |

> 위의 메모리는 CPU가 직접 접근하는 것이 아니라 가상 주소와 가상 테이블을 통해 접근된다.
> **프로그래머가 사용하는 모든 주소는 OS가 제공한 가상주소이다**

### 가상 주소를 사용하는 이유 
링크 : [[Computer_Science/Virtual_Memory/Virtual Memory\|Virtual Memory]]

### X86-64 가상 주소 특징 

- 주소 크기는 **64bit** 인데, ⭐But **실제로는 하위 48bit만** 사용(상위 16비트는 전부 0 or 1로 고정)
- 즉, 주소 공간 : $2^{48}$ = 256TB 
- 실제 대부분의 프로그램은 MB ~ GB만 접근하기에 이렇게 








