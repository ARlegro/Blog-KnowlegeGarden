---
{"dg-publish":true,"permalink":"/Computer_Science/Memory_Hierarchy/6.1-저장장치 기술(2)/","noteIcon":"","created":"2025-12-03T14:52:45.534+09:00","updated":"2025-12-13T18:25:26.723+09:00"}
---


이전 : [[Computer_Science/Memory_Hierarchy/6.1-저장장치 기술(1)\|6.1-저장장치 기술(1)]]

> 비휘발성 메모리를 공부할 것 
--- 
## 비휘발성 메모리 
### 개념 
> **전원이 꺼져도 데이터가 유지**되는 모든 종류의 메모리를 통칭 
- DRAM과 SRAM이 아무리 좋아봤자 휘발성이다. 즉, 전원이 꺼지면 말짱 도루묵
- 반면, **비휘발성 메모리는 전원이 꺼져도 정보를 유지한다.(데이터 영구 보존)**
- 비휘발성 메모리는 종류도 다양해서 기술도 각기각색이다.
- 종류 
	- **ROM(Read Only Memory)**
	- Flash Memory
	- HDD, SSD 
	- CD, DVD 
	

>[!QUESTION] 왜 쓰기가 가능한데 "XXX ROM"❓
>- ROM이라고 하면 Read-Only Memory의 줄임말인데 ROM이라는 접미사가 붙은 메모리들이 전부 쓰기가 불가능한 것이 아니다. 
>- 단지, **초기에는 읽기 전용**으로 만들어서 ROM이라고 접미사를 붙였다가 **기술이 좋아지면서 쓰기 기능이 추가 된** 케이스 

--- 

### 발전 과정
책에 언급된 순서대로임
1. PROM
	- 사용자가 한 번만 데이터를 기록할 수 있는 ROM
	- ❌데이터 수정이 불가능 
	  
2. EPROM(Erasable PROM)
	- PROM의 단점 극복 : **강한 자외선(UV)** 을 쏘면 **데이터 전체를 지울 수** 있어서, 다시 기록 가능
	  
3. EEPROM(Electrically Erasable PROM)
	- *바이트 단위*로 지우고 쓰기 가능 
	  
4. **Flash Memory**
	- EEPROM 기반으로 변형된 저장장치 기술
	- **블록 단위**로 **빠르게** 지우고 쓰기 가능 
		- 블록 : 여러 개의 Byte로 이루어진 묶음
		- 블록 단위 처리 ➡ **대용량 저장/쓰기에 적합** 
	- 이러한 강력한 장점 때문에 Flash Memory는 SSD, 스마트폰 저장장치 등 주요 저장 매체로 자리 잡음(SSD는 뒤에서 다시 공부할 것)

--- 
### 추가 : 펌웨어 (너무 깊이 ㄴㄴ)

책 일부 : **ROM에 저장된 프로그램들**은 종종 '**펌웨어**'라고 부른다.

> H/W와 S/W 2가지의 성격을 가짐 
> - 펌(머리) : 단단하지는 않고 부드럽지는 않은 

#### 개념 
- **H/W를 제어하고 작동**시키는 S/W
	- H/W에 대한 저수준 제어가 가능하다. 
	- 이러한 제어를 통해 H/W가 S/W의 명령을 이해하고 실행할 수 있도록 한다.
	  
- S/W - H/W의 중간 다리 역할 ![Pasted image 20250811124424.png](/img/user/supporter/image/Pasted%20image%2020250811124424.png)
- **ROM에 저장**된다 Cuz 전원이 꺼져도 지워지지 않아야 하므로 

*종종 버그 수정, 기능 향상을 위해 펌웨어 업데이트하라고 뜸*

#### 주요 특징 
1. *시스템 부팅 및 H/W 구동* 
	- 펌웨어는 전원이 켜진 직후, H/W와 OS보다 먼저 실행 됨
	- PC의 대표적인 **펌웨어인 BIOS**를 예시로 들자면:
		1. 전원 ON ➡ **BIOS가 실행**
		2. BIOS는 CPU/RAM/HDD/모니터 등 주요 **H/W 장치들을 점검**
		3. BIOS는 H/W 초기화 및 기본 설정을 적용
		4. 이 과정이 끝나면 **OS를 불러와 컴퓨터를 부팅**
	  
2. *S/W적 성격*
	- 프로그램 형태로 존재하며, 특정 기능을 수행하도록 설계됨
	  
3. *H/W와 S/W 연결*
	- OS와 H/W간의 통신을 가능하게 한다.
	- *Note : OS도 S/W이다*
	  
4. *H/W에 내장되어 있다*
	- 비휘발성 메모리(ROM, Flash Memory)에 저장 됨 
	  

---

## 메인메모리 접근 
#버스 
![Pasted image 20250811152248.png](/img/user/supporter/image/Pasted%20image%2020250811152248.png)

### 들어가기 전 : 시스템 버스 
*버스 개념은 네트워크에서 자세하게 배울걸?*

#### 개념 
> 컴퓨터 구성 요소들 사이에서 **데이터를 전송하고 제어 신호를 주고받는** 역할 
> - 즉, 핵심 부품들을 **연결**하고 원할히 **소통하는 공유 전기 통로** 
> - 두 개 이상의 장치들이 버스를 공유할 수 있다 (설계하기 나름)

![Pasted image 20250811154522.png](/img/user/supporter/image/Pasted%20image%2020250811154522.png)

>[!QUESTION] 왜 굳이 버스로 만들었는가? (직접 연결 없이)
>- 여러 장치가 하나의 버스(회로)를 공유할 수 있기 때문에 매우 효율적


#### 종류 
시스템(컴퓨터) Bus는 크게 3가지 종류로 나뉜다.
![Pasted image 20250811153215.png](/img/user/supporter/image/Pasted%20image%2020250811153215.png)
1. *Data Bus*
	- **실제 데이터를 전송**하는 통로 
	- **양방향** 전송 가능 
	- **언제 쓰는가❓**
		- CPU, 메모리, 주변 장치 간에 **데이터를 주고받을 때** 사용 
	  
2. *Address Bus*
	- 데이터의 **위치(주소)를 지정**하는 통로
	- **단방향** 전송만 가능 
	- **언제 쓰는가❓**
		- CPU가 **특정 주소의 데이터를** Memory에 **요구**할 때
		- CPU가 **특정 주소에 데이터를 저장**하라고 명령할 때 
	  
3. *Control Bus* 
	- 읽기/쓰기 같은 **시스템 작동을 제어하는 신호를 전달**하는 통로 
	- 각 장치의 **동기화 타이밍 조절**할 수 있음 


### 데이터 교환 
데이터는 CPU와 메인 메모리가 **'Bus'라고 불리는 공유된 전기회로를 통해서** 주고받는다. 
- 데이터 읽을 시 : 메인 메모리 ➡ CPU
- 데이터 쓰기 시 : CPU ➡ 메인 메모리

#### 구조 사진
![Pasted image 20250811160356.png](/img/user/supporter/image/Pasted%20image%2020250811160356.png)
- *주요 컴포넌트*
	1. *CPU*
	2. *I/O Bridge*
		- CPU와 여러 I/O 장치를 연결하는 H/W 인터페이스 (나중에 자세히 배움)
		- 데이터 전송 관리 및 프로토콜 변환 담당 
		- **시스템 버스의 전기적 신호를 메모리 버스의 전기적 신호로 변환** 
		  
	3. *메인 메모리*

- *Bus*
	1. *시스템 버스* : [[Computer_Science/Memory_Hierarchy/컴퓨터의 동작 과정\|컴퓨터의 동작 과정]]
	2. *메모리 버스* 
		- CPU와 메인메모리를 연결하는 **전용** 통신 경로
		- 메모리로 가는 전용 진입로 (다른 목적지로 가는 데이터랑 충돌 ❌)
		- CPU가 메모리에 데이터를 읽고 쓰는 데 특화된 서비스 

#### 예시 - 옛날 방식임 
> 예시 : CPU가 `movq A, %rax` 인스트럭션 처리 
> - 주소 A의 내용을 `%rax`에 로드하는 것 

![Pasted image 20250811161724.png](/img/user/supporter/image/Pasted%20image%2020250811161724.png)
1. *읽기 트랜잭션* 
	- CPU내의 Bus Interface 회로에서 **읽기 트랜잭션 시작** 
	- CPU가 읽고 싶은 데이터의 **주소 A를 System(Address) Bus에** 보냄 ➡ 또한 CPU가 **System(Control) Bus에 제어 신호**(읽기)를 보냄 ➡ I/O Bridge는 이 신호를 Memory Bus용 **신호로 변환**한 후 Memory Bus에 **보냄** 
	  
2. *주소 읽고 값 반환*
	- 우선, 메인 메모리는 Memory Bus에서 제어 신호를 받는다(대기 상태)
	- 그렇게 기다려서, Memory Bus에서 **주소를 읽는**다 ➡ 그 주소에 해당하는 **값을 찾아** 다시 Memory Bus에 **쓴다** 
	- I/O bridge는 여기서도 **신호 변환**을 해주고 **System(Data) Bus에 전달** 
	  
3. *감지 및 복사*
	 - CPU는 System(Data) Bus에 데이터가 있는 것을 감지한 후 
	 - 그 데이터를 읽은 뒤 `%rax`라는 레지스터에 복사한다.

 > `movq A, %rax` 하나의 명령어에도 여러 Bus가 쓰였다

*최근 CPU 바뀐 점 : [[Computer_Science/Memory_Hierarchy/CPU-메모리 상호작용(옛날 vs 최근)\|CPU-메모리 상호작용(옛날 vs 최근)]]*

--- 

## 입출력 장치 연결 
입출력장치 ex. 모니터, 그래픽카드, 마우스, 키보드, 디스크 등 

> 입출력(I/O) 장치들은 CPU, 메인메모리와 연결하기 위해 **I/O Bus를 이용**한다.<br>
> 즉, I/O Bus = I/O 장치들을 CPU와 메인 메모리에 연결하는 Bus


---
### I/O 버스 구조 및 특징 
#저속 #저비용 #저전력 #멀티플렉싱 


#### 버스 구조 
아래의 사진 = Bus 구조 (CPU-메인메모리-IO디바이스 를 연결하는)
![Pasted image 20250812000822.png](/img/user/supporter/image/Pasted%20image%2020250812000822.png)
- Mouse, SSD, Key-board, 디스크 등의 **장치들이 CPU와 메인메모리에 연결**하기 위해 사진에서 보이는 **I/O Bus를 이용**한다.

---

#### 특징 
- **I/O Bus는 3저(저속/저비용/저전력)**
	1. *저속*
		- System Bus보다 **대역폭이 작으며 속도가 느리다.**
		- 당연한 거지만, HDD-마우스-프린트보다 CPU가 빠르듯.
		  
	2. *저비용*
		- 고속/광속이 필요가 없으므로 설계/동기화에 비용이 적음 

	3. *저전력*
		- 높은 속도도 필요없고 대역폭도 적게 필요하므로 
			
- **멀티 플렉싱 구조**이다 (Multiplexing)
	- *멀티 플렉싱 = 여러 개의 신호를 하나의 전송 매체를 통해 동시에 전달하는 기술*
	- 위의 구조는 **여러 장치들이 I/O 버스를 공유**하는 구조 
	- 따라서, 동시에 전송 요청이 들어오면 중재가 필요 ➡ 지연 발생 
	  
- **CPU와 독립적**이다.
	- 특정 CPU에 종속되지 않는다 ➡ 다양한 장치들과 호환 

>[!tip] 속도는 느리지만 유연성이 강점(여러 장치들을 수용 가능)

---

#### 추가 : I/O 버스에 연결되는 장치들
위의 사진을 보면, **I/O 버스에는 다양한 장치들이 연결되어** 있다. 
> [!WARNING] But 단순히 바로 연결되는 것이 아니라, 각각의 컨트롤러 or 어뎁터를 통해 Bus와 통신한다. 

1. **USB 컨트롤러** 
	- USB Bus에 있는 **다양한 USB 장치들을 I/O Bus에 연결시키는** 역할 
	- ![Pasted image 20250812011742.png](/img/user/supporter/image/Pasted%20image%2020250812011742.png)
	  
2. **그래픽 카드(or 그래픽 어댑터)**
	- 데이터를 받으면 CPU를 대신하여, **모니터에 픽셀을 건드리고 색칠하는 역할**을 하는 H/W and S/W 로직을 포함 
	- **단방향** (From I/O Bus)
	  
3. **Host Bus Adapter**
	- Disk Drive를 I/O Bus에 연결  
	- 양방향
	- 뭐... 이 이상 자세하게 알 필요 없는 듯? 

