---
{"dg-publish":true,"permalink":"/Computer_Science/Memory_Hierarchy/6.1-저장장치 기술(3)-SSD/","noteIcon":"","created":"2025-12-03T14:52:45.563+09:00","updated":"2025-12-13T18:25:26.730+09:00"}
---


## SSD 
*Solid State Disk*
참고 : [삼성반도체](https://semiconductor.samsung.com/kr/support/tools-resources/dictionary/semiconductor-glossary-solid-state-drive-ssd/)

### 개념 
> 디스크가 아닌 **메모리 반도체를 저장매체**로 사용하는 **차세대 대용량 저장 장치**

- 핵심 : 디지털 방식으로 반도체 칩에 데이터가 저장됨 
- HDD와 같은 역할인 **보조기억장치** 
- 노트북이나 컴퓨터에서 **흔히** 볼 수 있는 저장장치.
	- 배그 등의 고성능이 필요한 게이밍에 SSD가 쓰인다면 화면이 끊기지 않을 수 있다.
- **종류가 많다**
	- 필요한 상황에 따라 다양하게 쓰일 수 있다.
	- 사용 방법에 따른 : PC/Laptop 용, 기업용, 휴대용(Portable) 등 
	- 목적에 따른 : 저장 최적화된 or 연속쓰기에 최적화된 SSD, 읽기에 최적화된 SSD


### 주요 구성 요소
> SSD의 구성요소를 보면 CPU/메모리/기억장치 등으로 구성된 **컴퓨팅 시스템과 유사**
![Pasted image 20250812014854.png](/img/user/supporter/image/Pasted%20image%2020250812014854.png)
1.  *NAND Flash*
	- 데이터 저장용 메모리 
	- 전원이 꺼지더라도 기록된 데이터가 사라지지 않는다 ⭐
	- 대용량 처리 가능 
	  
2. *Controller*
	- 책 曰 : 인터페이스와 메모리 사이의 데이터 교환 작업을 제어 ....
	- 걍 쉽게 ➡ **외부에서 들어온 명령어를 해석하고 처리하는 역할 (머리)**
	- 데이터를 빠르게 읽고, 쓰고, 에러를 수정해서 SSD의 성능을 높임 
	  
3. *DRAM*
	- 데이터를 임시로 저장하는 공간
	- 여기에 저장된 데이터는 전원이 꺼지면 날아감  

>[!QUESTION] 왜 비휘발성 메모리가 있는데 휘발성 메모리(DRAM)를 탑재?
>- **SSD의 성능을 향상**시키기 위해 DRAM을 사용 
>- NAND Flash는 데이터를 읽고 쓰는 속도가 DRAM보다 훨씬 느림
>- 즉, DRAM이라는 **임시 저장소**를 두어 **빠른 데이터 접근**을 활용해 SSD **성능을 향상**시키는 것이 목적


### 특징 
>[!tip] **반도체 기반 저장** 
 > HDD : 회전하는 디스크에 데이터를 저장  
 > SSD : 반도체 칩에 데이터를 저장 ⭐

![Pasted image 20250812020253.png](/img/user/supporter/image/Pasted%20image%2020250812020253.png)
#### 1. 높은 속도
HDD에서는 데이터를 찾으려면 디스크를 돌아야 했다. 

> SSD는 **전기 신호로 데이터를 읽고 쓴다** ➡ 이로 인해 매우 빨라짐
> - 이는 Controller(두뇌), NANA Flash(저장소) 조합 덕분
> - 부팅 속도, 프로그램 실행 속도, 파일 전송 속도 등 매우~ 빠름


#### 2. 저소음/저전력 
HDD와 달리 **움직이는 부품이 없어 소음이 적고, 전력 소모가 낮다.**<br>
>[!QUESTION] 움직이는 부품이 없다?
>이 말은 디스크나 모터같이 돌아가는 장치 없이 **반도체 칩만으로 작동**하기 때문에 

>[!danger] HDD라면?
>- HDD는 **모터를 사용하여 디스크를 고속으로 회전**하면서 데이터를 처리한다
>- 따라서, **소음 발생 + 전력 소모 多 + 발열 동반** 

#### 3. 높은 안정성
1. *데이터 안정성*
	- **비휘발성** 메모리인 **낸드 플레시 메모리(반도체)에 정보를 저장**하기 때문에 안정적
	  
2. *물리적 안정성*
	- 물리적 충격에 매우 강함 


#### 4. 비쌈 
> 좋고 가격도 줄어드는 추세지만 **여전히 비쌈.** 


### 기본구조 + 읽는 속도가 쓰는 속도보다 빠른 이유  ⭐
![Pasted image 20250812095351.png](/img/user/supporter/image/Pasted%20image%2020250812095351.png)

>[!EXAMPLE] Page, Block
>Flash 메모리에서 Page, Block은 **데이터 저장 구조의 기본 단위**이다.
>1. *Page*
>	- 기본 크기 : 4KB (4096 Byte)
>	- 각 Page는 주소를 가지고 있다.
>	- 예시
>		1. 10KB 크기 데이터 저장 시 ➡ 3개의 페이지 필요
>		2. 1KB 크기 데이터 저장 시 ➡ 1개의 페이지 필요
>2. *Block*
>	- **여러 Page를 포함**하는 더 큰 **데이터 저장 단위** 
>	- 기본 크기 : 256KB(64개 Page)
>	- 각 Block 은 주소를 가지고 있다.


### 읽기 vs 쓰기
> 핵심
> - 데이터 읽고/쓰기 : 페이지 단위
> - 데이터 삭제 : 블록 단위 (쓰기 과정에서 必)
> 	- 이유 = Page는 덮어쓰기가 안됨 

1. *읽기 - 매우 간단하고 빠름*
	- SSD에서 데이터를 찾는 것은 매우 간단. 
	- 원하는 **페이지의 주소를 찾아서 그 내용을 곧바로 읽어오면** 됨 
	  
2. *쓰기 - 느림*
	- 쓰기 작업은 읽기 작업보다 복잡하고 시간이 더 오래걸림 
	- **이유 1. 지우기 과정 높은 비용**
		- SSD에서 지우기는 **블록 단위**로 이루어진다(❌페이지 단위가 아님)
		- 즉, 일부 페이지 데이터만 지우려해도 **블록 전체를 지워야 하므로 읽는 것보다 훨씬 느림** 
		  
	- **이유 2. 페이지 수정 시 느림** 
		- ❌SSD는 페이지 단위 수정이 불가능 ➡ ***블록 단위***로 해야 함 ✅
		- ❓근데 블록 중 **일부 페이지만 수정**하고 싶다면❓아래와 같은 복잡한 작업이 필요
			1. ***새로운 블록을 찾는다.***
			2. 기존 블록 중 수정하지 않을 페이지를 ***새로운 블록으로 복사***한다
			3. ***새로운 블록의 빈 페이지에 수정된 데이터를 쓴다***
			4. 기존 블록은 나중에 지워진다.

>[!tip] 쓰기 과정 그림 
![Pasted image 20250812101112.png](/img/user/supporter/image/Pasted%20image%2020250812101112.png)
![Pasted image 20250812101258.png](/img/user/supporter/image/Pasted%20image%2020250812101258.png)


### 쓰기 동작 비교 - 순차 쓰기 vs 랜덤 쓰기 
> SSD 쓰기 동작은 '**순차 쓰기**', '**랜덤 쓰기**' 2가지 패턴으로 나뉘는데, 그것을 공부할 것

#### 0. 이전 Block Review
앞서 설명한 쓰기 과정은 여러 경우일 수 있다.
1. 진짜 기존 데이터를 수정하는 경우 일수도 있고,
2. 단순히 새로운 데이터를 쓰려다가 해당 위치에 이미 데이터가 있어서 복잡한 절차(읽기 ➡ 수정 ➡ 삭제 ➡ 쓰기)가 필요한 경우일 수도 있다.
   
>[!QUESTION] 그렇다면 왜 굳이 이미 차지하고 있는 곳에 와서 이런 번거로운 과정을 거치는지 의문이 생길 수 있다.
>- 그 이유는 SSD는 실사용 환경에서 대부분 랜덤 쓰기 패턴이 발생하기 때문에 저런 일이 빈번하다 


#### 1. 순차 쓰기 
> 데이터가 **연속된 주소에 차례대로 기록**되는 쓰기
> - ex. 0번 블록 쓰기 -> 1번 블록 쓰기 -> 2번 블록 쓰기 

- *빠른 속도*
	- 이러한 순차 쓰기는 지역성의 원리에 따라 **매우 빠르다**
	- 블록/페이지가 깔끔하게 채워져 추가적인 작업이 적다.
	- 자주 or 같이 쓰이는 데이터끼리 하나의 블록에 몰아 넣으니까 **지울 때도 한번에 지우기 편함** 
	  
- *효율성*
	- 블록/페이지가 깔끔하게 채워져 공간도 효율적
- *언제 좋을까❓*
	- 관련된 데이터들을 관리해야 할 때 
	- ex. 동영상 파일, 대용량 파일 복사 ➡ 연속적 기록이 유리 


#### 2. 랜덤 쓰기 (多)
#쓰기지연 #갱신多
#성능저하 

> 메모리에 데이터를 **무작위로 쓰는 것** 
> - 특정 순서 없이 메모리 주소에 데이터를 저장
> - 랜덤은 알아서 OS가 해주겠지

**성능 저하의 주된 원인**이다. 이유는, 데이터를 덮어쓰거나 수정하는 **페이지 갱신 자주 발생**해서 SSD의 복잡한 쓰기 과정(위에서 언급했던)을 겪어야 함 ➡ 쓰기 지연* 

1. *Page 갱신이 자주 발생* 
	- 자주 or 같이 쓰이는 데이터라도 **멀리 떨어진 주소, 블록에 기록**하기 때문에 블록 전체가 아니라 일부 페이지만 수정해야 하는 상황이 잦다
	  
2. *GC(Garbage Collector) 빈번*
	- SSD Flash Memory는 덮어쓰기가 안되므로 복사/GC 비용이 많이 듬 
	- **GC는 Block 단위로만 삭제가 가능**하기 때문에, Block 안에 Garbage Page가 생기면 복잡한 과정(새 블록 찾기 + 복사 + 다시 쓰기)을 겪어야 해서 **효율이 떨어짐**💢
	- Garbage들은 가능한 한 곳에 몰아 넣는 것이 효율적 
	  
3. *쓰기 증폭/지연 발생* - SSD의 수명 단축 원인 
	- 랜덤 쓰기 시 이전에 언급 했던 복잡한 과정을 자주 겪게 된다.
	- 이는, 실제로는 x만큼만 데이터를 쓰려고 했는데 내부에서는 x+y+z 만큼의 데이터를 다루고 쓰여지는 현상이 발생한다. 이것이 바로 "**쓰기 증폭**"
	- 이렇게 실제 데이터보다 많은 쓰기 작업이 필요하면 시간이 지연되는데, 이것이 바로 "**쓰기 지연**"

>[!QUESTION] 왜 굳이 랜덤쓰기를 하는가❓(+ 언제 발생하는가)
>- OS, 파일시스템, 프로그램 동작 특성이 그럼
>	- 파일 시스템 : 파일 저장/수정 시 실제 데이터와 메타데이터가 **다른 위치에 기록될 수** 있음 for 남는 공간 활용, 외부 단편화 해소
>- 또한, 우리가 컴퓨터를 사용하는 패턴 또한 랜덤 쓰기를 유발 ex. 파일 일부 변경, 캐시데이터 수시 변경 
>- 파일이 조각화 되는 과정을 이해하면 **랜덤쓰기가 되는 이유**를 알기 쉽다
>	1. 초기에는 *비슷한 파일끼리 근처 블록 차지* 
>	2. *수정*시 새로운 Block으로 이동
>	3. 비슷한 *Block끼리 거리가 멀어짐*
>	4. 결국 *한 파일이 물리적으로 여러 Block/페이지에 흩어짐* 
>- ❌조각화 과정을 보면 한 파일을 한 Block or 근처 Block에 **몰아 넣는 것은 거의 불가능** 
>- 따라서, **수정이 잦은 DB, OS, 응용 프로그램 등** 대부분의 프로그램에서는 **어쩔 수 없이 랜덤쓰기가 발생**하게 되는 것 
 

>[!tip] 이렇게 자주 일어나는 랜덤쓰기를 얼마나 효율적으로 만드는 것이 성능의 핵심


추가 : 랜덤 쓰기는 HHD보다 SSD가 빠르다네?
- HDD는 랜덤으로 읽기/쓰기 할 때마다 헤드가 물리적으로 움직여야 해서 느림
- 반면, SSD는 **전기 신호로 데이터에 접근**해서 **랜덤쓰기에 최적화된 H/W**



### Flash Translation Layer(FTL)
> 비효율적인 쓰기 과정을 보완하기 위해 SSD 제조사들은 FTL이라는 기술을 개발했다.

![Pasted image 20250812095351.png](/img/user/supporter/image/Pasted%20image%2020250812095351.png) 
- FTL은 **복사/지우기 작업을 최소화하도록 관리**한다
- 근데.. 아무리 발버둥 쳐도 한계가 있긴 함 

너무 깊이 ㄴㄴ 
- 그냥, SSD의 한계(덮어쓰기 불가능)를 극복하려고 노력해서 만든 산출물이 FTL(뭐.. 좀 더 효율적이라나)

