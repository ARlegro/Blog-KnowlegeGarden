---
{"dg-publish":true,"permalink":"/Computer_Science/Preview_CS/1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다./","noteIcon":"","created":"2025-07-11T23:14:08.909+09:00","updated":"2025-07-24T20:21:46.312+09:00"}
---



>[!tip] 컴파일러 및 인터프리터 설계의 핵심 원리

#### 번역프로그램의 필요성 
#고수준-기계어
- 고수준 언어(Java, C++, Python)로 작성된 프로그램을 CPU가 바로 실행할 수 없다.
- 이를 **"기계어"로 바꾸는(번역하는) 작업이 반드시 必**
- 이 작업을 수행하는 것이 바로 "**번역 프로그램**"

## 컴파일 시스템 

![Pasted image 20250714221538.png](/img/user/supporter/image/Pasted%20image%2020250714221538.png)

C언어 소스프로그램이 실행 가능한 프로그램으로 변환되는 과정은 4단계에 걸쳐서 진행된다.
이렇게 실행하는 프로그램들을 합쳐서 "**컴파일 시스템**"이라고 부름 

### 1단계 : 전처리 단계
> 원본 C 소스 프로그램 ➡ 수정된 소스 프로그램 

- 실제 컴파일이 시작되기 전 **소스코드를 정리하고 준비**하는 역할 
- **역할**
	- **조건부 컴파일** : `#`지시문을 사용하여 특정 조건에 따라 코드의 일부를 포함 or 제외
	- **다른 파일 포함** : `#include` 지시문을 사용하여 다른 파일의 내용을 현재 파일로 가져옴
	- **매크로 확장** : `#define`으로 정의된 메크로를 실제 코드로 대체 (문자열 치환 같은 것)
- 일반적으로 `.i`로 끝나는 새로운 C프로그램 파일(텍스트 파일)이 생성된다.

### 2단계 : 컴파일 단계
> 전처리된 소스 프로그램(`hello.i` - 텍스트) ➡ 어셈블리 프로그램(`hello.s`- 텍스트)
- C언어 같은 고수준 언어 코드를 **어셈블리어 코드로 변환**한다.
- 이렇게 변환된 어셈블리어 코드는 특정 CPU의 명령에 직접적으로 대응할 수 있다.

### 3단계 : 어셈블리 단계
> 어셈플리어 프로그램 ➡ 바이너리 형식 프로그램(재배치 가능 오브젝트)

- 어셈블리어 코드를 기계어로 변환 : CPU가 직접 실행할 수 있게 한다 
- 변환된 기계어 코드는 0,1의 바이너리 형태이며, 보통 '재배치 가능 오브젝트 파일'이라는 형식으로 저장된다.

> [!WARNING] 기계어로 변환되어도 아직 독립적으로 실해되지 못한다 
> - ❌이런 오브젝트 파일은 아직 완전한 실행 파일이 아니다 
> - ✅다른 오브젝트 파일 OR 라이브러리 함수와 연결되어야 한다.
### 4단계 : 링크 단계
> 재비치 가능 오브젝트 와 외부 라이브러리 오브젝트 ➡ 실행 가능 오브젝트 

- 프로그램 내의 외부 함수와 전역 변수의 실제 정의가 들어있는 **다른 오브젝트 파일  or 라이브러리 파일들을 찾아 연결**한다 
- **완전 실행 가능한 실행 파일로** 만든다 By 모든 코드와 데이터 조각을 하나로 합쳐서
- 이렇게 만들어진 실행가능 목적파일(실행파일)은 메모리에 적재되어 시스템에 의해 실행된다.

---

## 번외 : 번역 프로그램의 2가지 주요 형태 

### 1. 컴파일러 
>고수준 언어를 기계어로 변환 + 빠른 실행 속도 제공 

---
#### 정의 
소스코드 **전체를 한꺼번에 읽어**들여, 컴퓨터가 직접 실행할 수 있는 **기계어 코드(실행 파일)로 변환**하는 프로그램 (컴파일 해줌)

---
#### 작동 과정
1. **소스 코드 읽기** 
	- `.c`, `.java`, `.cpp` 등의 파일을 읽는다.
	  
2. **분석 및 최적화**
	- 소스 코드를 분석하여 **문법 오류**를 발견
	- 더 효율적인 코드를 생성하도록 **최적화**  ex. 실행되지 않을 코드 제거, 상수 미리 계산 , inLine
	  
3. **기계어 코드 생성**
	- 2번에서 분석된 내용을 바탕으로 컴퓨터 아키텍쳐에 맞는 기계어(바이너리) 코드를 생성
	  
4. **실행 파일 생성** 
	- 생성된 기계어 코드를 `.exe`과 같은 독립적 실행 파일로 만든다.
---
#### 특징
- 실행 전 번역된다
- **빠른 실행 속도** 
	- **컴파일된 실행 파일은 별도의 해석 과정 없이 바로 실행**되기에 인터프리터보다 실행 속도가 빠르다.
	  
- 오류 검출 기능 제공 
- **최적화 기능** ➡ 실행 속도 향상 or 메모리 사용량을 줄임 
---
#### 단점 

1. **전체 컴파일을 해야 한다**
	- 오류 수정 후 재 컴파일 시 전체 컴파일 
	- 이로 인해, 코드 수정 및 테스트 과정이 오래
	  
2. **플랫폼 종속적이다**
	- 생성된 기계어 코드는 os에 종속적이다.
	- 다른 OS라면 해당 플랫폼에 맞게 컴파일해야 함 (Docker로 해결)

>[!tip] 참고: 자바는 JVM에 기계어가 아닌 바이트 코드를 전달 
>1. **일반 컴파일(자바 소스 코드 ➡ 일반 컴파일러)**
>	- `.java` 소스 코드를  Java 컴파일러(javac)에 의해 `.class`파일인 바이트 코드로 컴파일
>2. **바이트코드 로딩** 
>	- JVM의 '클래스 로더'가 1번에서 만든 바이트 코드를 JVM의 메모리 영역으로 로딩
>3. **JVM의 실행 엔진에 의해 실행됨 (바이트코드를)**
>	- 실행 엔진은 '인터프리터'와 JIT로 이루어진다.

---
### 2. 인터프리터 
---
#### 정의 
- 소스 코드를 한 줄씩 or 명령어 블록 단위로 **읽어서 즉시 실행**하는 프로그램 
- **별도의 실행 파일을 생성하지 않는다.**

>[!tip] 예시 언어 : Python, JS, PHP 등 
- 자바의 JVM 실행엔진도 인터프리터가 있긴함 (살짝 자바는 혼합)
---
#### 작동 방식 
1. **소스 코드를 읽는다**
2. **즉시 번역 및 실행**
	- 각 소스 코드의 라인/블록을 읽고 ➡ 기계어로 번역 ➡ CPU에 전달 ➡ 바로 실행
	- 즉, 전체를 읽고 기계어로 번역하는게 아니라 단위별 한줄별로 작동하는 것 

---
#### 특징 
#독립적  #느림 #실시간 
- **실시간 번역** : 실행하면서 기계어로 번역된다.
- **실행 속도가 느리다** : 컴파일된 파일이 없기에 
- **플랫폼에 독립적이다** : 인터프리터만 설치되어 있다면 어떤 플랫폼이든 동일한 소스 코드 실행 

---
### 정리 - 비교 
| 구분      | 컴파일러 언어      | 인터프리터 언어    |
| ------- | ------------ | ----------- |
| 번역 방식   | **전체 번역**    | 한 줄씩 번역     |
| 실행 속도   | **빠름**       | 느림          |
| 메모리 사용량 | **적음**       | 많음          |
| 오류 처리   | **전체 컴파일**   | 한 줄씩 처리     |
| 특징      | **실행 파일 생성** | 소스 코드 직접 실행 |
