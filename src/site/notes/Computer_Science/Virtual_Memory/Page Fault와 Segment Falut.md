---
{"dg-publish":true,"permalink":"/Computer_Science/Virtual_Memory/Page Fault와 Segment Falut/","noteIcon":"","created":"2025-12-12T16:15:10.228+09:00","updated":"2025-12-12T17:18:32.482+09:00"}
---



## 1.  Page Fault

### 1.1.  개념 
> 프로세스가 접근하려는 VM 페이지가 현재 RAM에 로드되어 있지 않을 때 발생하는 예외

- VM시스템에서 흔히 발생하는 정상적인 이벤트
- 페이지가 RAM에 없기 때문에 디스크에서 해당 페이지를 가져와야 한다.

### 1.2.  *주요 원인*
1. *Demand Paging* 
	- 프로그램 실행 초기에 모든 페이지를 메모리에 올리지 않고, 실제로 필요할 때(접근 시) 페이지를 Load하는 VM기법 때문에 발생
2. *메모리 스와핑*
	- 물리적 메모리가 부족할 때, 사용 빈도가 낮은 페이지를 디스크로 보냈다가(Swap-Out) 다시 필요해져서 Swap-in으로 로드해야할 때 발생 

### 1.3.  *처리 과정* (H/W + OS)
1. *CPU가 PF 예외 발생*
	- MMU 페이지 테이블을 조회했지만 present bit = 0일 경우
2. *OS의 PF Handler가 실행*
3. OS가 해당 가상 페이지가 합법적인 주소인지 검증
4. 합법적이라면 아래의 과정 실행 (불법이라면 Segfault)
5. OS는 디스크에서 **해당 페이지를 찾아 물리적 메모리의 빈 공간인 "Frame"에 Load**한다 (필요 시 기존 페이지를 Disk에 내보내기도 함)
6. **페이지 테이블을 업데이트**하여 **새로운 매핑 정보를 반영**
	- present bit = 1 
	- 가상  페이지 - 물리 페이지 매핑 
		  
7. 중단되었던 원래의 명령을 다시 실행 

### 1.4.  특징 
- 디스크 I/O가 필요하므로 시스템 성능 저하의 주 원인일 수 있다.
- But VM을 가능하게 해주는 핵심 매커니즘이라 포기 못 함 
- P.F는 오류가 아니라 메모리 관리 이벤트 

## 2.  Segment Fault

> 프로그램이 접근할 수 없는 메모리 영역에 접근 시도하거나 허용되지 않은 방식으로 메모리에 접근할 때 발생하는 오류 


커널이 최종적으로 이 접근은 프로세스 잘못이라고 판단해 시그널로 죽인 결과 

### 2.1.  주요 원인 

1. *잘못된 포인터 사용* : Null 포인터 역참조, 해제된 메모리 접근 
	```c
	int *p = NULL;
	*p = 3   // write to 0x0 ❌
	```

2. *메모리 범위 초과* : 버퍼 오버플로우, 스택 오버플로우
	```c
	int a[3];
	a[1000] = 1;  // 다른 영역 침범
	```

3. *권한 위반* : 읽기 전용 영역에 쓰기 시도, 커널 영역 접근 시도 
4. *시스템 보호 매커니즘*
	
	

## 3.  P.F와 Segfault의 관계 

> **동일** : 둘 다 "**프로세스의 메모리 접근 과정에서 발생하는 예외 상황**"이라는 점<br>
> **차이** : 무엇을 기준으로 보느냐의 차이 
> 	- Page Fault : **메모리 상태** 관점의 사건
> 	- Segment Fault : **접근의 정당성** 관점에서 내려진 OS의 판단 결과 


즉, Page Fault는 "메모리 상태에 대한 H/W이벤트"이고 Segment Fault는 "그 이벤트를 처리한 뒤 내려진 OS의 판단 결과"이다.


즉, PF는 "원인/중간 사건"이고 Segfault는 결과(시그널)이다.

| **구분**     | **세그먼트 폴트 (Segmentation Fault)**             | **페이지 폴트 (Page Fault)**                    |
| ---------- | -------------------------------------------- | ------------------------------------------ |
| **발생 원인**  | **불법적인** 메모리 접근 시도 (접근 권한 위반)                | **필요한 페이지가 물리 메모리에 없음** (비어있음)             |
| **정상/비정상** | **비정상(오류)** 상황                               | 대부분 **정상적인** 가상 메모리 관리 과정                  |
| **처리 결과**  | **프로그램 강제 종료** (SIGSEGV)                     | OS가 **페이지를 메모리에 로드**하고 프로그램 실행 재개          |
| **목적**     | **메모리 보호** (Memory Protection)               | **가상 메모리 구현** 및 메모리 효율성 증대 (Demand Paging) |
| **발생 계층**  | 주로 **운영체제 커널/하드웨어 (MMU)**가 불법 접근 감지 후 OS가 조치 | **운영체제 커널/하드웨어 (MMU)**가 페이지 부재 감지 후 OS가 처리 |
