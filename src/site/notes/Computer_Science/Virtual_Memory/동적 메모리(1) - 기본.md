---
{"dg-publish":true,"permalink":"/Computer_Science/Virtual_Memory/동적 메모리(1) - 기본/","noteIcon":"","created":"2025-08-22T10:07:44.984+09:00","updated":"2025-09-05T02:36:59.370+09:00"}
---

---
### 정적 메모리 vs 동적 메모리 

>[!tip] 정적 메모리 vs 동적 메모리
>- 정적 메모리 : 컴파일 시간에 할당되는 메모리
>- 동적 메모리 : 런타임에 필요한만큼 메모리를 할당받는 방식 

---
#### 1. 정적 메모리 
> **컴파일 시간에 할당**되는 메모리 

할당되는 메모리는 **고정** : 런타임에 줄이거나 늘리기 불가 (유연성 부족)

> [!WARNING] 정적 메모리 단점 
> 1. *메모리 낭비*
> 	- 지정된 크기보다 적은 요소 사용 시 메모리 낭비 가능 
> 2. *충돌 오작동 가능성*
> 	- 런타임에 지정된 메모리 크기보다 더 많은 요소 입력시 프로그램 충돌 or 오작동

> 이러한 단점들을 해결해주는 것이 "동적 메모리"


---
#### 2. 동적 메모리 
> 런타임 시 할당되는 메모리 

- *Heap 영역에 할당*된다 by 동적 메모리 할당기<br>![Pasted image 20250822103616.png](/img/user/supporter/image/Pasted%20image%2020250822103616.png)
	- 힙 메모리 세그먼트는 **동적 메모리 할당이 일어나는 세그먼트**이다.
	- Heap 영역은 ***순서 없이* 무작위로 메모리가 할당/해제**된다.
	  
- 동적 메모리 관련 C내장 함수들
	- `malloc()`
	- `calloc()`
	- `realloc()`
	- `free()`

>[!EXAMPLE] 동적 메모리와 **포인터!!**
>- 포인터는 동적 메모리 할당에 매우 중요한 역할
>- **할당된 메모리는 오직 포인터를 통해서만 접근이 가능** 
>- 즉, 동적으로 할당된 Heap 메모리에 접근할 수 있는 유일한 방법은 포인터이다.

>[!QUESTION] 왜 동적 메모리 할당을 사용 
>1. *유연한 메모리 관리*
>	- 실행 중 필요한 만큼만 가능 
>	- 실행 전에는 자료 크기를 알 수 없는 경우가 있음. 이 때 사용 
>	  
>2. *적절한 수명 관리 시 최적화 가능* 
>	- 원하는 시점까지 메모리를 유지시키고 소멸시키는 것이 가능하다.
>	- 이로 인해, 시스템 메모리 효율성 증가 가능 

---
### 동적 메모리 할당기 

---
#### 개념 
> **프로세스의 Heap 영역을 관리**하는 시스템 
- **런타임 중** 원하는 만큼 **메모리를 동적으로 할당하고 해제**한다.
	- 프로그램 실행 전 메모리 크기를 알 수 없다.
	- 가변적인 메모리 필요시 유용

Heap관리 시 다양한 크기의 블록들의 집합으로 관리
- 각 블록은 할당 or 가용한(free) 가상 메모리의 연속적인 묶음이다.
- 가용한 블록은 할당을 위해 사용될 수 있다.
- 할당된 블록은 묵시적 or 명시적 반환전까지 할당된 채로 남아있다.

> 할당/해제를 잘만 한다면 **한정된 자원을 효율적으로 관리 가능**  

---
#### 할당기가 필요한 이유 ⭐
>[!tip] 할당기가 없으면 메모리 낭비(내부 단편화) 심함 
>- OS는 페이지 단위(보통 4KB)로만 메모리를 다룬다.
>- 💢하지만, 실제 프로그램은 **4KB보다 훨씬 작은 데이터를 자주 사용**한다
>	- 모든 메모리 요청마다 4KB 페이지 전체를 할당하면 내부단편화로 엄청난 메모리 발생 🥊

 
**✅할당기의 역할**
> 동적 메모리 할당기는 OS로부터 **페이지를 몇 개 가진 상태**에서 그 **페이지를 잘게 쪼개어** 작은 블록들을 관리

 ![Pasted image 20250822133643.png](/img/user/supporter/image/Pasted%20image%2020250822133643.png)
- 확보한 페이지(들)를 **작은 블록**으로 잘라 **유저 요청에 바로 제공**
- 이는 매번 `System Call`을 하지 않아도 됨 ➡ **성능 향상**
- 작은 단위의 요청도 유연하게 처리 가능 

---
#### 할당기의 2가지 유형 (간단히)
1. *명시적인 할당기*
	- 할당된 블록을 **명시적으로** 반환해줄 것을 요구 ➡ 즉, **프로그래머가 직접** 할당/해제를 관리해야 함 
	- ex. `malloc()`, `free()`
	- **✅장점** : 세밀하게 제어 시 **메모리 오버헤드 최소화** 가능 
	- **💢단점** : 메모리 누수 발생 가능 + 이중 해제 오류 가능(잘못된 해제)
	  
2. *묵시적인 할당기* 
	- **메모리 회수 타이밍**은 런타임 시스템이 **자동 결정** 
		- 할당된 블록이 프로그램에서 사용되지 않으면 할당기가 블록을 반환해줌
	- ex. Garbage Collector
	- ✅**장점** : 생산성 증대
	- 💢**단점** : GC로 인한 오버헤드, 예측 불가능한 지연 발생 가능 


---
## 명시적 할당기 
#명시적할당

---
### 명시적 할당기 요구사항 
> 명시적 할당기는 **엄격한 제한 속 동작해야** 한다.

1. *임의의 요청 순서 처리하기*
2. *요청에 즉시 응답하기* 
	- 속도는 생명 
	  
3. *힙만 사용하기*
	- 할당기가 **사용하는 자료 구조들은 힙자체에 저장되어야** 한다.
	  
4. *메모리 블록 정렬하기* ⭐⭐
	- **주소가 정렬되지 않으면** CPU는 특정 크기 데이터 접근 시 **여러 번 메모리 접근이 필요할 수** 있다. 💢
	- 따라서 
	  
5. *할당된 블록을 수정하지 않기*
	- 사용자에게 이미 반환한 할당 블록의 내용은 변경하면 안된다.
	- 할당기는 오직 할당 블록의 메타데이터만 관리하고 수정 가능 

---
### 메모리 활용도 극대화하기
>[!tip] 흔한 오해 : 가상 메모리는 무한이니까 메모리 무한 사용?
>**No, 가상 메모리 공간도 제한적**이다. 따라서, 한정된 자원을 효율적으로 사용하는 것이 중요 

*할당기가 Heap을 얼마나 효율적으로 사용하는지 측정*하는 방법은 여러개이다. 그 중 가장 유용한 지표 = *"최대 활용도(Peak Utilization)"*

#### 사전 개념 : 메모리 블록 
> **힙 메모리를 얼마나 잘 썼는지를 측정**하는 것이므로 힙 메모리의 블록 구성을 이해하는 것이 먼저 

>[!tip] 힙 블록 포맷 
![Pasted image 20250822115807.png](/img/user/supporter/image/Pasted%20image%2020250822115807.png)
>- 힙 블록의 **전체적인 구성은 Header(size + a) + Payload + padding**으로 이루어진다.
>	1. *size* 
>		- 할당기가 OS로부터 확보한 **전체 힙 메모리 크기** (보통 주소의 기본 단위인 word 사용).
>		- 메타 데이터 포함
>		  
>	2. *a* : 할당 여부 비트 (1이면 사용 중, 0이면 free)
>		- 8바이트 정렬 기준 모든 블록 주소의 header 하위 3비트는 항상 000이다.
>		- 따라서 **안 쓰는** header **비트를 재활용해서 할당 여부를 저장** ❗
>		- `header = [블록 크기 | 할당여부(하위1비트)]`
>	3. *Payload* : 프로그램이 **실제로 쓰고 싶은 데이터 크기**. 실제 사용자 데이터가 저장되는 영역 
>	4. *padding* : 메모리 정렬 규칙을 맞추기 위해 추가되는(채워 넣는 느낌) 영역 
>		- 예를 들어, 13byte 메모리 요청 시 (`malloc(13)`)
>			- payload(13B) 
>			- padding(3B)
>			- Header(24B)
>			- 최종 블록 크기 = 총 32B로 16의 배수(64bit 시스템 기준)
>- 즉, Block을 할당 받으면 위의 데이터 영역인 Payload뿐만 아니라 **다른 부분도 포함하여 할당 받은 것** 


>[!EXAMPLE] 개념 : 바이트 정렬 
>- 정렬 : 어떤 데이터 타입은 "**N바이트 배수 주소에서 시작해야**"한다는 규칙
>- 정렬 규칙 이유
>	- CPU는 한 번에 읽는 양이 Word(주소 기본 단위)크기와 관련되어 잘못 정렬되면 느리거나 오류 발생 가능 
>- 가장 **엄격한 기준으로 정렬 보장**해야 함 
>	- 어떤 타입의 객체도 안전하게 저장될 수 있어야 하므로 
>	- 64bit 시스템에서 malloc()은 **대부분 16바이트 정렬 보장** 



---
#### 메모리 효율성 측정 - Peak Utilization
$효율 = 실제사용한부분/{OS에서 확보한 전체 HeapSize}$
$U_k = \frac{\max_{i \leq k} P_i}{H_k}$
- **할당기가 확보한 자원($H_k$)대비**, **프로그램이 실제로 필요로 했던 최대치** (max $P_i$)를 얼마나 잘 수 용했는가를 나타냄 
- *max로 잡는 이유 = 시간에 따라 Payload가 변함 *
	- 프로그램 실행하면서 살아있는 메모리 총합은 변경된다.
	- 할당기가 **자원을 진짜 많이 필요할 떄 얼마나 잘 대처했는지 보는 것** 


- 너무 낮으면 ➡ 메모리 낭비, 
- 너무 높으면 ➡ 성능 문제 

---
#### 처리량 vs 메모리 효율성 (나중에)
> 이 둘은 **상충 관계가 존재**한다 ➡ 이 두가지의 적절한 균형이 중요 

---
#### 단편화 - 나쁜 활용도의 원인💢
> 힙 활용도를 낮추는 주요 원인 중 하나가 "**단편화**"이다.
> - 내부 단편화
> - 외부 단편화 

단편화가 뭔지는 아니까 동적 메모리에서의 특징들 위주로 

1. *내부 단편화*
	- **할당된 블록이 데이터 자체보다 더 클 때** 나타남 
	  
2. *외부 단편화*
	- 여유공간의 총합은 할당 요청을 만족시킬 수 있지만, 가용블록은 없는 상태 
	- 내부 단편화보다 예측이 어렵다
		- 이유 : 미래 요청 패턴도 중요하기 때문 


Next : [[Computer_Science/Virtual_Memory/동적 메모리(2) - malloc\|동적 메모리(2) - malloc]]