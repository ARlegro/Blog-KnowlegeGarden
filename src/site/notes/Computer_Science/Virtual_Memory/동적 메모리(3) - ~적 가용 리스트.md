---
{"dg-publish":true,"permalink":"/Computer_Science/Virtual_Memory/동적 메모리(3) - ~적 가용 리스트/","noteIcon":"","created":"2025-08-22T17:00:37.293+09:00","updated":"2025-09-05T02:38:25.178+09:00"}
---


*묵시적 가용 리스트(Implicit Free List)*

[[Computer_Science/Malloc/효율적인 할당기 구현 시 고려사항\|효율적인 할당기 구현 시 고려사항]]

>[!tip] 묵시적 가용 리스트 vs 명시적 가용 리스트 
>가용 Block을 어떻게 관리하느냐에 따라 **묵시적/명시적 가용 리스트로** 갈린다.
>가장 큰 차이는
>- *묵시적 구현* : free block을 따로 모아두지 않는다
>- *명시적 구현* : free block끼리만 연결리스트로 묶어둠 


---
## 1. 묵시적 가용 리스트 

#단순 

---
### 개념 
> 메모리 힙의 모든 블록을 연속적으로 연결하여 관리하는 방식 

- 가용(free) 블록을 따로 모아두지 않는다.
- 전체 힙을 선형으로 탐색하여 필요한 블록을 찾음 ➡ 느림 ($O(전체블록수)$) 💢


---
### 기본(Regular) 블록 구조 
![Pasted image 20250823215657.png](/img/user/supporter/image/Pasted%20image%2020250823215657.png)
![Pasted image 20250823112649.png](/img/user/supporter/image/Pasted%20image%2020250823112649.png)

모든 Block은 `[Header | Payload | Footer]` 구조이다
- *Header* : 블록의 크기와 할당 여부 정보를 담고 잇음 
- *Payload* : 사용자가 실제로 데이터를 저장하는 곳 
- *Footer* : 헤더와 동일한 정보 가짐. **병합 시 이전 블록의 정보를 빠르게 찾기 위해** 사용 

---
### 특별한 블록 

> - **경계 조건을 처리하기 위해 특별히** 만들어진 블록이 있다. 
> 	1. 프롤로그 블록
> 	2. 에필로그 블록 
> - 이 블록들은 **힙의 시작과 끝에 위치**
> - 엣지 케이스를 제거할 수 있어서 할당자의 **코드를 단순화**하는 역할 
> 	- 다음/이전 블록의 상태를 확인할 경우가 많을텐데 항상 안전하게 확인 가능 

---
#### 힙영역 
```bash
✅| Padding (8B) |  
✅| Prologue Header (8B, size=16, alloc=1) |
✅| Prologue Footer (8B, size=16, alloc=1) |
| First Free Block (가변) |
... Regular Blacks 
| Last Free/Allocated Block |
✅| Epilogue Header (8B, size=0, alloc=1) |
```
- Padding : 정렬 맞추기용
- Prologue : 힙 앞 보호 장치
- Regular Blocks: malloc/free 되는 실제 공간
- Epilogue : 힙 끝 보호 장치

Regular Block 외 특별한 블록들이 있는데 그것을 알아볼 것 
- Padding
- Prologue block
- Epilogue block

---
#### 0. 패딩 블록 
```c
PUT(heap_listp, 0);
```
- *정렬용 패딩* : 아무 의미 없는 0 대입 (숫자는 크게 상관없음)
- 블록의 **bp를 더블워드 사이즈 단위로 맞추기 위해** 만드는 더미 블록 

![Pasted image 20250823204155.png](/img/user/supporter/image/Pasted%20image%2020250823204155.png)
>[!tip] 힙 블록의 더블워드(8B) 정렬 규칙
> - 모든 payload는 8의 배수 주소에서 시작해야 
> - Cuz CPU의 읽기/쓰기 시 성능과 안전성 때문 

---
#### 1. 프롤로그(Prologue) 블록
```bash
[ Header (8B, size=16, alloc=1) | Footer (8B, size=16, alloc=1) ]
```
- Payload가 없이 header와 footer로만 이루어진 블록 
- *크기* 
	- 보통 **최소 블록 크기**로 하는 것이 흔함(16byte)
	  
- *역할* 
	- **힙의 첫 번째 블록이 이전 블록과 병합하려는 시도를 막아**준다
	- 덕분에, 유효하지 않은 메모리 주소 접근하는 오류를 방지 가능 
	  
- **힙의 맨 처음**에 위치 
- `alloc=1` : 항상 할당된 상태 

---
#### 2. 에필로그(Epilogue) 블록 

```bash
[ Header (8B, size=0, alloc=1) ]
```

> [!WARNING] 에필로그는 실제 블록이 아니다.

- 크기 : 0 byte
- *단순 경계용* 
	- 힙 끝을 알려주는 sentinel 
	- 힙의 마지막 블록이 다음 블록과 병합하려는 시도를 막아줌 
	  
- 힙의 맨 끝에 위치 
- `alloc=1` : 항상 할당된 상태 

---
## 2. 명시적 가용 리스트 

> [!WARNING] 묵시적 가용 리스트의 한계 
> - 블록 할당/해제 시간이 전체 힙 블록수에 비례 

> 가용 블록들을 연결 리스트 형태로 관리하는 방법
> - *핵심* : 가용 블록들만 관리 ❗
> - 각 가용 블록들은 **다음 가용 블록의 주소를 가리키는 포인터가 들어** 있다.


가용 리스트 
- 가용 블록만 연결한 별도의 연결 리스트 
- 각 가용 block의 Payload => 전임/후임 포인터를 저장 

---
### 할당 시 
![Pasted image 20250825160004.png](/img/user/supporter/image/Pasted%20image%2020250825160004.png)
- White Block = 가용 리스트 block
- 할당되고 분할된 가용 블록을 다시 리스트로 

앞 뒤 바꾸면 되는거라 간단

---
### Free 시 
살짝 더 복잡하다 Cuz 삽입 정책 
삽입 정책 = 새로 해제된 블록을 가용 리스트의 어디에 놓을지

삽입 정책 2가지 종류
1. *LIFO (후입 선출)* 
	- 사용 가능 Block이 생기면 리스트의 가장 앞 부분에 삽입 
	- 리스트 **시작 부분에 포인터가 항상** 있기 때문에 상당히 **간단**하고 상수 시간
	- 연구 결과 이게 더 낫다능
	  
2. *주소 순서*
	- 주소 순으로 리스트 정렬되어 잇음 
	- 장점 : 1번 보다 단편화가 적다. 
	- 단점 : free 시 선형 검색 시간 必

---
#### LIFO - Case 1 : 인접 가용 블록 X
> 인접 가용 블록이 없는 경우

![Pasted image 20250825173106.png](/img/user/supporter/image/Pasted%20image%2020250825173106.png)
- 그냥 list의 root에 가용된 block을 넣으면 됨 (병합 필요❌)
	- root = 가용 리스트의 head를 가리키는 포인터 
![Pasted image 20250825164909.png](/img/user/supporter/image/Pasted%20image%2020250825164909.png)

---
#### LIFO - Case 2 : 이전 블록이 가용
> 이전 물리 블록이 가용 상태인 경우 

![Pasted image 20250825173241.png](/img/user/supporter/image/Pasted%20image%2020250825173241.png)

이전 블록이 가용이므로 현재 free()하려는 블록과 병합해서 더 큰 가용 블록을 만든다.
1. 이전 가용 블록과 병합
2. 결과 블록을 리스트에 넣기 
3. root가 이 블록을 가리키도록 

---
#### LIFO - Case 3 : 다음 블록이 가용
> 다음 물리 블록이 가용 상태인 경우 

![Pasted image 20250825173417.png](/img/user/supporter/image/Pasted%20image%2020250825173417.png)

Case 2와 비슷하게 하면 됨 

---
#### LIFO - Case 4 : 이전,다음 블록이 가용 

3개 전부 병합하면 됨 

---
### 구현 시 조심                                                                                                                
1. *최소 가용 블록을 재정의 해야 함 *
	- 이전/다음 블록의 정보를 담을 블록이 필요하므로 최소 크기를 기존보다 늘려야 한다.
	- 이로 인해, split 조건도 바꿔야 함 
	- Note : **포인터는 8B가 필요** (64bit 기준) Cuz 가상 주소 폭이 64bit여서 포인터도 그거 맞춰야 
	  
2. 이중 포인터 사용 

---
## 분리 가용 리스트 

---
### 핵심 아이디어 
1. *여러 개의 가용 리스트* 
	- **크기 범위별로** 여러 개의 **가용 리스트**를 둔다 
		```c
		// Segregated Free List: 크기별로 분리된 가용 리스트 배열
		static void *free_lists[NUM_LISTS];
		/**
		 * 주어진 크기에 해당하는 리스트의 인덱스를 반환
		 */
		static int get_list_index(size_t size) {
		    // 2의 거듭제곱을 기준으로 크기 클래스를 나눕니다.
		    // 예: list[0] -> (0, 32], list[1] -> (32, 64], list[2] -> (64, 128] ...
		    if (size <= 32) return 0;
		    if (size <= 64) return 1;
		    if (size <= 128) return 2;
		    if (size <= 256) return 3;
		    if (size <= 512) return 4;
		    if (size <= 1024) return 5;
		    if (size <= 2048) return 6;
		    if (size <= 4096) return 7;
		    if (size <= 8192) return 8;
		    if (size <= 16384) return 9;
		    // ... 필요에 따라 더 많은 클래스를 추가할 수 있습니다.
		    return 10; // 가장 큰 클래스
		}
		```
	  
2. *빠른 검색*
	- `malloc`요청 시 **필요한 크기에 속하는 리스트만** 검색 
	  
---
### init 
- 가용 블록의 클래스 
  
```c
#define NUM_LISTS 20 // 사용할 가용 리스트의 개수
// Segregated Free List: 크기별로 분리된 가용 리스트 배열
static void *free_lists[NUM_LISTS];
int mm_init(void)
		
		// 분리 가용 리스트 배열 원소들 null로 전부 초기화 
    for (int i = 0; i < NUM_LISTS; i++) {
        free_lists[i] = NULL;
    }

    heap_listp = mem_sbrk(4 * WSIZE);
{
```
`free_lists[]`
- 크기별로 분리된 가용 리스트 배열
- *전역 정적 변수*
	- ❌힙 영역에 있는 것이 아니다 ➡ 별도로 힙에 배치할 필요가 없음 
	- 프로그램의 `.bss/.data 영역`에 놓임 

---
### Insert 시 

```c
// LIFO로 가용 리스트의 맨 앞에 블록을 삽입
static void insert_free(char *bp) {
    size_t size = GET_SIZE(HDRP(bp));
    int index = get_list_index(size);
    void *list_head = free_lists[index];

    // 삽입하려는 가용 블록과 이전 대장이였던 블록 link
    PUT_SUCC_PTR(bp, list_head);
    if (list_head != NULL) {
        PUT_PRED_PTR(list_head, bp);
    }

    PUT_PRED_PTR(bp, NULL);
    free_lists[index] = bp;
}
```

---
### remove_free

```c
void remove_free(char *bp){
    size_t size = GET_SIZE(HDRP(bp));
    int index = get_list_index(size);
    void *pred = GET_PRED_PTR(bp);
    void *succ = GET_SUCC_PTR(bp);

    if (pred) {
        PUT_SUCC_PTR(pred, succ);
    } else {
	    // bp의 pred = null  ==> bp가 head라는 것
        free_lists[index] = succ;  // bp가 첫 번째 노드
    }

    if (succ) {
        PUT_PRED_PTR(succ, pred);
    }
}
```

