---
{"dg-publish":true,"permalink":"/Computer_Science/Virtual_Memory/메모리 매핑/","noteIcon":"","created":"2025-08-21T17:47:38.274+09:00","updated":"2025-12-12T17:36:50.393+09:00"}
---


사전 필수 학습 내용 : [[Computer_Science/Virtual_Memory/Virtual Memory\|Virtual Memory]]

---
## 1.  시작

---
### 1.1.  개념 
> 가상 메모리 주소를 물리 메모리 or 디스크상의 데이터와 연결하는 과정


- 프로그램은 가상 주소(VA)만 사용
	- 파일을 *메모리에 있는 것처럼* 접근하고 조작 가능
- 실제 데이터는 
	- RAM에 있을 수도
	- 디스크(파일, Swap)에 있을 수도 있다.
- 이 둘을 연결해주는 관계 설정 = "메모리 매핑"

>[!tip] 파일이 메모리처럼 보이도록 OS가 가상 주소 공간에 매핑 

### 1.2.  왜 필요한가?

메모리 매핑이 없으면  #보안_취약 
1. 모든 프로그램이 실제 물리 주소를 알아야 하고 
2. 서로 메모리를 침범할 수 있다.

<BR>
1. **보안** 
2. **불필요한 복사 제거 - System call 감소**
	- 단순 `read`
		- 디스크 ➡ 커널 ➡ 유저 
		- 💢접근할 때마다 system call 발생 
	- `mmap`
		- 디스크 ➡ 페이지 캐시 ➡ 유저 주소 공간에 바로 매핑 
		- 
	- 이러한 차이는 메모리 복사 비용을 감소시키고 성능 개선해줌

3. System call I/O 횟수 감소
	- ✅최초 1회 매핑만 System call, 이후 접근은 CPU 명령 <BR>![Pasted image 20250821223858.png](/img/user/supporter/image/Pasted%20image%2020250821223858.png)
		- File의 공간을 RAM(Memory)접근하듯이 할 수 있다. ⭐⭐
		- Page Fault만 나지 않으면 **System Call이 필요 없다.**
			- 원래, I/O작업은 커널 진입이 필수였어서 오버헤드 발생했음 ❗
		- **더 빨라짐** 

3. **대용량 파일 처리에 유리**
	- 파일 전체를 메모리에 올릴 필요 없기 때문
	  
4. **다른 프로세스와 통신 가능 - 자연스로운 메모리 공유**
	- 공유 주소를 통해 **통신이 가능** <BR>![Pasted image 20250821224021.png](/img/user/supporter/image/Pasted%20image%2020250821224021.png)
	- 원래 프로세스끼리는 다른 프로세스와 메모리를 공유할 수 없었다.
	- 하지만 메모리 매핑을 사용하면 **동일한 파일 메모리 주소를 공유할 수** 있다.(둘다 쓰기/읽기 가능)


### 1.3.  관리

> 메모리 매핑은 페이지 테이블에 의해 페이지 단위로 관리된다.

각 Page는 다음 중 하나와 매핑됨
- 물리 메모리의 Frame
- 디스크의 특정 위치(file or swap)
- 아무것도 없는 상태(anonymous)
---
## 2.  매핑 종류 `
---
### 2.1.  일반 파일 매핑 


---
### 2.2.  익명 메모리 매핑
참고 : [[Computer_Science/Virtual_Memory/동적 메모리(2) - malloc\|동적 메모리(2) - malloc]] -> malloc 파트 


> **어떤 파일과도 연결되어 있지 않은** 메모리 매핑 

**✔동작 과정**
1. *페이지 테이블을 설정*
	- 프로세스가 **가상 메모리 공간이 할당되면** 그 주소에 매핑하기 위해 **테이블을 생성**한다.
	  
2. *가상 주소 일부를 익명 페이지와 매핑*
	- 페이징 기법은 Lazy Loading을 사용하므로 모든 데이터를 RAM에 적재하지 않는다.
	- 따라서 일부는 가상 주소와 매핑 되지 않는데 `NULL`값 대신 **익명 페이지를 매핑**해준다.

>[!EXAMPLE] 익명 페이지란❓
>- 실행 파일이나 특정 디스크 파일에 매핑되지 않은 깨끗한 메모리 공간
>- *Zero 페이지 초기화된 파일이다* 
>	- 0으로 채워진 초기 상태로 제공된다.
>	- **메모리를 아끼고자** 모드 0으로 
>- *초기(쓰기 발생 전)*
>	- 여러 가상 주소에 **하나의 익명 페이지를 공유 매핑**한다.
>	- RB_Tree에서 nil노드 공유랑 비슷한 메커니즘 
>- *쓰기 발생 시(Copy-On-Write)* => 효율적 ⭐
>	1. 우선, **Page Fault를 일으킨다** Cuz 쓰기 요청을 한 가상 주소에 메핑되는 페이지가 익명 페이지이므로 
>	2. **새로운 물리 페이지를 할당**해준다
>		- 공유된 것이 아닌 **자신만의 익명 페이지를 갖게 되는 것** 
>		- 💢새로 할당된 페이지도 파일과 연결되어 있지 않으므로 **익명 페이지**다 
>		- Note : 기존 익명 페이지는 다른 주소끼리 공유 중
>- *처음엔 모두 0 보장(공용 제로 페이지) → 쓰면 내 물리 프레임 하나가 생김(익명 페이지)*

---
## 4.  mmap - 메모리 매핑을 위한 시스템 콜
mmap = memory mapping 

자세한 내용 = [[Computer_Science/Virtual_Memory/동적 메모리(2) - malloc\|동적 메모리(2) - malloc]]


---
## 5.  공유 객체(Shared Mapping) vs 사적 객체(Private Mapping)

하나의 파일 객체(목적파일)를 가상 메모리에 매핑할 때, 그 **매핑을 여러 프로세스가 공유하도록 할 수도 or 각자만 사적으로 보이게 할 수** 있다. 이에따라 2가지 종류로 나뉨 
1. 공유 객체 매핑 
2. 사적 객체 매핑


>[!QUESTION] 메모리에서 객체(Mapping)란?
>- 디스크의 파일을 가상 메모리에 **매핑하는 단위/특정구간**
>- 가령 어떤 파일을 `mmap()`을 통해 가상 메모리 주소 공간에 매핑했을 때 이 파일 구간을 "객체"라고 부름 

 ---
### 5.1.  공유 객체
> 여러 프로세스가 같은 **파일을 MAP_SHARED 모드로 매핑**하는 것 
- *결과*
	- 가상 메모리에서의 **변경이 파일에 반영** + 한 프로세스의 **반영 내용이** 다른 프로세스에서 **그대로 보임** 
- 즉, **물리 메모리 + 파일까지 공유**하는 구조

---
### 5.2.  사적 객체
> 파일을 **MAP_PRIVATE모드로 매핑**하는 것 
- *작동 방식*
	- 처음에 파일의 내용을 **읽기 전용으로 공유하다가** <br>![Pasted image 20250822010323.png](/img/user/supporter/image/Pasted%20image%2020250822010323.png)
	- 어떤 프로세스가 쓰기(Copy-On-Write)를 시도 시 그 프로세스만의 익명 페이지로 바뀐다.<br>![Pasted image 20250822010346.png](/img/user/supporter/image/Pasted%20image%2020250822010346.png)
	  - 물리 메모리(RAM)에 **새로운 익명 페이지 생성**
	  - 쓰기 작업을 한 Process의 **가상 주소와 새로운 익명 페이지 주소를 매핑**
	  - **기존 페이지는 읽기 전용으로 유효** ➡ 다른 프로세스는 아직 수정 전 페이지랑 매핑 중 
	    
- *결과*
	- ❌그 페이지는 **다른 페이지에서 볼 수 없다** 
	- ❌변경된 내용은 **디스크에도 반영되지 않는다.**





