---
{"dg-publish":true,"permalink":"/Computer_Science/Virtual_Memory/페이지 설정/","noteIcon":"","created":"2025-08-21T14:39:45.289+09:00","updated":"2025-09-05T02:39:31.972+09:00"}
---


### 심화 : 가상 주소(VA -> PA) 변환 흐름 
가상 주소에서 물리 주소로의 변환은 CPU와 OS 사이의 협력으로 이루어진다.
- CPU 내부의 MMU(메모리 관리 장치)의 도움으로 가상 주소들을 물리 주소로 변환한다. (MMU = 주소 변환 엔진)
- But OS도 여기서 역할이 있음 ➡ 페이지 테이블 항목을 설정 

---
#### 그림 
![Pasted image 20250821153355.png](/img/user/supporter/image/Pasted%20image%2020250821153355.png)
>[!EXAMPLE] 참고 : 가상 주소 형식 
>1. VPN(상위 비트들)
>2. Offset(하위 12bit - 4KB)

---
#### 절차 
1. *TLB 조회* 
	- CPU가 가진 VA로 TLB를 조회한다
	- hit 시 ➡ PA 즉시 획득
	- Miss 시 ➡ 2번 
	  
2. *페이지 워크 절차 실행* (TLB Miss 시)
	- 정의 : MMU가 페이지 테이블을(TLB 말고 **RAM에 있는) 탐색해서 물리주소 변환 결과를 찾아내는** 과정 
	- **PTBR을 읽어 루트 테이블의 물리 주소를 확보**한다.(만약 루트 테이블에도 없었으면 Page Fault 발생💢)

>[!EXAMPLE] 개념 1. PTBR (Page Table Base Register)
>- CPU 안 레지스터 중 하나 
>- 현재 실행 중인 프로세스의 **"페이지 테이블 물리 주소"를 보관** 중
>- 이것 덕분에 **RAM의 페이지 테이블 접근이 가능**한 것 
>- 갱신 : 프로세스별 Page Table이 다르므로 프로세스 전환 시마다 PTBR값 갱신됨 


>[!EXAMPLE] 개념 2. 루트 테이블 (Root)
>- **RAM에 존재**하는 **실제 Page Table**
>- **Multi-level Page Table**로 되어 있다.(아키텍쳐마다 조금 다름)


3. *PPN(Pysical Page Number) 추출*
	- 해당 가상 주소와 대응되는 물리 페이 지 내의 **Page Frame Number**
	- 이 번호는 데이터를 찾기 위한 정보일 뿐(페이지 프레임의 위치)
	- RAM에 PPN이 없다면 Page Fault 
	  
4. *PPN과 Offset을 통해 PA 계산*
	- PPN은 페이지 프레임의 시작 위치이므로 이 정보와 offset정보를 통해 RAM에서 실제 데이터가 어딨는지를 알 수 있다. ➡ 이 주소가 **PA** 
	  
> [!WARNING] 주의 - 실제 데이터 위치는?
> - 실제 데이터 위치 != PPN
> - 실제 데이터 위치 == PPN + Offset 을 통해 계산된 PA

5. *PA를 통해 실제 물리 주소로 접근* 

---
###  참고 : 페이지 테이블 항목의 메타데이터 

1. Present bit(현재 비트) : 유효 비트?
2. Write bit(쓰기 비트) : 이 페이지가 쓰기 가능한지 여부를 나타냄 
3. User bit(사용자 비트) : 사용자 모드에서 접근이 허용되는지 여부를 나타냄
4. Executable bit(실행 비트) : 이 페이지 내의 코드를 실행할 수 있는지 여부를 나타냄 
5. PPN-Physical Page Number : 실제 메모리의 위치 


---
## 멀티 레벨 페이지 테이블 


---
### 등장 배경 

프로세스에 부여된 가상 주소는 대부분 메모리에서 사용되지 않음
즉, 메모리 낭비가 심함 

그래서 나온 것이 MPT이고 이는 필요한 부분만 테이블을 만들어 쓰는 것이다 By 페이지 테이블 계층적 관리 

또한 페이지 테이블 Swapping이 불가능
- 페이지 테이블은 Disk로 Swapping이 불가 
- 페이지 테이블이 없으면 메모리 찾는 것이 불가능 

32bit 시스템 기준 한 프로세스 당 Page Table의 크기는 4MB
근데  그 프로세스가 10MB를 필요로 한다면❓12MB의 Page Table을 할당되게 되는데 이는 2MB(12-10)라는 비효율적인 공간이 생기게 함 


### 개념 

논리 주소(가상 주소) 공간을 여러 단계의 Page Table로 나눈다.
멀티 레벨 페이지 테이블은 가상 주소의 페이지 번호 비트를 여러 단계로 쪼개 트리 구조로 탐색해서, **실제로 쓰는 범위의 테이블만 동적으로 생성하는 방식**

대분(디렉터리) -> 중분류(테이블) -> 세부위치(offset)

*페이지 디렉터리 인덱스*
- 어느 페이지 테이블을 쓸지 고르는 번호
- 이 번호는 "어느 페이지 테이블이 있어야 하는지"를 가리키는 포인터 

*페이지 테이블 인덱스*
- 선택된 Page Table 안에서 다시 특정 엔트리를 고르는 데 사용됨
	- 각 엔트리는 가상 주소와 매핑된 실제 Frame번호를 담고 있음 
	- 테이블 안의 몇 번째 페이지 Frame을 쓸지 고르는 번호 

=> 이 2가 인덱스를 통해 최종 물리 Frame을 찾고 그 내부의 세부 위치는 offset을 활용 




페이지 디렉토리 인덱스로 10bit를 썼다는 것은 $2^{10}$ (1024)개의 페이지 테이블 번호를 갖고 있다는 것 

![Pasted image 20250821172411.png](/img/user/supporter/image/Pasted%20image%2020250821172411.png)
(참고 : https://www.youtube.com/watch?v=jHKjJ0IMUv8)

특정 페이지 테이블만 쓰다가 그 페이지 테이블의 모든 항목들에 할당이 이뤄지면  OS는 새로운 페이지 테이블을 만들고 그것을 페이지 디렉토리에 매핑 

