---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/DP, Greedy/개념/DP - 동적 프로그래밍/","noteIcon":"","created":"2025-07-18T19:54:56.466+09:00","updated":"2025-08-08T01:42:11.028+09:00"}
---




프로그래밍 대회에 많이 나오는 개념이라 대회 준비 시 필수 

### 개념 
> 하나의 문제는 단 한 번만 풀도록 하는 것 
- **DP = 동적 계획법** 
	- **동적 할당**이란❓ 프로그램이 **실행되는 도중에 실행에 필요한 메모리를 할당**하는 기법 
- **효과** : 반복적으로 데이터를 계산할 필요를 없애준다.
	- 여러 개의 **겹치는 부분**이 있을 때, 각 부분 문제의 해답을 한 번 계산 시 **임시 저장하여 재사용**함으로써 한 번만 계산하도록 함 ➡ 전체 문제의 효율성을 높임


### DP가 필요한 예시 
- 아래의 사진은 **분할정복을 이용한 피보나치 수열**의 계산 예시인데, 값을 반복적으로 계산하는 부분이 많다.💢![Pasted image 20250718200027.png](/img/user/supporter/image/Pasted%20image%2020250718200027.png)
	- 빨간 12가 3번이나 계싼되었다 ➡ **비효율적**


### 언제 DP 사용하는 것이 좋은 조건 ❓
#사용조건가정

1. **최적 부분 구조** 
	- **큰 문제를 작은 문제로 나눌 수 있다.**
	 - 큰 문제의 최적 해가 작은 부분의 최적 해들로부터 구성될 수 있는 조건일 경우 
	 - **복잡한 문제가 동일한 형태의 더 작은 문제들로 분해될 수** 있어야 한다.
	   
 2. **중복되는 부분 문제** 
	 - **겹치는 부분** ➡ 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다
	 - 부분 문제의 최적 해답이 전체 문제의 최적 해답을 구성하는데 기여해야 한다.

> 즉, **동일한 작은 문제**를 **반복적**으로 해결하는 조건일 때 좋다 


### 사용법 

#### 1. 메모이제이션 활용 - Top-Down 방식 
#재귀 #캐싱 

- **개념** 
	- **이미 계산했던** 부분 문제의 **결과는 배열에 저장**해두고, 동일한 부분 문제가 다시 필요할 때는 재계산 없이 저장된 값을 바로 반환 

- **효과**
	- 불필요한 중복 계산을 방지하여 실행 시간 단축 
	- 겹치는 부분 문제가 많을수록 효율적 
- **사용법**
	1. 결과를 담을 수 있는 배열 생성 
	2. 중간 로직에 이미 구한 값 반환 로직 추가 
```python
memo = [-1] * 100 
# 결과를 담을 배열. -1은 아직 계산되지 않았음을 의미 (N이 100까지라고 가정)

def fib_memo(n):
    if n <= 1:
        return n 

    # 1. 이미 계산된 값이 있는지 확인
    if memo[n] != -1: 
        return memo[n]

    # 2. 계산되지 않았다면, 계산 수행 (재귀 호출)
    memo[n] = fib_memo(n-1) + fib_memo(n-2)

    # 3. 결과 저장 후 반환
    return memo[n]
```
- fib_memo(n - m)이 여러 번 호출되더라도 더 깊이 내려가지 않고 **메모이제이션에 저장된 값을 바로 반환 ➡ 중복 계산이 사라짐** 

#### 2. 타뷸레이션 - Bottom-Up 방식 
#반복문 #테이블채우기 #상향식 

- **개념**
	- 가장 작은 부분 문제부터 시작하여 점진적으로 큰 문제의 해답을 반복적으로 계산해 나가는 방식 

- **장점**
	- **재귀 호출 오버헤드가 없다**
	- 메모이제이션보다 **더 빠르고 StackOverFlow 위험이 없다**
	  
- **사용법**
	1. 결과를 담을 배열 생성
	2. 반복문을 통해 테이블 채우기 

```python
dp = [-1] * 100 # 결과를 담을 배열 
dp[0] = 0
dp[1] = 1 # 가장 작은 부분 문제의 기본값 설정

def fib_tab(n):
    if n <= 1:
        return n

    # 반복문을 통해 dp 테이블 채우기
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

# 예시: F(10) 계산
# print(fib_tab(10)) # 결과: 55
```

