---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/DP, Greedy/문제풀이/백준 1904 - 01타일/","noteIcon":"","created":"2025-12-03T14:52:51.871+09:00","updated":"2025-12-13T18:25:27.264+09:00"}
---



### 후기 
- 아직 DP개념을 훝기만 한 상태이다. 이론 공부보다는 실전에서 문제를 만났을 때 실력이 더 빨리 는다고 생각해서. 문제를 먼저 풀어보았다.
- 근데 감이 안잡혀서 30분 고민하다가 답을 봤다. 
- 답을 보고 "아하~ DP가 이런거구나"라는 정도의 감을 잡았고 코드 리뷰를 하면서 개념들을 정리해보려 한다.


## 문제 링크 

[BOJ 1904 - 01타일](https://www.acmicpc.net/problem/1904)



## 정답 

### 아이디어 

#### 길이 N 타일링 케이스 분리 
> 2가지 케이스로 분리하면 쉽게 점화식이 도출된다

1. **마지막에 "1" 타일을 쓴 경우**
	- "1"은 길이가 1로 취급된다. 
	- 따라서, 그 앞에 N-1칸은 유효한 타일 배열이라면 들어와도 된다.
	- 즉, (N-1)개의 타일 배열 개수 = N개의 타일에서 마지막에 1을 쓴 경우의 타일 배열 개수
	  
2. **마지막에 "00" 타일을 쓴 경우**
	- "00"은 길이가 2로 취급된다.
	- 따라서, 그 앞에 N-2칸은 유효한 타일 배열이라면 들어와도 된다.
	- 즉, (N-2)개의 타일 배열 개수 = N개의 타일에서 마지막에 "00"을 쓴 경우의 타일 배열 개수

>[!tip] 생성된 점화식 
>$f(N) = f(N-1) + f(N-2)$


#### 모듈러의 법칙 활용 
#모듈러의_법칙

> 문제를 보면, 특정 숫자를 나눈 나머지 값을 출력하라고 되어 있다. 이는 너무 큰 숫자일 경우를 대비한 것. 
> 하지만 특정 크기만큼 커진 다음에 나누는 방법은 커졌을 때 오버플로우 위험이 있기 때문에 조기에 잡야아하는데 이 때 사용하는 원리가 **모듈러의 분배 원칙**이다

>[!tip]  모듈러의 분배 원칙
>- (a+b) mod M = ( (a mod M) + (b mod M) ) mod M
>- 이로 인해, 각 값을 먼저 특정 숫자(M)로 나눠놓고 그 값들을 더한 뒤 나중에 또 나누면 됨


### 코드 

#### 배열 사용 케이스
가장 일반적인 DP 사용법이다. 
```PYTHON
import sys
input = sys.stdin.readline

def solution(N, mod):
  dp = [0]*(N+1)
  dp[0] = 0
  dp[1] = 1
  dp[2] = 2
  for i in range(3, N+1):
    dp[i] = (dp[i-1] % mod) + (dp[i-2] % mod)
    
  print(dp[N])

if __name__ == "__main__":
  N = int(input())
  mod = 15746
  solution(N, mod)
```


#### 메모리 최적화
> 더 최적화하고 싶다면??
- 두 변수만으로도 DP를 만들 수 있다.
- 이렇게 되면 공간 복잡도가 O(N)에서 O(1)로 최적화가 된다.

```PYTHON
import sys
input = sys.stdin.readline
  
def solution(N, mod):
  if N == 1:
    print(1)
    return

  a, b= 1, 2
  for _ in range(3, N+1):
    a, b = b, (a+b) % mod
    
  print(b)

if __name__ == "__main__":
  N = int(input())
  mod = 15746
  solution(N, mod)
```
















**N=1 : 1개** 
- 1

**N=2 : 2개**
- **11**
- 00 

**N=3 : 3개** 
- **001**
- **111**
- 100

➡ 0이 1개일 때 : $2C1$ 
➡ 0이 0개일 때 : 1개 

**N=4 : 5개**
- **0011**
- **1001**
- **1111**
- 0000
- 1100

➡ 0이 2개일 때 : 1
➡ 0이 1개일 때 : $3C1$ = 3개 
➡ 0이 0개일 때 : 1개 

**N=5 : 8개** 
- **00001**
- 00100
- 10000
- **00111**
- **10011**
- **11001**
- 11100
- **11111**

➡ 0이 2개일 때 는 $3C1$ 5-2 = 3  3개곳 중 1이 위치 ➡ 3개 
➡ 0이 1개일 때 $4C1$ 
➡ 0이 0개일 때 1개 


**N=6: 12개**
- 0이 3개일 때 : 1 
- 0이 2개일 때 : $4C2$ = 6
- 0이 1개일 때 : $5C1$ = 5개 

**N=7: 26개** 
- 0이 3개일 때 : $4C1$ = 4개
- 0이 2개일 때 : $5C3$ = 20개 
- 0이 1일 때 : $6C6$ = 1개 
- 0이 0개일 때 : 1개 



