---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/DP, Greedy/문제풀이/백준 2253-점프 (다른 답 나중에 분석하기)/","noteIcon":"","created":"2025-08-03T13:58:46.221+09:00","updated":"2025-08-08T01:44:12.523+09:00"}
---

[

>[!SUCCESS]  반성공
>- 설계랑 구현 다하고 테스트케이스는 통과했는데, 예외를 못 찾아서 그 부분만 GPT한테 도움을 받았다.

### 리뷰 이유 
다 풀고 다른 사람들의 답을 보니 더 간결하게 다른 방식(BFS)으로 푸는 사람들도 있길래 한번 리뷰하고 싶었다. (+ GPT가 주는 코드도 분석해보고자) 

### 문제 
[BOJ 2253 - 점프](https://www.acmicpc.net/problem/2253)
- 돌들이 같은 간격으로 있다
- **목표** : 돌들 사이를 점프하면 N번째 돌로 이동하는 것
- **조건** 
	- 이동은 앞으로만 가능 
	- 처음 점프는 한 칸만 가능 
	- 그 다음 점프부터는 **가속/감속 점프 가능** (x-1칸 or x칸 or x+1칸)
	- 크기가 작은 돌들은 넘어가야 한다.(서있을 수 없음)
- **출력** : N번째 돌까지 가기 위해 필요한 최소의 점 프 횟수 
	- 불가능일 경우 : -1 출력 


### 내가 푼 답

#### 1. 아이디어 
![Pasted image 20250805094049.png](/img/user/supporter/image/Pasted%20image%2020250805094049.png)
- 우선, **2차원 배열로 DP를** 만들어야겠다고 생각했다
	- 이유 : 특정 돌의 위치에 특정 가속도로 도착했을 때의 점프 수를 캐시해야한다고 생각. 
- `dp[1][2]` 는 1로 세팅 
	- 첫 점프는 무조건 1이니 두번 째 돌로 점프하는 수는 1
- **금지된 영역 처리** 
	- 하얀색 영역으로 처리 
- **불가능 영역 처리**
	- 물리적으로 특정 가속도로는 못 가는 부분을 불가능 처리했다 (코드에서는 `float('inf')`)
	- 예를 들어, 가속도는 점프마다 1씩 증가할 수 있는데 5에 도달하기 전에는 절대 가속도가 3이 될 수 없다.
		- 1번 ➡ 2번으로(점프1, 가속도1)
		- 2번 ➡ 4번으로(점프2, 가속도2)
		- 즉, 5번돌까지는 절대 가속도 3이 될 수 없다는 것. 
		- 이렇게 예외부분을 찾아서 순회하면 훨씬 더 빠른 성능이 나올거라고 생각 
		  
- `dp[i][j]` = `min(dp[i-1][j-i], dp[i][j-i]) + 1`
	- 특정 가속도로 특정 돌에 도착했다는 것 = 현재 가속도만큼 전의 점프 수 + 1 

>[!danger] 예외처리 못 했던 부분
> - 다음 Row에서 이전 Row 값을 향해서 감속하는 부분 처리가 안되서 버그가 났다.
> - 변경 전 기존 코드는 아래의 3가지 경우만 고려한 코드였다
> 	1) 속도 변화 없이 특정 돌 도착 경우  
> 	2) 이전 속도 + 1 로 특정 돌 도착 경우
> -  💢즉, **감속해서 돌아오는 것(더 낮은 row로)을 고려하지 않았다**.


>[!tip] 예외처리 해결 부분
>- 처음에는 낮은 ROW부터 순회하는 기존 로직이 끝나면 높은 ROW부터 순회해서 감속코드를 짜야하나.... 라고 생각했다.
>- 근데 생각해보니 높은 ROW의 점프 수를 갱신하고 나서 그 Row의 (가속도 - 1) ROW를 갱신할 수 있다는 것을 알고 도입했다.
```PYTHON
    ## 이전 스피드 row도 갱신
    prev_speed_cur = cur + prev_speed
    if prev_speed_cur == target_stone: #nd dp[speed][cur] != float
      dp[prev_speed][prev_speed_cur] = min(dp[prev_speed][prev_speed_cur], dp[speed][cur] + 1)

    ## 다음 speed row도 갱신
    next_speed_cur = cur + next_speed
    if next_speed < max_speed and next_speed_cur < col and next_speed_cur not in small_stones:
      dp[next_speed][next_speed_cur] = min(dp[next_speed][next_speed_cur], dp[speed][cur] + 1)
```

#### 2. 제출 코드 
```python
import sys
input = sys.stdin.readline

target_stone, small_stone_count = map(int, input().split())
small_stones = set([int(input()) for _ in range(small_stone_count)])

if 2 in small_stones:
  print(-1)
  sys.exit()

max_speed = int((2*target_stone) ** 0.5) + 2
col = target_stone + 1
dp = [[float('inf')] * col for _ in range(max_speed)]

dp[1][2] = 1
#dp[0][1] = 0

start = 1
for speed in range(1, max_speed):
  start = start + speed  

  for cur in range(start, col):
    if cur in small_stones:
      continue

    prev_pos = cur - speed
    if prev_pos <= 0:
      continue

    # 속도 유지하면 도착 시? (cur-speed를 위에서 이미 처리하긴 했는데...)
    if dp[speed][prev_pos] != float('inf'):
      dp[speed][cur] = min(dp[speed][cur], dp[speed][prev_pos] + 1)

    # 이전 스피드에서 -1 하고 dp[speed][cur]에 도달한 경우
    prev_speed = speed -1
    if prev_speed > 0 and dp[prev_speed][prev_pos] != float('inf'):
      dp[speed][cur] = min(dp[speed][cur], dp[prev_speed][prev_pos] + 1)

    # 이전 스피드에서 +1 하고 dp[speed][cur]에 도달한 경우    
    next_speed = speed + 1
    if next_speed < max_speed and dp[next_speed][prev_pos] != float('inf'):
      dp[speed][cur] = min(dp[speed][cur], dp[next_speed][prev_pos] + 1)

    ## 이전 스피드 row도 갱신
    prev_speed_cur = cur + prev_speed
    if prev_speed_cur == target_stone: #nd dp[speed][cur] != float
      dp[prev_speed][prev_speed_cur] = min(dp[prev_speed][prev_speed_cur], dp[speed][cur] + 1)

    ## 다음 speed row도 갱신
    next_speed_cur = cur + next_speed
    if next_speed < max_speed and next_speed_cur < col and next_speed_cur not in small_stones:
      dp[next_speed][next_speed_cur] = min(dp[next_speed][next_speed_cur], dp[speed][cur] + 1)

answer = float('inf')
for i in range(max_speed):
  if dp[i][target_stone] < answer:
    answer = dp[i][target_stone]

if answer == float('inf'):
  print(-1)
else:
  print(answer)
```

**만들고 나니 아쉬웠던 점** 
- 하나의 루프에서 여러 방향의 의존성을 처리하다 보니 코드가 복잡해진다는 느낌을 받았다.
- 이를 어케 해결할까? 했다.
- 생각해보니 위의 코드를 보면, **이전 Speed를 기준으로 현재 `d[i][j]`를 갱신하고 추가로 현재 speed를 기준으로 다음 포지션 값을 갱신**하고 있었다.
- 이런 부분이 **중복**된다고 판단되어 갱신해보자 


#### 3. 리팩토링 코드 

**❌버그 발생 코드** 
- 이중 for문을 사용하는데 나의 코드는 주로 첫 for문을 row로 했다.
- 그렇게 하다보니 다음 row에서 속력이 줄어드는 경우의 예외처리가 필요해졌다(만약 그 코드를 쓰면 기존 코드랑 별 다른게 없다고 판단)
```python

# ... 생략 
# ❌ 버그가 발생하는 코드 
max_speed = int((2*target_stone) ** 0.5) + 2
col = target_stone + 1
dp = [[float('inf')] * col for _ in range(max_speed)]

dp[1][2] = 1
start = 1
for cur_speed in range(1, max_speed):
  start = start + cur_speed  
  for cur_pos in range(start, col):
    if cur_pos in small_stones:
      continue
    # 현재 속도 값을 기준으로 다음 pos를 갱신한다
    for add in (-1, 0, 1):
      next_speed = cur_speed + add

      # 속도가 비정상적일 떄
      if not (0 < next_speed < max_speed):
        continue
      next_pos = cur_pos + next_speed
      # col이 범위 밖 or 금지된 돌
      if not (0 < next_pos < col) or next_pos in small_stones:
        continue
      dp[next_speed][next_pos] = min(dp[next_speed][next_pos], dp[cur_speed][cur_pos] + 1)
```


**✅올바른 코드** 
다음 row의 상황을 최대한 반영하기 위해서는 **첫 for문을 col을(돌의 위치) 기준으로** 하는 것이 좋다.
> 아래의 사진처럼 첫 for문을 위 아래로 훝는 것 

![Pasted image 20250805112015.png](/img/user/supporter/image/Pasted%20image%2020250805112015.png)

```python
import sys
input = sys.stdin.readline

target_stone, small_stone_count = map(int, input().split())
small_stones = set([int(input()) for _ in range(small_stone_count)])

if 2 in small_stones:
  print(-1)
  sys.exit()

max_speed = int((2*target_stone) ** 0.5) + 2
col = target_stone + 1
dp = [[float('inf')] * col for _ in range(max_speed)]


#############################################################################
possible_start = [0] * max_speed
for s in range(1, max_speed):
  possible_start[s] = (s*(s+1) // 2) + 1

dp[1][2] = 1

start = 1
for cur_pos in range(1, col):

	if cur_pos in small_stones:
      continue
      
  for cur_speed in range(1, max_speed):
    # 뒤 speed는 당연히 cur_pos에 못가니 안쪽 for문 break
    if cur_pos < possible_start[cur_speed]:
      break
      
    # 현재 속도 값을 기준으로 다음 pos를 갱신한다
    for ds in (-1, 0, 1):
      next_speed = cur_speed + ds      
      # 속도가 비정상적일 떄
      if not (0 < next_speed < max_speed):
        continue

      next_pos = cur_pos + next_speed
      # col이 범위 밖 or 금지된 돌
      if not (0 < next_pos < col) or next_pos in small_stones:
        continue

      dp[next_speed][next_pos] = min(dp[next_speed][next_pos], dp[cur_speed][cur_pos] + 1)  

#############################################################################
answer = float('inf')
for row in dp:
  val = row[target_stone]
  if val < answer:
    answer = val

print(-1 if answer == float('inf') else answer)
```


✔**성능개선** 
1. **Python3 기준**
	- ![Pasted image 20250805113520.png](/img/user/supporter/image/Pasted%20image%2020250805113520.png)
	- **개선 결과 : 35% 성능 개선**(2440ms ➡ 1584 ms)
	  
2. **pypy 기준** 
	- ![Pasted image 20250805113459.png](/img/user/supporter/image/Pasted%20image%2020250805113459.png)
	- **개선 결과 : 35% 성능 개선**(376ms ➡ 248ms)


### GPT 답 (BFS 버전)

> 다른 사람들의 코드를 보고, GPT코드를 보니 이 문제는 거의 BFS로 푸는게 정석이라고 한다.
> (근데 지금 키워드가 DP라 DP로 풀어버린 것)


### 타인 답 (DP 간결 버전)

```PYTHON
from math import sqrt
import sys

target,cannot_num=list(map(int,sys.stdin.readline().strip().split()))
cannot_set=set(int(sys.stdin.readline().strip()) for _ in range(cannot_num))


jump_max=int(sqrt(2*target))+1 # 최대로 뛸수 있는 범위
dp=[[float('inf')]*(jump_max+2) for _ in range(target+1)] # dp[stone][jump_dist] stone까지 jump_dist로 갔을 때 최소 비용

dp[1][0]=0
for cur in range(2,target+1): # 어디에 도착했는지
    if cur in cannot_set:
        continue

		for jumped in range(1,jump_max+1):# 몇칸 앞으로 뛰었어서 왔는지
        if cur-jumped<1:
            break
            
        dp[cur][jumped]=
			        min(dp[cur-jumped][jumped+1],dp[cur-jumped][jumped],dp[cur-jumped][jumped-1])+1

# print(*dp,sep="\n")
result=min(dp[target])
print(result if result!=float('inf') else -1)
```
