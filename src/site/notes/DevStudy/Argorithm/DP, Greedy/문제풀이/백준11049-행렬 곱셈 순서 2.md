---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/DP, Greedy/문제풀이/백준11049-행렬 곱셈 순서 2/","noteIcon":"","created":"2025-08-02T23:49:24.476+09:00","updated":"2025-08-03T10:48:12.127+09:00"}
---


>[!danger] 못 품 
>- 체감 난이도 **플레급** 🥊
>	- 구현적으로도 그렇고 
>	- **시간적으로도 매우 빡빡한 문제** 
>- 40분 생각했는데 설계 자체가 시작이 안돼서 답을 보게 되었다.
>- 답을 봤는데도 이해하는데 엄청 오래 걸렸다 
>- 심지어 이 문제를 Python으로 풀 시 여러 이슈들을 접하게 되는데 그 이슈들을 하나하나 다 해결하다가 하루가 끝났다... 
>	- 이렇게 속도적으로 구린 언어라 민감하다면 Python포기하지... Jungle 알고리즘 커리큘럼 끝나고 Java로 코테나 준비해야겠다 


### 핵심 아이디어 
> 이 문제를 풀기 위해 이해해야 하는 것
> - 행렬 곱셈의 원리 
> - 분할정복 개념 
> - DP 캐시 

#### 1. 행렬 곱셈의 원리 

행렬 A: `P x Q`, B: `Q x R` 를 곱하면 오른쪽과 같은 결과가 나온다 → A × B = `P x R`
- 즉, A의 행 X B의 열 의 형태가 된 것 

문제에서는 연속으로 곱해지는 행렬이 주어진다고 했는데, 그렇다면 A~G까지 행렬이 있을때 최종 형태는 `A의 row x G의 col`이 될 것이다.
![Pasted image 20250803100937.png](/img/user/supporter/image/Pasted%20image%2020250803100937.png)

 > **언제 쓰일까?? (맛보기)**
 > - 일단 맛보기로 알아보자면, 여러 경우의 수를 따져서 문제에서 요구하는 곱셈 연산의 수를 구할건데, 그럴 때 가장 중요한게 행렬의 형태이다. 
 > - 따라서 각 경우의 수마다 행렬 형태 공식을 활용해서 최소 곱셈 연산의 수를 구할 때 활용될 것 
 

#### 2. 분할 정복 개념 
> - 뒤에서 나오지만, **상향식으로 풀것이라 분할정복은 아니지 않나? 라고 생각이 들 수 있다.**
> - 하지만, 나는 **처음에** 이 문제에서 **어떻게 분할정복과 재귀의 개념을 적용할지를 이해**한 다음에 하향식으로 풀었다. 물론, 인터프리터 언어인 Python의 한계로 이 문제를 Python으로 푼다면 하향식 접근은 시간초과가 되어 있다. 
> - 이로 인해, 마지막으로 상향식으로 다시 바꾸긴 했는데, **결국 아이디어는 똑같기** 때문에 이 개념을 어떻게 적용할지 이해하는 것이 중요하다.0


우선 행렬이 4개일 때 간단한 예시를 생각하자
- A~D의 행렬이 있고, 각각의 행렬은 Row, Col을 갖고 있다.
- 문제의 전제는 곱셈이 성립한다는 가정이므로 **행렬곱셈 원리**에 의해 `N번째 Row = N-1번째 Col`이 성립한다![Pasted image 20250803101632.png](/img/user/supporter/image/Pasted%20image%2020250803101632.png)
- 이럴 경우 곱할 수 있는 **경우의 수**는 다음과 같다. ![Pasted image 20250803101855.png](/img/user/supporter/image/Pasted%20image%2020250803101855.png)
	- **기본적인 분할정복**에서는 **특정 중간값을 기준으로 좌우로 나눠서 작은 단위로 문제를 해결하고 합치는** 작업을 했었는데, 여기서도 그런 개념을 생각하면 된다.
	- **예시** - 가령, `((AB) C ) D` 이렇게 괄호순으로 ABCD를 곱한다고 가정하자
		- 이는 index(k) = 2 를 기준으로 `ABC | D` 이렇게 우선 나누고, 
		- 나눠진 왼쪽 부분(`ABC`)을 또 index = 1 을 기준으로 나눈 `(AB | C) | D` 값이 된다.
		- `(AB | C)` 를 먼저 보자면
			- **ABC를 곱했을 때의 최소 곱셈 연산수** = `"AB"최소 곱셈 연산수 + "C"곱셈 최소 곱셈 연산수 + (AB의 최종행렬과 C를 곱했을 때 최소 곱셈 연산수)` 가 된다. 
			- 최소 곱셈 연산수는 행렬의 형태를 보고 문제에서 주어진대로 구하면 된다. 
		- 그 다음 `(AB | C) | D` 를 보면 
			- 우선, 위에처럼 ABC 부분에서 최소값 그거를 구한다
			- 근데 `AB|C`순서든 `A|BC` 순서든  위의 사진처럼 결국 `ABC`곱셈의 최종 형태는 `a X d`가 될 것이다.
			- 이를 활용한다면 **`ABC | D` 곱셈 시** 계산되는 최소 곱셈 수는 이전의 최소 곱셈 수 구하는 과정과 상관없이 **행렬의 모양만 따지면 되는 것** 
	- 다른 예시인 `(A ((BC) D))`도 마찬가지다 ![Pasted image 20250803102959.png](/img/user/supporter/image/Pasted%20image%2020250803102959.png)
- **어떻게 코드로 구현할 것인가❓**
	1. **하향식 접근법(재귀)**
		- 행렬의 배열이 있다고 가정할 때, 위에서 언급한 임의의 중간 값이 `K`를 `0 ~ 마지막 index` 로 대입하고 재귀하면서 진행한다.
			```python
			  cost = float('inf')
			  for k in range(x, y):
			    left_cost = calculate_cost(matrix, x, k)
			    rigth_cost = calculate_cost(matrix, k+1, y)
			    # 유니온 코스트 = 좌 - 우 최종 행렬을 곱할 때의 최소 연산 수			
			    ## 최종 left 행렬의 row와 col을 곱하고 최종 right 행렬의 col을 곱함
			    union_cost = matrix[x][0] * matrix[k][1] * matrix[y][1]			
			    cost = min(cost, left_cost + rigth_cost + union_cost)
			```
		  
	2. **상향식 접근법** 
		- 아이디어는 거의 유사.
		- 3중 for문을 돌려야 한다.
			1. 첫 for문 : 곱하는 행렬의 길이별로 경우의 수를 따져야 해서 
			2. 두 for문 : 첫 시작 인덱스와 길이에 맞는 끝 인덱스를 정하기 위해 
			3. 세 for문 : 2번에서 정한 범위 내에서 중간값 k를 기준으로 최소 곱셈 비용을 계싼하기 위해 
			```python
			for length in range(2, N+1):
		    for i in range(N - length + 1):
		      j = i + length - 1
		      # k는 중간점
		      for k in range(i, j):
		        left_cost = dp[i][k]
		        right_cost = dp[k+1][j]	
		        union_cost = matrix[i][0] * matrix[k][1] * matrix[j][1]
		        total_cost = left_cost + right_cost + union_cost	
		        if dp[i][j] > total_cost:
		          dp[i][j] = total_cost
			```
> 이 때 DP를 써야하는데 이거는 3번에서 

#### 3. DP 적용 
> 하향식이든 상향식이든 결국 이전에 구했던 DP배열을 쓴다

>[!QUESTION] 왜 DP를 써야하는가❓
![Pasted image 20250803103900.png](/img/user/supporter/image/Pasted%20image%2020250803103900.png)
>- 위의 사진은 ABCD를 곱할 때의 경우의 수이다.
>- 각 경우의 수를 보면 겹치는 곱셈 부분이 있다. ex) AB, CD, BC 
>- 매번 경우의 수에서의 최소곱셈연산을 계산할 때 Full로 연산 때리면 굉장히 속도가 느려질 것이다.
>- 그래서 겹치는 부분은 연산을 하지 않도록 DP 캐시를 활용할 것 


- **DP의 형태는 2차원 배열**로 만들 것이다.
- 왜냐면 "어디서부터 어디까지의 곱셈이 ~다" 라는 것을 표시하기 위해서는 2개의 표시가 필요하기 때문
- 따라서 "`dp[i][j]` = i ~ j 까지 곱했을 때 최소 곱셈 연산 수"가 된다.



### 정답 코드 
> 시간에 되게 민감한 문제라 함수 호출 자체를 줄였다
```python
import sys

input = sys.stdin.readline
N = int(input())

matrix_1d = []
for i in range(N):
  row, col = map(int, input().split())
  if i == 0:
    matrix_1d.append(row)
  matrix_1d.append(col)

dp = [[float('inf')]*N for _ in range(N)]
for i in range(N):
  dp[i][i] = 0

for length in range(2, N+1):
  for i in range(N - length + 1):
    j = i + length - 1
	  # k는 중간점
    for k in range(i, j):
      left_cost = dp[i][k]
      right_cost = dp[k+1][j]
      union_cost = matrix_1d[i] * matrix_1d[k+1] * matrix_1d[j+1]
      total_cost = left_cost + right_cost + union_cost
      if dp[i][j] > total_cost:
        dp[i][j] = total_cost

print(dp[0][N-1])
```




### 이슈들 

#### 1. 탑다운 방식에서의 시간초과 
```python 
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

dp = []
def calculate_cost(matrix: list[tuple], x: int, y: int) -> int:
  # 종료 조건
  if dp[x][y] != -1:
    return dp[x][y]
  if x >= y:
    return 0

  cost = float('inf')
  for k in range(x, y):
    left_cost = calculate_cost(matrix, x, k)
    rigth_cost = calculate_cost(matrix, k+1, y)
    # 유니온 코스트 = 좌 - 우 최종 행렬을 곱할 때의 최소 연산 수
    ## 최종 left 행렬의 row와 col을 곱하고 최종 right 행렬의 col을 곱함
    union_cost = matrix[x][0] * matrix[k][1] * matrix[y][1]
    cost = min(cost, left_cost + rigth_cost + union_cost)

  dp[x][y] = cost
  return dp[x][y]

def solution(N, matrix: list[tuple]):  
  global dp
  dp = [[-1]*N for _ in range(N)]
  result = calculate_cost(matrix, 0,len(matrix) - 1)
  print(result)

if __name__ == "__main__":
  N = int(input())
  matrix = [tuple(map(int, input().split())) for _ in range(N)]
  solution(N, matrix)
```
처음에 한 영상([알고리즘 문제풀이 영상](https://www.youtube.com/watch?v=Tdl6VP4bS90))을 보고 탑다운 방식으로 풀어보았다.
그런데 시간초과가 떴다. 
엥??? 영상의 코드와 내 코드를 비교하는데 똑같은데 왜 실패하는거지?? 
알고보니 C++과 Python의 차이로 인해 발생한 결과 차이였다.(영상 풀이 기준 = C++)
- **C++** 은 굉장히 빠른 언어로 탑다운 방식같이 **재귀 호출이 많아도 시간 문제가 크게 없다.**
- 하지만 **Python은** 컴파일러가 아닌 **인터프리터 언어**이기 때문에 **함수 호출에 굉장히 비싼 비용**이 든다. 
- 따라서, 이 문제를 Python으로 풀기 위해서는 **재귀 호출이 없는 Bottom-Up 방식을 택해야** 한다. 

#### 2. 공간 최적화 : Matrix를 1차원 배열로
기존 코드에서는 각 행렬을 `(row, col)` 형태의 튜플로 Matrix 리스트에 저장했다.
```python
	# 기존 
  N = int(input())
  matrix = [tuple(map(int, input().split())) for _ in range(N)]
```
> **하지만 행렬 곱셈의 원리를 조금만 생각하면 1차원 배열로도 충분히 이 문제에 이용할 수 있다.**

일단 이 문제에서 행렬 정보가 있는 Matrix가 필요한 이유는??
- `union_cost = matrix[i][0] * matrix[k][1] * matrix[j][1]` 이 부분에서만 쓰인다.

✔그렇다면 **이제 행렬 곱셈의 특징**에 대해 알아보자 
- 행렬 A: `P x Q`, B: `Q x R` → A × B = `P x R`
- 즉, A의 행 X B의 열 의 형태가 된 것 

문제의 조건은 행렬이 무조건 곱해질 수 있는 순서대로 주어진다고 했다.
그렇다면 첫 행렬을 제외하고는 **`i번째 행렬의 row = i-1번째 행렬의 col`이 성립**한다.
이를 기반으로 아래와 같이한다면 **1차원 배열만으로도 필요한 모든 정보 저장이 가능**하다
```python
  matrix_1d = []
  for i in range(N):
    row, col = map(int, input().split())

    if i == 0: # 처음엔 row 채우기 
      matrix_1d.append(row)

    matrix_1d.append(col)
```
> 효과 : 메모리 효율성 

#### 3. min()대신 if문으로 -> 시간초과 해결 
문제를 풀면서 `dp[i][j] = min(dp[i][j], ...)` 구조를 사용했을 때는 시간 초과가 발생했지만,  
동일한 의미를 갖는 `if` 조건문으로 바꾸자 통과가 되었다.
>[!QUESTION] 일이 발생한 이유가 뭘까? **파이썬 함수 호출 오버헤드** 
>- Python은 **인터프리터 언어라 함수 호출이 굉장히 비싸다**
>- 특히 반복문에서 여러번 호출될 경우, **작은 오버헤드가 누적되어 성능 저하**가 눈에 띄게 나타날 수 있다. 


