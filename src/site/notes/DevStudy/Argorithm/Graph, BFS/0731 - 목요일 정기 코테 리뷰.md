---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/0731 - 목요일 정기 코테 리뷰/","noteIcon":"","created":"2025-07-31T15:38:35.996+09:00","updated":"2025-08-01T01:17:09.353+09:00"}
---


Krafton 알고리즘 주차에서는 매주 목요일 9:00 ~ 11:30에 3개의 코딩 테스트 문제를 본다.
아래는 이번에 나온 3가지 문제이다
- [백준 1338](https://www.acmicpc.net/problem/1388) (바닥장식)
- [백준 2667](https://www.acmicpc.net/problem/2667) (단지번호붙이기)
- [백준 18405](https://www.acmicpc.net/problem/18405) (경쟁적 전염)


이번 주차의 문제는 여태까지에 비해 상대적으로 문제들이 쉬웠던 것 같다.
하지만 마지막 문제에서 시간이 30분도 안 남았고 푸는 방법을 다 생각해놓고 구현도중 Time-out되어서 마지막 문제는 못 풀긴 했다.


### 1번 리뷰 

[백준 1338](https://www.acmicpc.net/problem/1388) (바닥장식)

> 대부분 DFS로 풀었는데 나는 재귀 호출 없이 2중 for문을 통해 continue flag를 두어서 순회하는 방식으로 풀어갔다. 


#### 나의 코드
```python
import sys
input = sys.stdin.readline
from typing import List

wood_count = 0

def calculate_vertical_wood(graph: List[list]):
  vertical = "-"
  # 연속인지 아닌지
  count = 0
  # 컨티뉴가 아닌데 s를 만나면 count +
  # 컨티뉴인데 s 만나면 그냥 진행
  # 컨티뉴 False : |를 만났을 때
  # 컨티뉴 True : s를 만났을 때
  is_continue = False
  for row in graph:
    is_continue = False
    for r in row:
      if r == vertical and not is_continue:
        count += 1
        is_continue = True
        
      if r != vertical:
        is_continue = False

  return count
  

def calculate_horizontal_wood(graph: List[list]):
  horizontal = "|"
  # 연속인지 아닌지
  count = 0
  is_continue = False
  
  for col in range(len(graph[0])):
    is_continue = False
    for row in graph:
      if row[col] == horizontal and not is_continue:
        count += 1
        is_continue = True

      if row[col] != horizontal:
        is_continue = False

  return count

  
if __name__ == "__main__":
  height, width = map(int, input().split())
  
  graph = [[] for _ in range(height)]
  for i in range(height):
    row = input().strip()
    for r in row:
      graph[i].append(r)
      
  vc = calculate_vertical_wood(graph)
  hc = calculate_horizontal_wood(graph)
  print(vc + hc)
```

> DFS를 딱히 생각하지 않고 위처럼 직관적인 방법으로 풀었다.
> 근데, 대부분 DFS로 풀었길래 나도 한번 다시 DFS로 풀어보고자 한다

#### DFS로 다시 풀어보기 


```python
import sys
input = sys.stdin.readline

def dfs(graph: list, cur_row, cur_col, visited: list):
  visited[cur_row][cur_col] = True
  s = graph[cur_row][cur_col]
  direction_move = (0, 1) if s == "-" else (1,0)
  moved_row = cur_row + direction_move[0]
  moved_col = cur_col + direction_move[1]

  # 범위 밖 움직임 or 이미 방문
  if not (0<= moved_row < len(graph)) or not (0<= moved_col < len(graph[0])) or visited[moved_row][moved_col]:
    return

  # 내가 찾는 문자면 더 가~~
  if graph[moved_row][moved_col] == s:
    dfs(graph, moved_row, moved_col, visited)

if __name__ == "__main__":
  height, width = map(int, input().split())
  visited = [[False]*width for _ in range(height)]
  graph = [list(input().strip()) for _ in range(height)]
  count = 0  

  for i in range(height):
    for j in range(width):
      if not visited[i][j]:
        count += 1
        dfs(graph, i, j, visited)

  print(count)
```

**✅이 방식의 특징** 
- **한번만 순회하면된다.** 
	- 이전 방식 : 문자의 종류별로 graph를 도는 방식이다.
	- 현재 방식 : 이 방식을 문자가 뭐든 상관없이 일단 dfs를 도는 방식

- **문자별로 동일한 메서드 사용**
	- 내 방식은 문자별로 다른 메서드를 사용하게 설계했다.
	- 하지만 이 방식은 move 튜플을 활용해서 가로든 세로든 상관없이 이 메서드를 사용할 수 있게 했다.





### 3번 리뷰 
- 시간이 없어서 못 푼 문제. 어렵지는 않았다.
- 설계도 다 하고 코드 작성 도중 시간이 끝난....


```python
import sys
from collections import deque
input = sys.stdin.readline
from typing import List

def find_virus_first_position(graph: List[list[int]]) -> list:

  positions = []
  for i in range(len(graph)):
    for j in range(len(graph[i])):
      if graph[i][j]:
        positions.append((graph[i][j], i, j))

  return positions
  

# 상 하 좌 우 
direction_move = [(-1,0), (1,0),(0,-1),(0,1)]

def spread(graph: List[list[int]], queue: deque):

  result = [] 
  while queue:
    num, cur_row, cur_col = queue.popleft()
    
    for i in range(4):
      to_move_row = cur_row + direction_move[i][0]
      to_move_col = cur_col + direction_move[i][1]

      
      # 범위를 넘어서는 움직임 or 이미 색칠한 곳 
      if not (0 <= to_move_row < N) or not (0 <= to_move_col < N) or graph[to_move_row][to_move_col]:
        continue

      graph[to_move_row][to_move_col] = num
      result.append((num, to_move_row, to_move_col))
  
  return result

if __name__ == "__main__":
  N, K = map(int, input().split())

  graph = [list(map(int, input().split())) for _ in range(N)]

  S, X, Y = map(int, input().split())

  dq = deque()
  # (num, x, y)
  positions: list[tuple] = find_virus_first_position(graph)
  for position in sorted(positions):
    dq.append(position)

  while S > 0:      
    result = spread(graph, dq)

    # deque에 추가 
    if S > 1:
      for p in result:
        dq.append(p)
    
    S -= 1 
  
  print(graph[X-1][Y-1] if graph[X-1][Y-1] else 0)
```



> [!WARNING] 시간조절!!!
> - 아직 문제를 빠르게 못 푸는 것 같다...
> - 아직 덜 익숙한가보다



