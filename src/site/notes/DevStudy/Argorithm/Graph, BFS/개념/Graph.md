---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/개념/Graph/","noteIcon":"","created":"2025-07-24T14:30:40.687+09:00","updated":"2025-08-01T00:12:04.160+09:00"}
---


### 개념 

- 다양한 관계를 추상화하여 모델링하는 데 사용되는 자료구조
- **2가지 구성요소**
	1. **정점**(Vertext / Node)
	2. **간선**(Edge / Arc) : 정점들 사이의 관계나 연결

### 그래프 종류 
> 간선의 특성에 따라 여러 종류 
> - 그래프의 방향이 있는지❓ 없는지 ❓

#### 1. 무방향 그래프(Undirected)
- 간선에 방향이 없는 그래프 
- 방향 상관없이 동일하다 
- **예시** : 친구관계, 도로 네트워크(양방통행)
- **특징** 
	- (A,B)간선이 존재하면 (B, A)간선도 존재 

#### 2. 방향 그래프(Directed)

- 간선에 **방향이 있는** 그래프 
- **예시** : 팔로우 관계, 일방통행 도로 
- 자기 자신을 가리킬 수도 있다.

#### 3. 가중치 그래프(Weighted Graph)
- **간선에 가중치가 부여**된 그래프 
- **가중치 예시** : 간선 비용, 거리, 시간, 용량 등 
- 최단 경로 찾기 시 핵심 

### 그래프 표현방법
> 컴퓨터 메모리에 그래프를 저장하는 방법은 크게 2가지가 있다. 

#### 1. 인접 행렬(Adjacency Matrix)
![Pasted image 20250724143921.png](/img/user/supporter/image/Pasted%20image%2020250724143921.png)
>[!EXAMPLE] 개념
>- 그래프를 **2차원 배열**에다가 표현 (그래프 크기 = $노드개수^2$)
>- 배열의 `matrix[i][j]` : 정점 i와 정점 j 사이에 간선이 있는지를 표시 
>- 서로 연결된 Node들은 1로 표현 (안되면 0)
>- **무방향 그래프 + 인접 행렬 ➡ 항상 대칭적** 


> 인접행렬 코드 예시
```python
N = 5  # 노드의 개수
graph = [[0]*N for _ in range(N)]

edges = [
  (0, 1),
  (0, 4),
  (1, 2),
  (1, 3),
  (2, 3),
  (3, 4)
]

for u, v in edges:
  graph[u][v] = 1
  graph[v][u] = 1 # 무방향일 경우 대칭화 必

for row in graph:
  print(row)

[0, 1, 0, 0, 1]
[1, 0, 1, 1, 0]
[0, 1, 0, 1, 0]
[0, 1, 1, 0, 1]
[1, 0, 0, 1, 0]
```

>[!tip]  장단점 
>1. ✅**장점**
>	- 간선 존재 여부 **확인이 빠름** : O(1)
>	- **구현이 단순** 
>2. **💢단점**
>	- **높은 공간 복잡도** : $O(V^2)$ 의 공간복잡도 ➡ 메모리 낭비 
>	- **간선 탐색 시** $O(V)$ : 특정 노드의 모든 이웃을 찾으려면 해당 행 전체를 스캔해야 함 
>	- **희소 그래프(간선이 적은)에서 비효율적** : 간선이 매우 적은 경우 대부분의 셀이 0일텐데 **메모리 낭비**가 너무 심해진다


#### 2. 인접 리스트(Adjacency List)
#메모리_절약 
![Pasted image 20250724144015.png](/img/user/supporter/image/Pasted%20image%2020250724144015.png)

>[!EXAMPLE] 개념 
>- 배열에 Node들을 나열하고 관계를 Linked List로 표현하는 방법
>- 각 정점에 **연결된 이웃 정점들을 리스트(or 백터, 연결 리스트)로 저장**하는 방식 
>- `list[i]` = 정점 i에 연결된 모든 정점들의 목록을 포함 

> 코드 예시 
```python
V = 5  # 노드 개수
graph = [[] for _ in range(V)]

# 간선 정보
edges = [
    (0, 1),
    (0, 4),
    (1, 2),
    (1, 3),
    (1, 4),
    (2, 3),
    (3, 4)
]

for u, v in edges:
  graph[u].append(v)
  graph[v].append(u) # 무방향일 경우

for i in range(V):
  print(f'노드 {i}와 연결된 노드들 : {graph[i]}')

# 노드 0와 연결된 노드들 : [1, 4]
# 노드 1와 연결된 노드들 : [0, 2, 3, 4]
# 노드 2와 연결된 노드들 : [1, 3]
# 노드 3와 연결된 노드들 : [1, 2, 4]
# 노드 4와 연결된 노드들 : [0, 1, 3]
```
- graph를 리스트로 만든다. 
- 각 원소는 리스트 형태이다.
- 특정 노드와 연결된 노드를 아주 빠르게 찾을 수 있다 

>[!tip] 장단점
>1. 장점 ✅
>	- **메모리를 덜 씀** : 실제로 연결된 노드만 저장함. 따라서, 간선이 적을 때 효율적 .
>	- **간선 순회가 빠르다** : 특정 노드에 **연결된 노드만 바로 탐색**하므로 **DFS, BFS 등 그래프 순회 시 효율적** 
>	- **동적 그래프에 유리** : 간선 추가/삭제 시 append, remove만 하면 됨 
>	  
>2. 단점 💢
>	- **간선이 많은 그래프에서는 불리**
>		- 간선이 많은 경우 리스트 순회 비용이 커져서 조회/수정 부담 
>		- 오히려 이 경우는 인접 행렬이 더 나을 수 있음 
>	- **연결 여부 확인 시 느리다**
>		- 인접 행렬 : $O(1)$
>		- 인접 리스트 : $O(연결된 노드 수)$


>[!QUESTION] 언제 어떤 표현 방법 선택❓ (인정 행렬 vs 인접 리스트)
>- **인접 행렬** : 연결 여부 확인이 빈번할 때 
>- **인접 리스트** : 연결된 것들 확인하고 싶을 때(친구 목록) 


