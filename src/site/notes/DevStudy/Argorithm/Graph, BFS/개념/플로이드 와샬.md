---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/개념/플로이드 와샬/","noteIcon":"","created":"2025-12-03T14:52:52.229+09:00","updated":"2025-12-13T18:25:27.356+09:00"}
---




※**다익스트라**는 하나의 정점에서 다른 모든 정점으로의 최단경로 구하는 알고리즘 
### 정의 및 특징 
#### ✔정의 
- **모든 정점에서 모든 정점으로의 최단 경로**를 구하는 알고리즘
	- 따라서, 2차원 배열을 사용해야 함 
- 거쳐가는 노드를 중심으로 문제를 해결하는 방법 
	- `i`에서 `j`로 가려고 할 때 바로 가는 것보다 특정 노드 `K`를 거쳐가는게 더 빠를 수도 있으니 
- DP를 활용 
 
#### ✅장점 
- **모든 쌍의 최단 경로를 한 번에 계산**한다
- **음수 가중치 간선을 처리**할 수 있다 unlike 다익스트라 
- **구현이 간단** 

#### 💢단점
 1. **높은 시간복잡도**
	- 3개의 중첩문 ➡ **시간 복잡도 = $O(N^3)$** (*N = 정점의 개수*)
	- 따라서 정점의 개수가 많지 않은 경우 효과적으로 사용될 수 있다.
	  
2. **음수 사이클이 있는 경우 제대로 작동하지 않는다.**
	- 음수 사이클이 있으면 무한으로 작아지는 값으로 최단경로가 계산될 수 있다.
	- 따라서 음수 사이클을 감지하는 것이 필요 

### 그림 예시 

![Pasted image 20250729192517.png](/img/user/supporter/image/Pasted%20image%2020250729192517.png)
![Pasted image 20250729192543.png](/img/user/supporter/image/Pasted%20image%2020250729192543.png)
![Pasted image 20250729192557.png](/img/user/supporter/image/Pasted%20image%2020250729192557.png)


>[!QUESTION]  하나의 경로만 고려하는 방식이라 한계가 있지 않은가??? ❌

![Pasted image 20250729192623.png](/img/user/supporter/image/Pasted%20image%2020250729192623.png)
- 노드를 하나씩 열어 가는 과정에서 **우회 경로의 각 구간**이 차례로 최적화되고,
- 마지막 단계(N)에서는 **모든 우회 경로**가 한꺼번에 후보에 올라 최종 최단거리가 된다.
### 활용 예시 

| 분야         | 설명                                                         |
| ---------- | ---------------------------------------------------------- |
| 작은 범위 길 찾기 | 지도상의 모든 지점 간 최단 거리를 미리 계산해 놓는 경우(시간 복잡도가 높아서 소규모 지역에서만 가능) |
| 게임 맵 최단 경로 | 고정된 맵의 중요지점 간 최단 경로를 게임 시작 전에 미리 계산 (동적인 맵에는 비효율적)         |


### 코드

```python
import sys
from typing import List
input = sys.stdin.readline
INF = float('inf')

'''
1. 초기 배열(단경로)과 결과 배열을 생성
2. 결과 배열에 초기 배열 값을 복사 (2중 for문) - clone있나?
3. 3중 for문으로 플로이드 와샬 ㄱ : 핵심 = 거쳐가는 노드가 기준
  - 첫 for => 거쳐가는 노드 (k)
  - 두 for => 출발 노드 (i)
  - 세 for => 도착 노드 (j)
    - (i -> k -> j) < (i -> j) 면은 갱신
'''

def floyd_warshall(graph: List[List[int]]) -> List[List[int]]:
  '''
  args:
    graph : 인접 행렬 형태의 그래프
  '''
  # 정점의 개수 (N * N 이라 가정)
  num_vertices = len(graph)

  # 최단 거리 저장할 2차원 배열 (초기 상태 = Graph와 동일 )
  dist = [[graph[i][j] for j in range(num_vertices)] for i in range(num_vertices)]

  # 자기 자신 경로는 0 - 안해도 되긴 함 (명시적 표현)
  for i in range(num_vertices):
    dist[i][i] = 0

  # k : 경유 노드
  for k in range(num_vertices):
    # i : 출발 노드
    for i in range(num_vertices):
      # j : 도착 노드
      for j in range(num_vertices):
        # 오버 플로우 방지 + 하나라도 무한대라면 그건 최단이 될 수 없다.
        if dist[i][k] == INF or dist[k][j] == INF:
          continue

				# i or j 가 k이랑 겹치면 더해봤자임 
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

  return dist

if __name__ == '__main__':
  graph = [
    [0, 5, INF, 10],
    [INF, 0, 3, INF],
    [INF, INF, 0, 1],
    [INF, INF, INF, 0]
  ]
  
  result = floyd_warshall(graph)
  for row in result:
    for val in row:
      print(val if val != INF else "INF", end=" ")  

    print()
```


>[!QUESTION] I -> J 로 갈 때 경유지가 여러개인 경우는❓❓
>- `dist[i][j]`는 지금까지 허용된 노드만 거쳐 가는 최단 비용이다


### 추천 BOJ 링크 

- [바이러스](https://www.acmicpc.net/problem/2606)
- [플로이드](https://www.acmicpc.net/problem/11404)

