---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 11725 - 트리의 부모 찾기(인접리스트 예시)/","noteIcon":"","created":"2025-07-24T21:34:36.836+09:00","updated":"2025-08-01T01:11:51.049+09:00"}
---



참고 링크 : [[DevStudy/Argorithm/Graph, BFS/개념/Graph\|Graph]]

>[!tip] 이유
>- 정글에서의 Week3이 Graph가 포함되어 있는데 양도 많고 책에 내용도 별로 없는 것 같아서 직접 문제를 보면서 잠깐 고민하고 답안 해설 보면서 Graph를 공부하는 식으로 방향을 정했다.
>- 너무 생소한 방법들이라 아직 실버 문제를 보고 분석하면서 공부해야 할 것 같다.

### 문제 링크 

[BOJ 11725 - 트리의 부모 찾기](https://www.acmicpc.net/problem/11725)
### DFS 모범 답안 
```PYTHON
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

graph = [[]]
def dfs(u , parents):
  for v in graph[u]:
    if parents[v] == 0: # 마킹이 안 되어 있을 경우만 DFS
      parents[v] = u
      dfs(v, parents)

if __name__ == '__main__':
  N = int(input())
  graph = [[] for _ in range(N+1)]  # 인접 리스트 사용
  for _ in range(N-1):
    u, v = map(int, input().strip().split())
    graph[u].append(v)
    graph[v].append(u) # 무방향이라 

  # 각 노드의 부모를 담을 그릇
  parent = [0] * (N + 1)
  parent[1] = 1  # 1번 노드는 무조건 표시 해놓기
  dfs(1, parent)
  output = parent[2:]
  print("\n".join(map(str, output)))
```
1. **인접 리스트 생성** 
	- N + 1 개의 리스트 배열 `graph`를 만들어 간선 정보를 저장한다.
	- 문제는 무방향이니 대칭적으로 저장 
	  
2. **탐색 방법 선택 (DFS or BFS)**
	- DFS : 재귀 호출이 너무 많아지긴 함 
	- BFS : 큐 사용 
3. **각 노드의 부모를 담을 그릇 (parent) 생성** 
![Pasted image 20250725004018.png](/img/user/supporter/image/Pasted%20image%2020250725004018.png)
> [!WARNING] 그래프는 그냥 임의로 그린 것 + 방향은 무방향이지만 그림 위치 조정을 편하게 하려면 화살표를 써야 돼서 화살표는 무의미 

![Pasted image 20250725002539.png](/img/user/supporter/image/Pasted%20image%2020250725002539.png)
- 현재 정점(노드) 와 연결된 모든 이웃(v)를 차례로 본다 
- 루트에서부터 시작하므로 탐색은 반드시 아래로 간다.
- **방문 처리 필요 이유** : 무방향이라 방문처리를 하지 않으면 무한 재귀 호출이 되어버림 

> 자세한 설명은 사진 참고 

### BFS 모범답안 

> - DFS랑 접근 아이디어는 똑같다. 단지 Q를 이용한 방식일 뿐 
> - while 한 바퀴 당 같은 레벨의 노드만 접근하기 때문에 중복 접근하지 않는다.
> - 대신, popleft(), append()연산이 추가되긴 함 

```PYTHON
import sys
from collections import deque
input = sys.stdin.readline

graph = []

def bfs(parents):
  q = deque([1])
  while q:
    popped = q.popleft()
    for v in graph[popped]:
      if parents[v] == 0:
        parents[v] = popped
        q.append(v)  

if __name__ == "__main__":
  N = int(input())
  graph = [[] for _ in range(N+1)]
  for _ in range(N-1):
    u, v = map(int, input().strip().split())
    graph[u].append(v)
    graph[v].append(u)

  parents = [0] * (N + 1)
  parents[1] = 1
  bfs(parents)
  result = parents[2:]
  sys.stdout.write("\n".join(map(str, result)) + "\n")
```

### 성능 비교 (DFS vs BFS)
![Pasted image 20250725005648.png](/img/user/supporter/image/Pasted%20image%2020250725005648.png)
- 같은 레벨만 호출해서 중복 호출을 안하는 BFS가 더 빠를 줄 알았지만 DFS가 더 빨랐다
- 이유는 다음을 생각해 볼 수 있다.
	- Deque 메서드 호출 비용(append(). popleft())

