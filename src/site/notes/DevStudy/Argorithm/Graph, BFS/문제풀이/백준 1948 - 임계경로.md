---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 1948 - 임계경로/","noteIcon":"","created":"2025-12-03T14:52:52.039+09:00","updated":"2025-12-09T17:19:42.555+09:00"}
---


>[!danger] 못 품 - 메모리 초과
>- 알고보니 DP를 배우지 않으면 못 푸는 문제란다
>- 아직 DP를 배우지도 않았는데... 근데 대충 메모이제이션 방법 들어는 봤는데 이거 어케 적용하지??
>- 그래서 조금이나마 DP에 대해서 감좀 잡아보고자 레츠고 

### 문제 링크 및 간단 설명 

[BOJ 1948 - 임계경로](https://www.acmicpc.net/problem/1948)

- 목표 : 시작점부터 도착점까지 가장 비싼 경로를 찾고, 그 경로에 속하는 간선 개수를 세는 것 
- 그런 경로가 여러 개라면 전부 세기 

### GPT 답 
```python
from collections import deque
import sys
input = sys.stdin.readline

# 1) 입력 및 그래프 구성
N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
reverse_graph = [[] for _ in range(N+1)]
in_degree = [0] * (N+1)

for _ in range(M):
    u, v, w = map(int, input().split())
    graph[u].append((v, w))
    reverse_graph[v].append((u, w))
    in_degree[v] += 1

S, E = map(int, input().split())

# 2) 위상 정렬로 순서 구하기
queue = deque()
topo_order = []
for node in range(1, N+1):
    if in_degree[node] == 0:
        queue.append(node)

while queue:
    u = queue.popleft()
    topo_order.append(u)
    for v, _ in graph[u]:
        in_degree[v] -= 1
        if in_degree[v] == 0:
            queue.append(v)

# 3) DP로 최장 경로 계산
dist = [-1] * (N+1)
dist[S] = 0

for u in topo_order:
    if dist[u] == -1:
        continue
        
    for v, w in graph[u]:
		  dist[v] = max(dist[v], dist[u] + w)

# 4) 역방향 BFS로 임계 간선 개수 세기
# ❌이거 이렇게 하면 안되는 듯
visited = [False] * (N+1) # 똑같은 간선 세지 않기 위해 
count = 0
dq = deque([E])
visited[E] = True

while dq:
    curr = dq.popleft()
    for prev, w in reverse_graph[curr]:
        if dist[prev] + w == dist[curr]:
            count += 1
            if not visited[prev]:
                visited[prev] = True
                dq.append(prev)

# 5) 결과 출력
print(dist[E])
print(count)
```

#### 1. 위상 정렬 
![Pasted image 20250731200417.png](/img/user/supporter/image/Pasted%20image%2020250731200417.png)
> **위상 정렬을 써야 되는 이유** 
1. **순서(의존성) 보장** 
	- 위상 정렬은 **순서를 보장 받아야 할 때** 요긴하게 쓰인다. ex. 반드시 A -> B 로 가야만 할 때 그 순서를 보장해준다. 
	- 순서가 보장되지 않으면, 아직 처리되지 않은 노드에서 이어지는 경로를 잘못 반영할 수 있습니다.

2. **순회 횟수 최소화 when 향후 DP 이용 시**
	- 순서가 보장된 경로로 순회한다면 올바른 최장경로 DP 갱신이 가능하다.

#### 2. DP로 최장 경로 계산 

- `dist` 배열 초기화 
- **위상 정렬을 기준으로 순회**하면 한 번의 순회로 모든 최장거리를 올바르게 구할 수 있다.

#### 3. 역추적으로 임계 간선 계수 세기 

>최장 경로에 속하는 간선의 조건 : `dist[u] + w = dist[v]`
- 사전에 만들어 놓은 reverse_graph를 활용해 끝점부터 돌면서 위의 조건을 검증하면 된다.
- 이 조건에 검증된 간선은 임계간선으로 취급 
- 추가 : 중복 집계를 방지하기 위해 방문 체크도 必
`
### 공부하고 다시 푼 답

```python
import sys
from collections import deque
from typing import List
input = sys.stdin.readline

def topological_sort(graph: List[list], indegree: list, start):

  result = []  
  queue = deque([start])
  while queue:
    u = queue.popleft()
    result.append(u)

    for v, _ in graph[u]:
      indegree[v] -= 1
      if indegree[v] == 0:
        queue.append(v)

  return result  

def get_long_dists(graph: List[list], n, topo_list: list, start):
  dist = [float('-inf')] * (n+1)
  # start는 0으로 채워줘
  dist[start] = 0
  for u in topo_list:
    if dist[u] == float('-inf'):
      continue

    for v, w in graph[u]:
      if dist[v] < dist[u] + w:
        dist[v] = dist[u] + w

  return dist

def backtracking(reverse_graph: List[list], dist: list, end):
  '''
  reverse_graph
    - key: 도착, value = (출발, 비용)
  '''
  visited_edges = set()
  queue = deque([end])
  count = 0

  while queue:
    v = queue.popleft()
    for u, w in reverse_graph[v]:
      # 이렇게 짧은건 임계경로가 아니야
      if dist[u] + w < dist[v] or (u,v) in visited_edges:
        continue

      queue.append(u)
      visited_edges.add((u,v))
      count += 1

  return count

if __name__ == "__main__":
  n = int(input())
  m = int(input())

  graph = [[] for _ in range(n+1)]
  reverse_graph = [[] for _ in range(n+1)]
  indegree = [0 for _ in range(n+1)]

  for _ in range(m):
    u, v, w = map(int, input().split())
    graph[u].append((v,w))
    indegree[v] += 1
    reverse_graph[v].append((u, w))

  start, end = map(int, input().split())

  result: list = topological_sort(graph, indegree, start)
  dist: list = get_long_dists(graph, n, result, start)
  count: int = backtracking(reverse_graph, dist, end)

  print(dist[end])
  print(count)
```

**몇 가지 추가**
1. 역추적 코드에서 visited에 간선 정보를 추가 (u, v)
	- 역추적 할 때, 특정 노드에 도착하는 간선 정보를 이미 집계했으면 할 필요가 없다
	- 단순히 `visited[node]`로 하면 그 노드로 오는 모든 노드들을 고려할 수 없으므로 이렇게 간선 가중치까지 고려한 튜플로 만든 것 

### 최종 리뷰 

- 일단 1시간 넘게 답을 분석하고 안보고 답을 적어보긴 했다.
- 최장거리 제대로 구하려고 위상정렬하고... 백트레킹하면서 최장거리를 기반으로 임계경로를 구하기... 라는 **흐름은 이해**했다.
- 근데, 다음에도 이런 유형의 문제를 만나면 **문제를 보자마자 이렇게 설계할 능력은 아직 안되는 것 같다** ㅠㅠ 
- 단순 위상정렬, BFS말고도 DP, 역추적 로직들이 추가가 되다보니 어려웠던 것 같다. 그래도 이번주 푼 문제들 중에 가장 난이도 있는 문제를 푼 것 같아서 뿌듯하다 
