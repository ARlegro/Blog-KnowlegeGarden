---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 1991 - 트리 순회/","noteIcon":"","created":"2025-07-24T20:51:50.724+09:00","updated":"2025-08-01T01:08:45.131+09:00"}
---



이 문제를 풀기 전에 한 시간정도 graph, tree를 공부했다.
그 때는 Node, Tree의 class를 만들어서 구현했던 것 같은데, 이 정답의 모범답안을 보니 

### 문제 링크 

https://www.acmicpc.net/problem/1991


### 모범 답안 

```python
import sys
input = sys.stdin.readline

# 전위 순회 
def preorder(data, result: list):
  if data == '.':
    return

  result.append(str(data))
  preorder(tree[data][0], result)
  preorder(tree[data][1], result)

# 중위 순회 
def inorder(data, result: list):
  if data == '.':
    return

  inorder(tree[data][0], result)
  result.append(data)
  inorder(tree[data][1], result)

# 후위 순회 
def postorder(data, result: list):
  if data == '.':
    return

  postorder(tree[data][0], result)
  postorder(tree[data][1], result)
  result.append(data)

if __name__ == '__main__':
  N = int(input().strip())
  # 트리 생성 - Dict로
  tree = {}
  for _ in range(N):
    parent, left, right = input().strip().split()
    tree[parent] = (left, right)
    
  pre_result = []
  preorder("A", pre_result)
  in_result = []
  inorder("A", in_result)
  post_result = []
  postorder("A", post_result)
  
  sys.stdout.write(''.join(pre_result)+"\n")
  sys.stdout.write(''.join(in_result)+"\n")
  sys.stdout.write(''.join(post_result)+"\n")
```

- Tree 클래스를 따로 만들지 않고 딕셔너리 형태로 만들었다.
	- **key** = 부모 노드
	- **value** = 튜플형태 (왼쪽 노드, 오른쪽 노드)
- 딕셔너리를 사용함으로써 별도의 Node/Tree 클래스 없이도 트리 순회를 깔끔히 처리할 수 있게 했다.
	  
- 
