---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 21606 - 아침 산책/","noteIcon":"","created":"2025-07-27T14:49:20.013+09:00","updated":"2025-08-01T01:12:08.231+09:00"}
---



> 정답❓  73점 中 200점 

### 리뷰 이유 
- 73점 밖에 못 맞아서 
- 도저히 200점 짜리 답을 모르겠어서 


### 문제 링크
[BOJ 21606 - 아침 산책](https://www.acmicpc.net/problem/21606)


### 내가 푼 답 ✅

```PYTHON
import sys
input = sys.stdin.readline

N = int(input()) # 5
indoor_info = [0] #010111
where_info = input().strip() # 10111  (0은 실외, 1은 실내)
for start in where_info:
  indoor_info.append(int(start))

def dfs(root, result: list):
  if visited[root]:
    return

  # 1. 실내(1)일 경우
  if indoor_info[root]:
    result.append(True)
    return
  
  # 2. 실외를 만났을 경우!!!
  visited[root] = True
  for c in graph[root]:  
    dfs(c, result)

visited = [False] * (N + 1)
graph = [[] for _ in range(N+1)]
for _ in range(N-1):
  u, v = map(int, input().split())
  graph[u].append(v)
  graph[v].append(u)

answer = 0
for start in range(1, len(indoor_info)):
  # 첫 시작은 무조건 실외(1)에서
  if indoor_info[start] == 0:
    continue

  # 실외 시작 go ~~
  result = []
  visited[start] = True
  for c in graph[start]:
    dfs(c, result)

  answer += len(result)
  visited = [False] * (N + 1)
  
print(answer)
```

흔한 DFS 방법이다.
근데 이렇게 풀면 73점 밖에 못 받음 

### 200점 짜리 답

#### 아이디어 

**1‍⃣ 실내 - 실내 인접 간선 따로 체크** 
- 실내에서 실외를 거치지 않고 "실내 ➡ 실내" 로 산책 경로를 지정할 수 있다.
- 이럴 때는 **실내끼리 연결된 간선 하나당 2개의 point를 더해주면** 된다.
- **시간 복잡도 = O(N)** : 처음 입력에서 준 간선 정보 개수(N-1)만큼만 순회하면 되기에 


**2‍⃣ 실외 덩어리를 기반으로 계산** 
- 실외 노드끼리 연결된 컴포넌트(덩어리)를 찾는다
- 이 덩어리를 거쳐갈 수 있는 모든 실내의 계수 `T`개를 구한다.
- **"실내 ➡ 실외 컴포넌트 ➡ 실내"** 경로 개수 = `T(T-1)` (순열 공식 참고)


>[!tip] 참고 - 순열 공식 
>- P(n,r)=n!​/(n−r)!
>- 14개 중 2개를 고른다 ➡ 14! / 12! ➡ 14 x 13 = 182 가지 


**❓이렇게 하면 왜 빨라지는가 ❓**
- 첫 FOR문에서 실외인 노드만 들어가면 된다.

#### BFS - 코드 
```python
import sys
from collections import deque
input = sys.stdin.readline
  
N = int(input())
indoor_info = [0]
for i in input().strip():
  indoor_info.append(int(i))

graph = [[] for _ in range(N+1)]
edges = []
for i in range(N-1):
  u, v = map(int, input().split())
  edges.append((u,v))
  graph[u].append(v)
  graph[v].append(u)

answer = 0
# 1. 실내 - 실내 인 경우 ➡ O(N-1)
for u,v in edges:
  if indoor_info[u] == 1 and indoor_info[v] == 1:
    answer += 2

# 2. 실외 컴포넌트 따로
visited = [False] * (N + 1)
for row in range(1, len(graph)):
  # 실내는 Bye
  if indoor_info[row] == 1 or visited[row]:
    continue

  # 방문하지 않았고 실외인 곳
  q = deque() # q에는 실외만 담김
  visited[row] = True
  q.append(row)
  
  neighbor_outdoor = set()
  while q:
    popped = q.popleft()
    for c in graph[popped]:
	    # 실외 가지들이 있으면 추가 
      if indoor_info[c] == 1:
        neighbor_outdoor.add(c)

			# 실내이면서 방문하지 않은 곳 
      elif not visited[c]:
        visited[c] = True
        q.append(c)

  answer += len(neighbor_outdoor) * (len(neighbor_outdoor) -1)
 
print(answer)
```

![Pasted image 20250727160621.png](/img/user/supporter/image/Pasted%20image%2020250727160621.png)

**실외 컴포넌트로 묶고 경로 개수 세기 로직**
1. 실외이고 방문한적 없는거 확인 
2. 특정 실외에 접근 시 인접한 실내 리스트를 set()형태로 만들기 
3. BFS, DFS로 돌면서 인접 실내 추가하기 

> 특정 실외 노드를 돌다가 
> - 인근 실내 노드 발견 시 neighbor_outdoor에 추가 
> - **방문하지 않은 실외만 큐에** 추가 



#### DFS 코드 
```PYTHON
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N = int(input())
indoor_info = [0]
for i in input().strip():
  indoor_info.append(int(i))

graph = [[] for _ in range(N+1)]
edges = [] 
for i in range(N-1):
  u, v = map(int, input().split())
  edges.append((u,v))
  graph[u].append(v)
  graph[v].append(u)

answer = 0
# 1. 실내 - 실내 인 경우 
for u,v in edges:
  if indoor_info[u] == 1 and indoor_info[v] == 1:
    answer += 2 

# 2. 실외 컴포넌트 따로 
visited = [False] * (N + 1)

def dfs(start: int, result: set):
  # 실내는 굿바이 
  if indoor_info[start] or visited[start]:
    return
  
  visited[start] = True
  # start = 실외
  for c in graph[start]:
    # 가지가 실외일 경우 : 더 달려 (그 전에 방문 처리 必)
    if indoor_info[c] == 0:
      dfs(c, result)
    # 가지가 실내일 경우
    elif indoor_info[c] == 1:
      result.add(c)

for row in range(1, len(graph)):
  # 실내는 Bye
  if indoor_info[row] == 1 or visited[row]:
    continue
  
  # 방문하지 않았고 실외인 곳 
  neighbor_outdoor = set()
  dfs(row, neighbor_outdoor)
  answer += len(neighbor_outdoor) * (len(neighbor_outdoor) -1)

print(answer)
```