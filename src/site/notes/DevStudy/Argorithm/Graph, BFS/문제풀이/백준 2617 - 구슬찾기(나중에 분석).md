---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 2617 - 구슬찾기(나중에 분석)/","noteIcon":"","created":"2025-07-29T16:20:10.934+09:00","updated":"2025-08-01T01:11:31.779+09:00"}
---





>[!success]

### 리뷰 이유 
- 나보다 2배 빠른 사람이 있길래 코드 염탐해봤더니 되게 깔끔하게 처리했길래 분석하고 내 더러운 코드에 대해 반성좀 하려고 

### 내 코드 

```python
import sys
from typing import List
from collections import defaultdict
input = sys.stdin.readline
'''
무게가 중앙값인 구슬을 찾기 위해
양팔저울로 2개의 구슬 크기를 비교
목표 : 중간 구슬이 될 수 없는 구슬의 개수 구하기
'''
'''Think
중간값 판단 여부
1. 자신보다 작은게 없거나 큰게 없다면 중간값 퇴출
2. 자신보다 작은 or 큰 것이 너무 많을 때
  - 전체 3개 중 2개가
  - 전체 5개 중 3개가 자신보다 작다면 => 불가
  - 전체 7개 중 4개가 자신보다 작다면 => 불가
  - 공식 : 전체(N)/2 + 1 이 기준
'''
bigger_info = []
smaller_info = []
visited = []
def bigger_dfs(start, result: set):
  for bigger in bigger_info[start]:
    # 이미 센거면 넘어가고
    if visited[bigger]:
      continue

    result.add(bigger)
    visited[bigger] = True
    bigger_dfs(bigger, result)

def smaller_dfs(start, result: set):
  for smaller in smaller_info[start]:
    if visited[smaller]:
      continue

    result.add(smaller)
    visited[smaller] = True
    smaller_dfs(smaller, result)

if __name__ == "__main__":
  N, M = map(int, input().split())
  # key = 기준 값, value = 기준 값보다 큰 값
  bigger_info = defaultdict(list)
  # key = 기준 값, value = 기준 값보다 작은 값
  smaller_info = defaultdict(list)

  for _ in range(M):
    big, small = map(int, input().split())
    bigger_info[small].append(big)  
    smaller_info[big].append(small)

  answer = []
  for i in range(1, N+1):
    visited = [False] * (N + 1)
    bigger_result = set()
    bigger_dfs(i, bigger_result)

    if len(bigger_result) > (N/2):
      answer.append(i)
      continue

    visited = [False] * (N + 1)
    smaller_result = set()
    smaller_dfs(i, smaller_result)

    if len(smaller_result) > (N/2):
      answer.append(i)

  print(len(answer))
```

아쉬운 점 
- smaller vs bigger dfs함수를 굳이 나눌 필요가 없었다.
- 거의 로직은 똑같음. 


### 그 사람 코드 

```python
import sys

N,M= map(int,input().split())

heavy= [[]for _ in range(N+1)]
light= [[]for _ in range(N+1)]

for _ in range(M):
    h,l= map(int,input().split())
    heavy[h].append(l)
    light[l].append(h)

def dfs(li,cur):
    cnt=0

    for next in li[cur]:
        if not visited[next]:
            visited[next]=True
            cnt+=1
            cnt+=dfs(li,next)
    return cnt
    
    
mid = (N+1)/2
result = 0

for i in range(1,N+1):
    visited=[False] *(N+1)
    if dfs(heavy,i) >= mid:
        result+=1
    if dfs(light,i) >= mid:
        result+=1

print(result)
```
- count같은 int형으로 반환하는 것보다 result 배열로 반환하는게 익숙해서 생각치 않고 있었는데 저렇게 반환하면 깔끔하고 메모리도 덜 먹게 할 수 있었다는 걸 깨달음 (**count 반환 패턴 기억하기!!!**)
- **이 사람 코드 단점**
	- 이미 첫 if 문 dfs에서 결과가 나왔으면 다음 dfs는 건너 뛰어도 되는데 저걸 추가해서 괜히 성능 저하 
	- 