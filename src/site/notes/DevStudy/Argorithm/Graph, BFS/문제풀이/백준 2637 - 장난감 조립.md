---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 2637 - 장난감 조립/","noteIcon":"","created":"2025-12-03T14:52:52.062+09:00","updated":"2025-12-09T17:19:42.603+09:00"}
---



>[!danger] 시간 초과 발생 
>- 이 문제를 단순히 DFS/BFS/위상정렬로 푼다면 시간초과가 발생한다.
>- 3시간 풀고 답이 없어서 답지를 보니 DP??라는 것을 쓰더라
>- 아직 내가 배우지 않은 내용이라 살짝 맛보기로 공부하고 싶어서 리뷰 


### 문제 링크 

[BOJ 2637 - 장난감 조립](https://www.acmicpc.net/problem/2637)

> 다양한 부품들이 계층적으로 연결되어 있고 완제품을 만드는 구조

![Pasted image 20250730144233.png](/img/user/supporter/image/Pasted%20image%2020250730144233.png)
### 내가 푼 답 
 
#### 코드 

```python
import sys
from collections import defaultdict, deque
input = sys.stdin.readline 



'''문제 요약 
부품은 3가지 : 기본 - 중간  => 완제품 

위상 정렬 써야 하는 이유 
순서가 정해지지 않으면 중간제품의 필요 부품들을 dfs/bfs로 탐색할 때
기본부품을 파악하기 힘들다
'''

# key = 완/중간 제품, value = (필요부품, 개수)
need_components = defaultdict(list) 
sub_components_count = defaultdict(int)

def dfs(parent_part, now_part, before_count): # 2 
  global sub_components_count
  if not need_components[now_part]:
    sub_components_count[now_part] += before_count
    return 
  
  for subpart, count in need_components[now_part]:
    dfs(parent_part, subpart, count * before_count)

def tolo_sort(graph: dict[list], num_vertices: int) -> list:

  # 정렬 담을 거 세팅 
  indegree = [0]*(num_vertices + 1)
  indegree[0] = -1

  for subpart in graph:
    # subpart_count = parent_part만드는 데 피룡한 subpart 개수 
    for parent_part, subpart_count in graph[subpart]:
      indegree[parent_part] += subpart_count

  # 큐에 담기 : 단순히 노드만 담는게 아님 (노드에 필요한 것들도 담아야 하는데)
  queue = deque()
  for i in range(1, num_vertices + 1):
    if indegree[i] == 0:
      queue.append(i)

  while queue:
    subpart = queue.popleft()
    
    # 인근 노드 진입차수 낮추고 0이면 q에 push 
    for parent_part, subpart_count in graph[subpart]:
      # 진입차수 낮추기 
      indegree[parent_part] -= subpart_count

      # 필요 부품 목록에 추가하기 - (필요부품, 개수)
      need_components[parent_part].append((subpart, subpart_count))

      if indegree[parent_part] == 0:
        queue.append(parent_part)
  
  dfs(N, N, 1)
  for key in sorted(sub_components_count):
    print(key, end=" ")
    print(sub_components_count[key])

if __name__ == '__main__':
  N = int(input())
  M = int(input())

  # graph = [[] for _ in range(N+1)]
  # key : 출발 노드, value = (도착노드, 비용)
  graph = defaultdict(list)
  for i in range(M):
    X, Y, K = map(int, input().split())
    graph[Y].append((X, K))

  answer: list = tolo_sort(graph, N)
```

#### 시간 초과 이유 

- DFS/위상 정렬만으로 풀 경우, 특정 중간 부품을 만들 때 필요한 기본 부품의 개수를 계산하기 위해 **매번 깊이 탐색을 다시 해야 하므로 시간 복잡도가 증가**한다.
- 즉, **이미 계산한 결과를 다시 계산**하기 때문에 **비효율성**이 발생하는 것 

### GPT 답 

>[!Example] 제시 : 2차원 배열의 DP를 만든다.
>- `dp[i][j]` 의미 : 부품 i를 만드는 데 필요한 기본 부품 j의 개수 
>- **기본 부품은 1로 세팅** `dp[i][i]`
>	- 어떻게 구분❓ 초기 Indegree가 0인게 기본 부품 
>- `i`노드에 필요한 부품들을 계산하기 위해 **`dp[i]`를 갱신하려면 진입차수가 0이 전제**가 되어야 한다.
>- 따라서, 진입차수가 높은 노드가 먼저 채워진다는 걱정을 할 필요가 없다.

```python
import sys
from collections import defaultdict, deque
input = sys.stdin.readline

def topolo_sort(graph: dict[list], indegree:list, N:int) -> list:
  dp = [[0]*(N+1) for _ in range(N+1)]
  queue = deque()

  # dp - 기본 부품 초기화(기본부품만)
  for i in range(1, N+1):
    if indegree[i] == 0:
      dp[i][i] = 1
      queue.append(i)

  while queue:
    cur_node = queue.popleft()
    for next_node, cnt in graph[cur_node]:
      # cur_node 행에 적힌 dp를 next_node행에 *cnt하기
      for i in range(1, N+1):
        dp[next_node][i] += dp[cur_node][i] * cnt

      indegree[next_node] -= 1
      if indegree[next_node] == 0:
        queue.append(next_node)

  return dp  

if __name__ == '__main__':
  N = int(input())
  M = int(input())

	
  graph = defaultdict(list)
  indegree = [0] * (N+1)
  # GRAPH, INDEGREE 세팅 
  for _ in range(M):
    X, Y, K = map(int, input().split())
    graph[Y].append((X,K))
    indegree[X] += 1

	# dp[i][j] = i부품 만드는 데 필요한 j부품 수 
  dp = topolo_sort(graph, indegree, N)
  
  for i in range(1, N+1) :
    if dp[N][i] > 0:
      print(f'{i} {dp[N][i]}')
```
![Pasted image 20250730144233.png](/img/user/supporter/image/Pasted%20image%2020250730144233.png)
#### 1. DP초기화 - 2차원 배열 
```PYTHON
dp = [[0]*(N+1) for _ in range(N+1)]

for i in range(1, N+1):
    if indegree[i] == 0: # 진입차수가 0이면 기본 부품
        dp[i][i] = 1     # i번 부품을 만드는 데 i번 기본 부품이 1개 필요하다
        queue.append(i)  # 위상 정렬을 위해 큐에 추가
```
![Pasted image 20250730144340.png](/img/user/supporter/image/Pasted%20image%2020250730144340.png)
- 2차원 배열(dp)의 의미 : `dp[i][j]`는 i를 만들 때 필요한 기본 부품 j의 개수
- DP 테이블 **초기화할 때는 기본 부품에 해당하는 부분만** 채운다. (이후 이거를 기반으로 다른 부품의 기본 부품 수를 갱신)
	- **기본 부품 판단 기준 = 초기 진입차수가 0**  (1, 2, 3, 4)
	- `dp[i][i] = 1` : i번 기본 부품을 만드는 데 1개의 i 가 필요하다는 당연한 걸 갱신신
#### 2. 위상 정렬을 통한 DP테이블 갱신 
```PYTHON
while queue:
    cur_node = queue.popleft() # 현재 처리할 부품 ex. 1번 부품
    
    # cur_node가 필요한 다음 부품들(next_node)과 그 개수(cnt)를 순회
    for next_node, cnt in graph[cur_node]:
        # cur_node를 만드는 데 필요한 각 기본 부품의 개수를 next_node에 반영
        for i in range(1, N+1): 
            dp[next_node][i] += dp[cur_node][i] * cnt 
            
        indegree[next_node] -= 1 # 다음 부품의 진입 차수 감소
        if indegree[next_node] == 0: # 진입 차수가 0이 되면 큐에 추가
            queue.append(next_node)
```
![Pasted image 20250730144619.png](/img/user/supporter/image/Pasted%20image%2020250730144619.png)
![Pasted image 20250730144939.png](/img/user/supporter/image/Pasted%20image%2020250730144939.png)
- 초기 Queue에는 진입차수가 0인 1 ~ 4번 노드가 들어가 있을 것이고 이번에 1번 노드를 꺼냈다고 가정해보겠다.
- 1번 노드를 꺼내고 `graph[1]`을 하면 1과 인접한 노드(next)와 그 인접 노드를 가기 위해 1번 노드가 얼마나 필요한지(cnt)를 튜플 형태로 반환 받는다.
- **이 과정에서 중요한 것 = DP 테이블 갱신**
	- 1번 노드에 적힌 기본 부품 배열들 `dp[1]`을 cnt 배 해서 `dp[next]`를 갱신한다.
	- 이렇게 되면, **next 부품을 만드는 데 필요한 모든 기본 부품의 개수가 `dp[5][j]`에 누적**된다.
	- **위상 정렬의 효과**
		- 위상 정렬 순서에 따라 DP가 갱신되므로 **항상 하위 부품(진입차수가 먼저 0이 되는)의 dp값이 먼저 갱신**된다. (하위 부품 ➡ 상위 부품)
		- 향후 상위 부품(중간 or 완제품)이 특정 중간 부품을 참조하고 기본 부품들을 계산해야 할 때 이미 dp에 갱신되어 있으므로 **더 깊이 탐색할 필요 없이 바로 조회하고 사용할 수 있다.**


### 후기 

- DP는 다음 주 키워드에 있는 내용이라 잘 몰랐었다.
- 그런데 DP 사용 유무에 따라 속도가 크게 달라진다는 것을 느낄 수 잇는 좋은 문제였던 것 같다.
- 아직 DP를 사용하는 데 익숙하지 않지만 다음 주 되면 익숙해질 테니 일단 참고만 하고 있겠다.