---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Graph, BFS/문제풀이/백준 2665 - 미로 만들기/","noteIcon":"","created":"2025-12-03T14:52:52.084+09:00","updated":"2025-12-09T17:19:42.613+09:00"}
---




>[!danger]  못 품 ㅠㅠ 

### 초기 생각 
![Pasted image 20250728134651.png](/img/user/supporter/image/Pasted%20image%2020250728134651.png)
#### 1. 하얀색 덩어리들의 최소거리 - 다익스트라 활용 ❓
- 하얀 덩어리를 하나의 노드라고 생각하고 각 덩어리 마다 최소 거리를 다익스트라로 풀어서 어찌저찌 해야 하나?? 라는 생각을 했는데
- 어떻게 하나의 노드로 묶고 어떻게 최소 거리를 구하지?? 라는 고민을 오래 하다가 **이 방법은 포기**

#### 2. 벽을 뚫을 때마다 카운팅 
- 어찌보면 정답 접근이랑 같은데, 막상 이를 생각할 때는 여러가지 고민이 들었다
- 우선, 어디 벽을 골라야하지? 벽은 골랐는데 벽이 또 있으면?? 
- 그 다음에는, 이렇게 되면 너무 오래 걸리지 않나?? 하면서 구현 전에 멘붕이 왔고 결국 2시간 고민 끝에 답을 보기로 했다.

### 답지 확인 

비용이 들지 않는 흰방(0)을 최대한 탐색한다.
#### 아이디어 

#다익스트라처럼 
> 비용이 적은 경로부터 탐색 ➡ Heapq 활용 
1. **최소 비용 큐 로직 구현 by 최소힙**
	- 각 칸까지 도달하는 최소 비용을 우선순위 큐에 저장한다.
	- 우선순위 큐에는 (비용, 위치)로 담겨있다.
	- 최소 힙으로 구성된 큐는 **가장 비용이 낮은 칸부터 탐색**하도록 됨 ➡ 최소 비용으로 도달할 수 있는 위치들부터 방문 
	  
2. **최단 거리 배열 활용**
	- 더 적은 비용으로 방문하는 경우에만 갱신하고 큐에 push 
	  

> 꽉 막힌 흰방을 끝까지 갔다해서 재귀 호출 이런 개념으로 비용 생각하면 안된다. 어차피 큐에는 특정 방(row, col)에 도달하는 비용을 바로 담았기 때문에 그 위치까지 다시 가는데 O(1)이면 됨. 


#### 답지 보고 아이디어 얻고 만든 코드 
> 아이디어를 기반으로 만들면 아래처럼 된다
```PYTHON
import sys
from heapq import heappop, heappush
input = sys.stdin.readline

N = int(input())
graph = [[0]*(N) for _ in range(N)]        


for i in range(N):
  line = input().strip()
  for j in range(N):
    graph[i][j] = int(line[j])

# up, down, left, right
direction_move = [(-1, 0),(1, 0), (0, -1),(0, 1)]  # (row움직임, col움직임)

def solve():
  # 시작점부터 Let's go
  queue = []
  INF = float('inf')
  cost_list = [[INF]*N for _ in range(N)]
  # cost, row, col
  start = (0,0)
  queue.append((0, start[0], start[1]))

  while queue:
    cost, row, col = heappop(queue)
    for m in direction_move:
      to_move_row = row + m[0]
      to_move_col = col + m[1]
      # 움직일 곳이 범위 넘어갈 경우
      if not (0 <= to_move_row < N) or not (0 <= to_move_col < N):
        continue

      # 찾았따
      if to_move_row == N-1 and to_move_col == N-1:
        print(cost)
        return

      # 더 싼 경로가 있을 경우에는 pass
      if cost_list[to_move_row][to_move_col] <= cost:
        continue

      # 이 위치까지 오는데 비용 (아직 비용 청구 전 - 비용 청구는 다음에 더 갈 때)
      cost_list[to_move_row][to_move_col] = cost
      if graph[to_move_row][to_move_col] == 1:
        heappush(queue, (cost, to_move_row, to_move_col))
      else:
        # 비용 들음
        heappush(queue, (cost+1, to_move_row, to_move_col))

if __name__ == '__main__':
  solve()
```

- Heapq를 통해 우선순위가 낮은 포지션들을 최대한 늦게 pop하는 것이 key point 였다.
- 사실 이 부분만 이해하면 이 문제는 딱히 설명할게 없긴 하다