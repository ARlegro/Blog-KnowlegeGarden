---
{"dg-publish":true,"permalink":"/DevStudy/Argorithm/Tree/파이썬 코테 트리 기본 구조/","noteIcon":"","created":"2025-12-06T12:52:04.041+09:00","updated":"2025-12-06T13:23:26.173+09:00"}
---


오랜만에(3달만인가?) 알고리즘을 불어보려고 백준 1991 트리 순회 문제를 풀어보려고하는데 파이썬으로 어떻게 트리를 만들었더라? 혼란이 왔다.

일단 Tree클래스랑 Node 클래스 만들어서 하면되는건가?하다가 이렇게 코테를 복잡하게 했던 기억이 없는데? 생각이 들어 파이썬에서 트리 문제를 풀 때 표준 구조를 알아보게 되었다.


## 1.  파이썬 코트 트리 구축 표준 패턴
```python
tree = {}

def build_tree(N: int) -> dict:
    global tree
    for _ in range(N):
        parent, left, right = input().split()
        tree[parent] = (left, right)
  
    return tree
```
- `tree[parent] = (left, right)` 형태로 모두 저장한다.
- parent = 현재 노드
- left, right : 왼쪽/오른쪽 자식
- 장점
	- 실제 포인터나 객체를 만드는 것이 아니라, **노드 이름들만 관계로 연결하는 구조**라 구현이 단순하고 빠르다


## 2.  실전 예시 - 전위, 중위, 후위
[백준 사이트](https://www.acmicpc.net/problem/1991)
[[DevStudy/Argorithm/Graph, BFS/문제풀이/백준 1991 - 트리 순회\|백준 1991 - 트리 순회]]

그냥 전위, 중위, 후위 순회를 어떻게 할 거냐 이런 건데 tree만드는 법만 알면 그닥 어렵지 않다.
물론 너무 오랜만에 해서 dfs를 어케 구현했더라? 이런 고민이 들긴 했다 ㅎ 

### 2.1.  코드 
```python
import sys

input = sys.stdin.readline
write = sys.stdout.write

tree = {}


def build_tree(N: int) -> dict:
    global tree
    for _ in range(N):
        parent, left, right = input().split()
        tree[parent] = (left, right)

    return tree


def in_order(word: str, result: list):
    global tree
    left = tree[word][0]
    right = tree[word][1]
    if left != ".":
        in_order(left, result)

    result.append(word)

    if right != ".":
        in_order(right, result)


def pre_order(word: str, result: list):

    result.append(word)
    left = tree[word][0]
    right = tree[word][1]
    if left != ".":
        pre_order(left, result)

    if right != ".":
        pre_order(right, result)


def post_order(word: str, result: list):

    left = tree[word][0]
    right = tree[word][1]
    if left != ".":
        post_order(left, result)

    if right != ".":
        post_order(right, result)

    result.append(word)


if __name__ == "__main__":
    N = int(input())
    tree = build_tree(N)
    result = []
    root = "A"
    pre_order(root, result)
    write("".join(map(str, result)) + "\n")
    result.clear()
    in_order(root, result)
    write("".join(map(str, result)) + "\n")
    result.clear()
    post_order(root, result)
    write("".join(map(str, result)) + "\n")
```

### 2.2.  시간 복잡도 
1. *트리 구축 비용 - O(N)*
	- N개의 줄을 읽으므로 O(N)
	  
2. *각 순회 - O(N)*
	- 각 노드를 한 번씩만 방문하므로 O(N)



