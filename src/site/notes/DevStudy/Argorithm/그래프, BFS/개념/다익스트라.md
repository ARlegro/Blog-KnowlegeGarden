---
{"dg-publish":true,"permalink":"/dev-study/argorithm/bfs///","noteIcon":"","created":"2025-07-27T23:18:28.348+09:00","updated":"2025-08-01T00:10:55.313+09:00"}
---



> 다른 최단 경로 탐색 알고리즘 = [[DevStudy/Argorithm/그래프, BFS/개념/플로이드 와샬\|플로이드 와샬]]  (이건 모든 쌍)

## 개념 및 특징 

### 1. 개념 
#최단경로탐색   #DP  #Greedy
![Pasted image 20250729190757.png](/img/user/supporter/image/Pasted%20image%2020250729190757.png)
- **특정 노드에서 다른 모든 노드까지의** **최단 거리를 구하는** 탐욕적 알고리즘
- 주로, **DP를 활용**하여 최단 경로를 탐색. 또한, 가장 가까운 노드부터 차례대로 최단 거리를 확장해 나가는 **Greedy 방식**을 사용  
	- **DP 활용** : distance 배열 활용하여 현재까지 발견된 최단 거리를 저장하고 갱신
	- **Greedy 방식** : heapq모듈을 활용하여 최소 거리의 요소를 먼저 `pop()`하여 처리. 
- **시간 복잡도** = $E*logV$
	- 간선 수만큼 heap push/pop 연산 必

> 최소 거리에서 최소 거리를 붙여가며 최종적으로 최단거리를 계산 


---
### 2. 특징 

- **양의 간선만 허용** 
	- ❌음의 간선이 존재하는 경우에는 사용 불가 (음의 간선만 아니면 됨 ) ❓❓
		- Greedy 방식이라 모든 경우의 수를 비교하지 않음 unlike '플로이드 와샬'
	- 음의 간선이 존재할 경우 다른 알고리즘을 써야 함 

- **이전 정보 재활용**
	- 하나의 노드까지의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다
	  
- **최단 거리가 여러 개일 수** 있다.

---
### 3. 활용 사례

| 분야           | 설명                                    |
| ------------ | ------------------------------------- |
| **인공위성**     | 인공위성 간의 **데이터 통신 경로** 최적화             |
| **GPS**      | 현재 위치에서 목적지까지의 **최단경로** 계산            |
| **네트워크 라우팅** | 패킷 전송 시 **최적의 경로를 찾아주는** 라우팅 프로토콜에 사용 |

---


## 예시 흐름
> 1) 현재까지 알려진 최단 거리가 가장 짧은 노드를 선택하여 방문하고,
> 2) 해당 노드를 경유했을 때 다른 노드들의 최단 거리가 갱신되는지 확인하는 과정을 반복 


### 아이디어 

>[!tip] 가장 가까운 노드부터 확정!(by heapq) ➡ 거리 검증 ➡ 인접 노드 갱신 ➡ 가까운 요소 pop() ➡거리검증 (무한 루프 until q is empty)
>- 모든 경로를 다 비교하지 않고, 현재 최적의 선택만 해가며 문제를 해결해 가는 것 

1. **초기 설정** 
	- distances 배열 설정 (무한대) - 각 노드까지 가는 거리 
2. **우선순위 큐 초기화**
	- (거리, 노드)형태의 튜플로 구성된 우선순위 큐에 (0, 시작노드)를 삽입 
3. **최단 거리 검증 및 갱신 반복**
	- 가장 가까운 노드를 선택(by heapq)하고 
	- **거리를 검증**한다. 
		- 만약 `current_distance`가 이미 `distances[current_node]`에 저장된 값보다 크다면(**더 짧은 경로가 발견된 상황**) pop에서 꺼낸 해당 노드로 가는 경로를 무시 (예시는 뒤에서 나옴)
		- 가장 작은 `current_distance`를 가진 노드가 큐에서 `pop`되면, `distances[current_node]`는 그 시점에서 확정된 최단 거리 (그 시점 ➡ 현재 큐 정보)
		  
	- **인접 노드 거리를 갱신** 
		- pop한 노드와 연결된 노드를 순회하는데,
		- 그 노드까지의 거리를 현재 노드의 거리에 더한 뒤(`distance = current_distance + weight`) distance배열과 비교 
		- 만약 새로 계산된 distance가 현재 저장된 distance보다 짧다면 새로 갱신하고 갱신한 (distance, neighbor_node)를 큐에 push 
	- 이 과정을 q가 빌 때까지 반복 

>[!QUESTION] 도대체 Q만 계속 쌓이고 언제 끝나는가???
>- 초기에는 distance[ ] 가 제대로 채워져 있지 않아서 그렇게 느낄 것 
>- 시간이 지날수록 실제 최소 경로 거리에 근접한 값으로 `distance[]`가 채워질 것 
>- 만약 그렇다면 while 문에 있는 2가지 if 문에서 필터링 돼서 q에 추가 요소가 반영되지 않을 것 
>- 그러면 q가 빔



--- 
### 코드 

```python
import heapq
def dijkstar(n, graph: dict, start):
  INF = float('inf')
  distances = [INF] * (n+1)
  distances[start] = 0

  # (거리, 노드)
  priority_queue = [(0, start)]
  while priority_queue:
    # 가장 가까운 노드 선택
    current_distance, current_node = heapq.heappop(priority_queue)

    # 이미 처리된 or 너무 긴 거리라면 무시
    if current_distance > distances[current_node]:
      continue

    # 이웃한 노드들의 정보를 토대로 distance를 갱신 및 heapq에 push
    for neighbor, weight in graph[current_node].items():
      distance = current_distance + weight
      if distances[neighbor] > distance:
        distances[neighbor] = distance # 갱신
        heapq.heappush(priority_queue, (distance, neighbor))
```

#### 1. 초기 세팅 
- 각 노드까지의 최소 경로 거리를 담을 distances 배열을 생성 
- 시작 노드의 거리 = 0  `distacnes[start] = 0`
- 시작 노드를 큐에 담금 
- while문 시작하며 pop하고 조건에 맞을 경우 distance갱신하고 q에 추가 
![Pasted image 20250728104036.png](/img/user/supporter/image/Pasted%20image%2020250728104036.png)


#### 2. While문 시작 - pop() 후 거리 검증 
![Pasted image 20250728104226.png](/img/user/supporter/image/Pasted%20image%2020250728104226.png)


>**너무 긴 거리의 노드를 무시하는 이유**
- A ➡ C ➡ B의 거리를 측정해서 `distance[B]`를 7로 해놨을 때
- A ➡ B로 가는 로직을 보면 (10, "B")가 된다.
- 이 때 단순히 B로 바로 가는 것보다 C로 경유해서 가는 것이 더 효과적
	- 이후 B ➡ D로 갈 때는 무조건 C를 경유해서 갈 것 
- 따라서, B로 바로 가는 경우는 그냥 continue해서 다음 pop()

#### 3. 이웃 순회 - 거리 검증/갱신/heap 추가 
![Pasted image 20250728104417.png](/img/user/supporter/image/Pasted%20image%2020250728104417.png)

> 이웃한 B, C까지의 경로를 아래의 2개를 순회한다
1. 현재노드의 거리(current_dis) 와 weight(현재 노드로부터 그 노드까지 가는 거리)를 더한다
2. 1번 값과 현재 distances 배열의 값과 비교를 해서 갱신할지 판단 
	- 1번 값이  기존 `distance[?]`보다 작아야 heapq갱신
	- 이거는 2번에서 긴거리 무시하는 이유와 같음

---
### 구체적 예시 - 그림 (정리)

![Pasted image 20250728104627.png](/img/user/supporter/image/Pasted%20image%2020250728104627.png)
![Pasted image 20250728104636.png](/img/user/supporter/image/Pasted%20image%2020250728104636.png)


![Pasted image 20250728104648.png](/img/user/supporter/image/Pasted%20image%2020250728104648.png)![Pasted image 20250728104657.png](/img/user/supporter/image/Pasted%20image%2020250728104657.png)

![Pasted image 20250728104710.png](/img/user/supporter/image/Pasted%20image%2020250728104710.png)

>[!QUESTION] 도대체 Q만 계속 쌓이고 언제 끝나는가???
>- 현재는 distance[ ] 가 제대로 채워져 있지 않아서 그랬던 것 
>- 시간이 지날수록 실제 최소 경로 거리에 근접한 값으로 `distance[]`가 채워질 것 
>- 만약 그렇다면 while 문에 있는 2가지 if 문에서 필터링 돼서 q에 추가 요소가 반영되지 않을 것 

> 아래의 조건들로 필터링 걸릴 것 

![Pasted image 20250728104913.png](/img/user/supporter/image/Pasted%20image%2020250728104913.png)
![Pasted Image 20250728103432_426.png](/img/user/supporter/image/Pasted%20Image%2020250728103432_426.png)3333