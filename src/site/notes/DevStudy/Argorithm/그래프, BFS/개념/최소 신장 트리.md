---
{"dg-publish":true,"permalink":"/dev-study/argorithm/bfs///","noteIcon":"","created":"2025-07-25T11:45:25.153+09:00","updated":"2025-08-01T00:11:45.903+09:00"}
---



#크루스칼  #프림 

### 개념 
![Pasted image 20250725152137.png](/img/user/supporter/image/Pasted%20image%2020250725152137.png)
- **최소 비용으로 그래프의 모든 정점을 연결**하는 트리 
- 예를 들어, 기지국을 설치할 때 최소 비용으로 모든 정점들을 연결하고 싶을 때 
- **종류**
	- 크루스칼 알고리즘
	- 프림 알고리즘 

--- 
### 종류1. 크루스칼 알고리즘 

> [!INFO] 선행 학습 : [[DevStudy/Argorithm/그래프, BFS/개념/합집합 찾기 알고리즘 - Union Find (+ Rank 기반)\|합집합 찾기 알고리즘 - Union Find (+ Rank 기반)]] Cuz 사이클 발생여부 확인 

#### 개념 
- **목표** : 모든 정점을 **최소 비용으로 연결**하되 **사이클이 없는 트리 구조를 만드는 것** 
- **동작 방식** 
	1. 모든 간선을 가중치 기준으로 오름차순 정렬
	2. 가중치가 작은(비용이 적은) 간선부터 차근차근 그래프에 포함시키기
	3. 포함 시키기 전에 사이클 테이블을 확인
		- 사이클이 형성될 경우 해당 간선을 추가하지 않는다 ⭐⭐
	4. 간선의 수가 V-1개가 되면 종료 
	   
- **시간 복잡도** = $O (E log E)$  *E = 간선 수*
	- 간선 수가 많으면 느릴 수 있음 
- **간선 수** = E - 1 


---
#### 구현 

![Pasted image 20250725144502.png](/img/user/supporter/image/Pasted%20image%2020250725144502.png)
1. **기본 베이스 코드 - Union-Find 알고리즘 [[DevStudy/Argorithm/그래프, BFS/개념/합집합 찾기 알고리즘 - Union Find (+ Rank 기반)\|합집합 찾기 알고리즘 - Union Find (+ Rank 기반)]]**
	- `getParent()` - 부모 찾는 메서드 
	- `union()` - 간선 연결하는 메서드 (부모가 같으면 연결 실패)
	  
2. **튜플로 `(노드1, 노드2, 중요도)` 를 묶어서 보관한다** 

```python
import sys
# Union-find 알고리즘의 코드 
def findParent(parents: list, x):
  if parents[x] != x:
    parents[x] = findParent(parents, parents[x])
  return parents[x]

def union(parents, a, b):
  a = findParent(parents, a)
  b = findParent(parents, b)
  if a == b:
    return False
  elif a < b:
    parents[b] = a
  else:
    parents[a] = b
  return True

def kruskal(V, edges: list):
  parents = [i for i in range(V+1)]
  edges.sort()
  mst_weight = 0
  mst_edges = []
  for w, u, v in edges:
    if union(parents, u, v):
      mst_weight += w
      mst_edges.append((w, u, v))
      # 크루스칼의 Edge = v - 1
      if len(mst_edges) == V -1:
        break

  return mst_weight, mst_edges

if __name__ == '__main__':
  v, E = map(int, input().split())
  edges = [tuple(map(int, input().split()[::-1])) for _ in range(E)]
  weight, edges = kruskal(v, edges)
  print(weight)
  print(*edges)

4 5
1 2 1 #입력 (노드1, 노드2, 중요도)
1 3 4
2 3 2
2 4 7
3 4 3
6
(1, 2, 1) (2, 3, 2) (3, 4, 3)
# 출력 (중요도, 노드1, 노드2)
```

같은 부모를 가지면 안됨
