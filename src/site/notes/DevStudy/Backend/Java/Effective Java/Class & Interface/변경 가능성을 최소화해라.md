---
{"dg-publish":true,"permalink":"/DevStudy/Backend/Java/Effective Java/Class & Interface/변경 가능성을 최소화해라/","noteIcon":"","created":"2025-12-03T14:52:49.144+09:00","updated":"2025-12-13T10:41:46.200+09:00"}
---



> 변경 가능성을 최소화해라 

>[!tip] 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

### 0.1.  불변 클래스의 장점 

- **설계, 구현, 사용이 쉽다.**
- **재사용성 증가** : 안심하고 공유할 수 있기 때문
- **예측이 쉬워**져 오류가 생길 여지도 적고 **안전**한다.
	- Thread-Safe하므로 동기화 걱정도 없다.


### 0.2.  불변 클래스 5가지 규칙 

1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다
2. 클래스를 확장할 수 없도록 한다
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
	- 특히 final로 설정된 참조 필드는 변경이 가능하기 때문에 이의 접근 자체를 막아야 한다.


### 0.3.  static final 로 설계를 고려해라 

단순히 String, int같은 값들을 static final처리하는 것이 아니라 객체 자체도 static final로 처리해서 재활용할 수 있다. (**전제 : 불변 객체** 💢)

```java
// String + Int
public static final String STRING_VALUE = "test";
public static final String INT_VALUE = 1234;

// 객체로 (💢 전제 : 불변 객체 )
public static final ANIMAL DOG = new DOG(10);
```
**✅정적 팩토리 방법 장점**
1. **메모리 사용량과 GC 비용이 줄어든다.**
	- 여러 클라이언트가 하나의 인스턴스를 공유 
2. **방어적 복사도 필요 없어진다.** 
	- 원본이 불변이니 복사 해봤자임 
3. **캐시 기능 추가도 쉬워진다.** 
4. **내부 데이터 공유**를 마음껏 해도 된다.

**💢정적 팩토리 방법 단점 in 불변 객체** 
- 값이 여러 개라면 여러 독립적 객체를 만들어 놔야 한다.
	- 수정할 필요가 있어서 원하는 객체를 완성하기까지 여러 객체를 만들어야 될 수 있다.
	- 이 과정에서 필요없는 객체들도 있을텐데 성능 문제가 더 불거진다.
	- 만약 변경이 됐다면 내부를 수정했겠지 


### 0.4.  상속을 못하게 하기 for 불변 객체 

>[!QUESTION] 불변 클래스 설계를 위해 상속을 막아야 하는 이유 
>크게 3가지 이유가 있는데 결론은 하위 클래스가 불변성을 깨뜨릴 수 있기 때문이다.
>1. **부모 필드가 불변이여도 자식 필드가 불변인 것은 아니다**
>2. **목적이 맞지 않는다**
>	- 상속 : 행위를 확장 or 변경하는 목적
>	- 불변 클래스 : 행위 상태 모두 고정되어야 



### 0.5.  어떻게 불변 클래스로 만들 수 있나??


#### 0.5.1.  클래스 및 필드에 final 선언 

```java 
public final class Complex {
	
		private final double re;
		private final double im;


		...
		// 값 변경 시 새로운 객체 생성 후 반환
		public Complex plus(Complex c){
				// note : 같은 클래스는 private이여도 필드 접근 가능 
				return new Complex(re + c.re, im + c.im)
		}
}
```
대신 이러한 방법은 수정 시마다 매번 독립된 객체를 생성해야한다.

#### 0.5.2.  정적 팩토리 제공 
> 모든 생성자를 private or package-private 으로 만들고 public 정적 팩토리 사용해라 

```java 
public final class Complex {
	
		private final double re;
		private final double im;

		// 생성자 private으로 
		private Complex(double re, double im){
				this.re = re;
				this.im = im;
		}

		public static Complex valueOf(double re, double im) {
				return new Complex(re, im);
		}
```
명명 규칙 : [[DevStudy/Backend/Java/Effective Java/Obect Create_Destroy(객체 생성과 파괴)/Consider static-factory-method Instead of Constructor\|Consider static-factory-method Instead of Constructor]]

> 보통 불변 객체를 굳이 만들어야 하면 이 방법이 최선일 때가 많다.







