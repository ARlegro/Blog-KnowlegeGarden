---
{"dg-publish":true,"permalink":"/DevStudy/Backend/Java/Effective Java/Obect Create_Destroy(객체 생성과 파괴)/불필요한 객체 생성을 피해라/","noteIcon":"","created":"2025-12-03T14:52:49.305+09:00","updated":"2025-12-13T10:47:30.580+09:00"}
---


똑같은 기능의 객체를 매번 생성하는 것보다 재사용하는게 나을 때가 많다.
특히!! '불변 객체'에서는 더욱 그렇다.


## 1.  극단적인 예  
참고 : [[DevStudy/Backend/Java/String\|String]]
```JAVA
String word = new String("bulkup) ❌

String word2 = "bulkup" ✅
```
- ❌ : 이는 매번 String 인스턴스를 새로 만든다. 만약 이 문장이 여러 번 호출된다면 String 인스턴스가 String Pool에 수백만개가 쌓일 수도 있다.
- ✅ : 이와 같은 문자열 리터럴을 사용하는 코드가 같은 객체를 재사용 

---
## 2.  팩토리 메서드를 통한 예시 

```java

public class MatchMachine;

		private static final MatchMachine INSTANCE = create();

		// 매번 동일한 객체 반환 
		public static MatchMachine getInstance() {
				 return INSTANCE
		}

		// 미리 생성
		private MatchMachine create() {
				 return new MatchMachine( ... )
		}
```

---
## 3.  가변 객체는 ??

불변 객체는 객체 재사용이 좋다.
그렇다면 가변 객체는 ❓
- 가변 객체라도 특정 로직에서 사용 중에 변경되지 않음을 확신한다면 재사용 할 수 있다.
- 특히, 생성 비용이 비싼 객체라면 더욱 더 그렇다.

---
## 4.  Match 시 최적화하기 

String의 `matches` 메서드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이다. 하지만 그냥 사용하면 성능에 그렇게 적합하지 않다.

---
### 4.1.  기본 사용 시 matches()는 성능에 부적합 💢
`String.matches(regex)`는 내부적으로 다음과 같이 작동한다.

```java
public final class Pattern  
    implements java.io.Serializable

return Pattern.matches(regex, this);
```
- 호출할 때마다 **`Pattern.compile(regex)`** 로 **정규식 객체를 매번 새로 생성**
- `Pattern` 객체는 컴파일 시 비용이 크며, GC 대상이 되기 전까지 메모리를 잡아먹는다.

**극단적인 예시 - 반복적인 패턴 검사**
```java
for (String input : inputs) {
			if (input.matches("^[a-zA-Z0-9]+$")) {         
					...
			} 
}`
```
- 루프를 돌 때마다 **정규식(Pattern)을 컴파일**하게 되므로 **매우 비효율적**

---
### 4.2.  ✅성능 개선 
그렇다면 문자열 비교 시 어떻게 최적화 할 수 있을까??

일단 `Pattern` 객체는 불변이므로 재사용해도 문제 없다.
- 한 번 `Pattern.compile()` 해서 `Pattern` 객체로 만든 후,
- 이를 `static final`로 캐싱해두고
- `pattern.matcher(input).matches()` 형태로 사용하는 것이 효율적

```java
import java.util.regex.Pattern;

public class PatternUtil {  
    
    private static final Pattern ALPHABET_PATTERN = Pattern.compile("[a-zA-Z]");  
    public static boolean isAlphabet(String str) {  
        return ALPHABET_PATTERN.matcher(str).matches();  
    }
```

---
## 5.  오토박싱의 느린 성능 - 이유 : 객체 생성 

오토 박싱은 불필요한 객체를 만들어 내는 또 다른 예이다.

일반적으로 사용할 때는 자동으로 변환해주니 타입 구분을 흐려줘서 편리햇는데 성능면에서는 조심해야 한다.

---
### 5.1.  비교 
아래의 코드는 모든 양의 양의 정수의 합을 구하는 코드이다.
두 코드를 비교하자
```java
    long startTime = System.currentTimeMillis();  
    Long sum = 0L;  
    for (int i = 0; i < Integer.MAX_VALUE; i++) {  
        sum += i;  
    }  
    long endTime = System.currentTimeMillis();  
    System.out.println("참조형타입(Long) 사용 시 걸린 시간 : " + (endTime - startTime));  
  
    long startTime2 = System.currentTimeMillis();  
    long sum2 = 0L;  
    for (int i = 0; i < Integer.MAX_VALUE; i++) {  
        sum2 += i;  
    }  
    long endTime2 = System.currentTimeMillis();  
    System.out.println("기본형타입(long) 사용 시 걸린 시간 : " + (endTime2 - startTime2));  
}

```
```text
참조형타입(Long) 사용 시 걸린 시간 : 9732
기본형타입(long) 사용 시 걸린 시간 : 692
```
> 무려 14배나 차이난다.

---
### 5.2.  첫 코드가 느린 이유 
sum변수를 Long으로 선언해서 Long 인스턴스가 엄청 많이 만들어졌다.
long은 기본형이지만 Long은 참조형으로 객체이다.
따라서 Long사용 시 불필요한 객체가 생성되는 것이다.

> 기본 타입을 주로 사용하고, 의도치 않은 오토박싱이 들어가지 않도록 주의하자 

---
### 5.2.1.  그럼에도 불구하고 개발의 편의성 

요즘 JVM의 GC는 상당히 최적화가 되어 있어서 가변운 객체들은 빠르게 제거해준다.

프로그램의 간결성, 명확성을 위해서라면 어느 정도 객체 생성은 괜찮다!!