---
{"dg-publish":true,"permalink":"/DevStudy/Backend/Java/JAVA의 컴파일/","noteIcon":"","created":"2025-12-03T14:52:49.314+09:00","updated":"2025-12-13T10:32:00.997+09:00"}
---


### 컴파일 흐름 
>[!tip] 참고: 자바는 JVM에 기계어가 아닌 바이트 코드를 전달 
>1. **일반 컴파일(자바 소스 코드 ➡ 일반 컴파일러)**
>	- `.java` 소스 코드를  Java 컴파일러(javac)에 의해 바이트 코드로 구성된 `.class`파일로 컴파일
>	- `.class`파일은 JVM이 읽을 수 있는 파일 형태 
>	- Javac은 JDK에 포함되어 있다.
>2. **바이트코드 로딩** 
>	- JVM의 '클래스 로더'가 1번에서 만든 바이트 코드를 JVM의 메모리 영역으로 로딩
>	- OS or H/W에 종속적이지 않다!!!  (원래 컴파일러는 종속적인데 이 과정은 비종속적)
>3. **JVM의 "실행 엔진"에 의해 실행됨 (바이트코드를)**
>	- 바이트 코드를 해석하여 실행한다
>	- 실행 엔진은 '인터프리터'와 JIT로 이루어진다.


> **자바는 플랫폼 독립적 언어**
> - 바이트 코드가 OS or H/W에 종속적이지 않다 ➡ JVM이 설치된 모든 시스템에서 실행될 수 있다


### 실행 엔진 종류 

#### 1. 인터프리터 
> 인터프리터 자체 설명 참고 : [[Computer_Science/Preview_CS/1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.\|1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.]]
- 로드된 바이트 코드를 **한 줄씩 읽어**들인 후 **기계어 코드로 해석하고 실행**한다
- 즉각 실행 가능
- 같은 코드 반복 시 매번 해석해야 해서 성능이 느림 (반면, 컴파일러는 알아서 최적화 해줌)

>[!QUESTION] 느린 인터프리터로 계속 진행하는가❓ NO ❗❗
>- JIT라는 컴파일러로 인터프리터의 단점을 보완한다.
#### 2. JIT(Just-In-Time) 컴파일러 
#성능최적화_핵심

**주요 과정** 
1. 자주 실행되는 코드 블록(핫스팟)을 식별한다.
2. 이 핫스팟 바이트 코드를 네이티브 기계어 코드로 컴파일한다 
3. 이렇게 만들어진 코드를 **캐시에 저장**하여 동일 코드가 실행될 때마다 인터프리터의 재해석없이 더 빠르게 실행 가능  #캐시_성능최적화 


**추가 성능 최적화**를 위해 OS에 종속적인 기계어로
- JIT컴파일러가 기계어 변환 시 각 OS에 맞는 최적화된 기계어로 변환하여 성능을 높인다

