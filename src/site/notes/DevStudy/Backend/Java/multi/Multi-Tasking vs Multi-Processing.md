---
{"dg-publish":true,"permalink":"/DevStudy/Backend/Java/multi/Multi-Tasking vs Multi-Processing/","noteIcon":"","created":"2025-12-03T14:52:49.342+09:00","updated":"2025-12-13T10:40:56.530+09:00"}
---


## 멀티태스킹과 멀티프로세싱

멀티스레드를 이해하려면 위의 2개의 운영체제의 개념을 알아야 함

---
### 단일 프로그램 실행 - 초기 컴퓨팅 방식 
초창기 컴퓨터는 CPU가 1개뿐이었으며, 한 번에 하나의 프로그램만 실행할 수 있었다. 
> 예시 상황 (프로그램 2개 동시, CPU는 1개)
> - 음악 재생 프로그램과 워드 프로그램을 동시에 실행하고 싶어도, 실제로는 CPU가 먼저 음악을 실행한 후, 워드를 실행함
> - **CPU는 순차적으로만 코드 실행 가능** → 병렬 실행 불가

![Pasted image 20250622145915.png](/img/user/supporter/image/Pasted%20image%2020250622145915.png)

- **초창기 프로그램은 이렇게 한 번에 하나의 프로그램만 실행가능했다.**
- ❌즉, 동시 실행 자체가 물리적으로 불가능 


>[!tip] 멀티태스킹의 등장
>이러한 문제를 해결하기 위해 **하나의 CPU 코어**로 **여러 프로그램을 동시에 실행**하는 ”멀티태스킹”기술이 등장했다.

---
### 멀티태스킹
> 하나의 CPU로 여러 프로그램을 동시에 실행 **되는 것처럼 보이게 하는 기술**

여러 사진을 매우 빠르게 교차해서 보면 애니메이션처럼 보인다. 이런 원리를 이용
- **번갈아가면서 반복 수행 :** CPU가 매우 빠르게 여러 프로그램의 코드를 번갈아 수행하면, 사람이 느낄 때 동시에 실행되는 것처럼 느껴짐. 
- **시 분할 기법(타임 쉐어링)** : **CPU 시간을 잘게 나누어 프로그램에 할당하는 기법**이다. 이는 각 프로그램이 마치 동시에 실행되는 것처럼 하는 기법이다.
![Pasted image 20250622150101.png](/img/user/supporter/image/Pasted%20image%2020250622150101.png)


>[!tip] 참고 : 스케쥴링 By OS
>- **정의** : 어떤 작업에 CPU를 언제/얼마만큼 할당할지를 결정
>- OS는 다양한 우선순위, 응답시간, 공정성 등을 고려해 최적화된 방식으로 작업을 관리한다.
>- **목표** : CPU자원을 최대한 효율적으로 사용하는 것 

---
### 멀티 프로세싱
> 물리적으로 “진짜 동시에 실행”할 수 있는 기술
---
#### 1. 정의
- **컴퓨터 시스템에서 둘 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시에 처리하는 기술.**
- 여러 CPU코어를 사용하므로 더 많은 작업을 처리 가능
  
![Pasted image 20250622150333.png](/img/user/supporter/image/Pasted%20image%2020250622150333.png)

이로 인해 여러 작업을 물리적으로 **완전히 동시에 처리** 가능
(멀티태스킹의 Time-Sharing이랑은 다름)


> CPU안에는 실제 연산을 처리할 수 있는 “코어”라는 것이 있다.
> 최근 CPU는 대부분 2, 4, 8 코어 이상의 멀티코어 구조이다.

---
### 멀티 프로세싱 VS 멀티태스킹

| 구분     | 멀티 테스킹                                                | 멀티 프로세싱                            |
| ------ | ----------------------------------------------------- | ---------------------------------- |
| **관점** | OS/SW 의 관점(속임수 비슷)                                    | H/W 장비의 관점                         |
| **핵심** | 한 CPU 코어가 **시분할**로 여러 작업에 번갈아 배분해 **동시 실행처럼** 보이게 한다. | 여러 개의 CPU 코어가 서로 다른 작업을 진짜로 동시에 수행 |
| **장점** | CPU 사용률 극대화                                           | 연산 작업 시간 단축<br>이론적으로 코어 수만큼 처리량 향상 |
| **단점** | Context Switching으로 인한 오버헤드 문제                        | 코어 간 자원 공유 이슈<br>하드웨어 비용 증가        |

- **멀티태스킹**
    - 단일 CPU 코어가 - 매우 빠르게 여러 작업을 **순차적으로 처리**. 사람 눈에는 **동시에 실행되는 것처럼 보이도록** 연출
    - 소프트웨어 기반으로 **CPU시간을 분할하여 각 작업을 할당**
    - ex. 여러 애플리케이션이 동시에 실행되는 환경
    - 대표적인 기법 : Time Sharing 

- **멀티 프로세싱**
    - 여러 CPU 코어를 사용하여 동시에 여러 작업을 수행 (프로세서가 여러개)
    - 연산 속도 향상 및 대규모 연산 처리에 효과적
    - 속임수가 아니라 하드웨어 기반으로 성능을 향상시킨다 : **물리적**으로 동시에 가능
	- 현대 대부분의 컴퓨터/서버/모바일은 멀티코어 기반 → **기본적으로 멀티프로세싱 가능**

> 하나의 시스템이 멀티 프로세싱을 하면서 동시에 멀티태스킹을 할 수 있다
> - EX. 작업은 3개인데 코어가 2개인 경우

---
## 프로세스와 스레드
---
### 1. 프로그램 ➡ 프로세스 ➡ 스레드 
프로그램 실행 시 운영체제는 디스크에 있는 파일 덩어리인 프로그램을 메모리로 불러오면서 프로세스를 만든다
- **프로그램** : 디스크에 저장된 '실행 파일' (코드 + 데이터 + etc )
- **프로세스** : 프로그램을 실행을 위해 OS에 의해 메모리(RAM)에 올라온 프로그램의 **실행 인스턴스**
- **스레드** : 프로세스 내부에서 실제로 작업을 수행하는 작업 단위 

![Pasted image 20250622154522.png](/img/user/supporter/image/Pasted%20image%2020250622154522.png)
---
### 2. 프로세스

프로그램은 실행 전까지는 단순한 파일이다. 프로그램을 실행하면 프로세스가 만들어지고 프로그램이 실행된다.

---
#### 정의
- OS 안에서 실행 중인 프로그램
- OS로부터 자원을 할당받는 작업의 단위
- 프로세스는 실행 중인 **프로그램의 ‘인스턴스’**

---
#### 특징

- **독립적인 메모리 공간** : 각 프로세스는 **독립적인 가상 메모리**(Virtual Memory) 공간을 갖고 있으며, **프로세스 간 직접 접근하거나 간섭할 수 없다**.  
- **자원 할당** : OS로부터 코드, 데이터, 힙, 스택 등 다양한 시스템 자원을 할당받는다. 
- **높은 안정성** : 독립적으로 작동하기 때문에 한 프로세스가 문제가 발생하여 강제로 종료되더라도, 다른 프로세스에는 직접적인 영향을 주지 않아 시스템 전체의 안정성을 높인다.

> [!WARNING] 프로세스의 생성/관리 비용은 크다.
> - 새로운 프로세스를 생성하거나 Context Swtiching 시 오버헤드가 크고 비용이 많이 든다 
> - Cuz **독립적인 메모리 공간과 자원을 모두 전환해야하므로** 

---
#### 프로세스 메모리 구성

- **코드 섹션** : 실행될 코드가 저장되는 부분으로 읽기 전용 영역이다 (❌중간에 코드 변경 불가)
- **데이터 섹션** : 전역 변수 및 정적 변수가 저장되는 부분
- **힙** : 프로그램 실행 중 동적으로 할당되는 메모리 영역. 주로 객체(인스턴스)들이 저장됨 
- **스택** : 메서드 호출 시 생성되는 지역변수, 매개변수, 반환주소 등이 임시로 저장되는 영역. 함수 호출마다 프레임이 쌓이고, 함수 종료 시 해제된다.

> 프로세스는 '실행 환경과 자원을 제공하는 컨테이너' 역할을 수행

---
### 3. 스레드(Thread)
![Pasted image 20250622154522.png](/img/user/supporter/image/Pasted%20image%2020250622154522.png)
> 프로세스는 하나 이상의 스레드를 반드시 포함한다

---
#### 정의
- **프로세스 내에서 실행되는 작업의 단위**
- **프로세스의 자원을 공유**받으며 CPU를 이용하여 **코드를 실행** 
- 하나의 프로세스 내에는 반드시 하나 이상의 스레드가 존재하며, 이 스레드가 실제 작업을 수행
	EX. 자바에서는 main이라는 스레드가 무조건 있음 

---
#### 특징
- **메모리 공유** : 동일한 프로세스 내의 스레드들은 해당 프로세스의 **코드 섹션, 데이터 섹션, 힙 영역을 공유**한다. 따라서, Thread 간 데이터 통신은 매우 빠르고 효율적이다.

- **개별 스택 보유** : 각 스레드는 자신만의 독립적인 스택을 보유 Cuz 스레드마다 고유한 함수 호출 정보 및 지역변수를 유지해야 하기 때문 
- **상대적 낮은 생성/관리 비용** : 프로세스 생성에 비해 스레드 생성 비용은 저렴하다. 또한 스레드 간 Context Switching 시에도 프로세스 전체의 메모리 공간을 변경할 필요 없이 스택, PC 레지스터 등 일부만 변경하면 되므로 **오버헤드가 적고 빠르다.**
- **낮은 안정성** : 한 프로세스 내의 스레드끼리 메모리를 공유하기 때문에 한 스레드의 오류가 다른 스레드와 전체 프로세스에 영향을 미쳐 프로세스 자체가 강제 종료될 수 있다.

> 스레드는 'CPU를 사용해서 코드를 하나하나 실행하는 흐름'


> **프로세스** → 실행 환경과 자원을 제공하는 **컨테이너** 역할
> **스레드** → CPU를 사용해서 코드를 하나하나 실행

---
### 프로세스 vs 스레드 정리

| 비교 항목  | 프로세스                                     | 스레드              |
| ------ | ---------------------------------------- | ---------------- |
| 메모리 공유 | X (독립적인 가상 메모리 공간)                       | O (같은 프로세스 내 공유) |
| 생성 비용  | 높음 (새로운 OS 자원 할당)                        | 낮음 (프로세스 자원 공유)  |
| 실행 속도  | 상대적으로 느림                                 | 빠름               |
| 통신 방식  | IPC(Inter-Process Communication) 사용 (느림) | 공유 메모리 사용 (빠름)   |
| 안정성    | 독립적 (다른 프로세스 영향 없음)                      | 하나가 죽으면 전체 영향 가능 |
| 사용 사례  | 웹 브라우저, 데이터베이스                           | 웹 서버, 게임 엔진      |


---
### 멀티스레드가 필요한 이유 

1. **동시성과 응답성 향상**
	- 대부분의 현대적인 애플리케이션은 **끊김 없는 사용자 경험**과 **빠른 응답**을 제공해야 한다다. 
	- 하나의 프로그램 안에서도 여러 작업을 동시에 처리해야 할 필요가 생기는데, 이때 **멀티스레드**가 필수적이다.
	- 예시 - 유튜브 영상 시청하면서 댓글 달기(스레드1 - 영상재생, 스레드2 - 댓글)
		- 만약 단일 스레드라면 댓글을 다는 동안 영상이 잠시 멈추거나 버벅일 것이다.
	  
2. **자원 활용 효율성 극대화**
	- 현대 CPU는 멀티 코어로 구성되어 있다.
	- CPU 처리 능력을 극대화하기 위해서는 멀티스레드를 통해 병렬로 처리함으로써 전체 시스템의 throughput을 높일 수 있다.
	  
3. **프로세스 생성/관리 비용 절감**
	- 여러 작업을 위해 매번 프로세스를 생성하는 것은 비용이 많이 든다.
	- 반면, 스레드는 프로세스의 자원을 공유하므로 생성/관리에 효율적이다

---
## 스레드와 스케쥴링

---
### 스케쥴링이란 ❓
> OS의 핵심 기능 중 하나로, 실행 대기 중인 스레드(or 프로세스)에게 어떤 순서로, 얼마만큼의 시간동안 CPU 할당할지 결정

제한된 CPU자원을 여러 프로그램에게 효율적으로 분배하여 동시에 실행되는 것처럼 보이게 하거나 실제로 동시에 실행하는 과정을 말한다.
- **목표** : CPU 활용 극대화, 스루풋 증대, 응답시간 최소화 등
- **주체** : OS의 스케쥴러가 담당. 
- **방법** : 스레드들의 우선순위, 실행 시간, 대기 시간 등 다양한 기준과 최적화 기법을 사용해서 CPU 시간을 분배한다.

---
### 단일 코어 스케쥴링
> CPU코어가 1개일 때 스케쥴링하는 과정


- 스케쥴링 큐 : OS는 **내부에 스케쥴링 큐**를 가지는데, 이것이 **어떤 순서대로 스레드들을 번갈아 실행할지 결정한다.**
- **Time-Sharing 원리** : 스케쥴링 큐에서 스레드를 선택하여 CPU에 할당하면 정해진 시간동안만 실행시킨다.
- **컨텍스트 스위칭(Context Switching)**: 스레드를 번갈아 실행할 때, 현재 실행 중인 스레드의 **상태(PC 레지스터, 스택 포인터 등)를 저장하고 다음 실행할 스레드의 상태를 불러오는 작업**이다. 스레드 간 컨텍스트 스위칭은 프로세스 간 스위칭보다 훨씬 가볍고 빠르다.
- 물리적으로는 한 번에 하나씩 실행되지만 스위칭이 매우 빠르기 때문에 소비자는 여러 작업이 동시에 진행되는 것처럼 느껴진다.


1. 각각의 스레드는 스케쥴링 큐에서 대기한다 Cuz 동시 실행은 불가능
	    ![Pasted image 20250622163202.png](/img/user/supporter/image/Pasted%20image%2020250622163202.png)
    
2. 스레드 하나씩 스케쥴링 큐에서 꺼내고 넣고 빼고 반복
	    ![Pasted image 20250622163246.png](/img/user/supporter/image/Pasted%20image%2020250622163246.png)
    - 꺼낸 스레드의 코드를 수행하고 CPU를 통해 연산


---
### 멀티 코어 스케쥴링
> CPU 코어가 2개 이상이며 한 번에 더 많은 스레드를 동시에 진행 가능

- **병렬 실행** : 스케쥴러는 사용 가능한 여러 Core에 Thread들을 동시에 할당하여, 한 번에 여러 개의 스레드가 물리적으로 동시에 실행되도록 한다 ➡ 처리 능력 향상 
- 이는 동시성이 아니라 '병렬성'이다.

![Pasted image 20250622163329.png](/img/user/supporter/image/Pasted%20image%2020250622163329.png)

> [!WARNING] 동시성 vs 병렬성 
> 1. 동시성 : 여러 작업이 "동시에 진행되는 것처럼 보이는" 상태 (단일 코어에서도 가능).
> 2. 병렬성 : 여러 작어빙 "진짜 동시에 실행되는" 상태 (멀티 코에에서만 가능)

---

## 중간 정리

| 구분         | 설명                                        |
| ---------- | ----------------------------------------- |
| **프로세스란❓** | 실행 중인 프로그램 인스턴스로, 메모리와 자원을 독립적으로 갖는 작업 단위 |
| **스레드란❓**  | 프로세스 내에서 실제 작업을 수행하는 실행 흐름                |
| **메모리 공유** | 스레드는 같은 프로세스의 메모리를 공유, 프로세스 간엔 공유 불가      |
| **안정성**    | 프로세스는 고립되어 안전, 스레드는 하나의 충돌로 전체 영향 가능      |
| **사용 목적**  | 프로세스는 독립 실행 단위, 스레드는 속도 향상 및 자원 절약 목적     |

> [!WARNING] OS의 스케쥴러에 의해 직접 실행되는 것은 프로세스가 아니라, **프로세스 내의 쓰레드이다!!**

---
## 컨텍스트 스위칭
#오버헤드 
멀티태스킹이 반드시 효율적인 것은 아니다 Cuz CPU가 여러 작업을 번갈아 처리할 때 발생하는 **오버헤드**가 있기 때문

---
### 스위칭 비용 예시 
**상황 : A스레드를 처리하다가 B를 처리하다가 다시 A로 돌아올 때*
- A스레드에서 어디까지 진행됐는지를 알아야 한다
- 이를 위해 A를 멈추는 시점에 현재 상태를 메모리에 저장해두어야 함. (이를 A스레드의 '컨텍스트'라고 함)
- 이후 A로 돌아올 때, 이전에 저장해 둔 A스레드의 컨텍스트를 CPU에 다시 불러와야 한다.

> [!tip] 현재 실행 중인 작업의 상태를 저장하고, 다른 작업의 상태를 복원하는 이 전체 과정을 **'컨텍스트 스위칭'** 이라고 한다.

---
### 컨텍스트 스위칭과 비용

**컨텍스트** 
- 현재 작업 중인 스레드(or 프로세스)의 '작업 환경'을 의미한다. 이 환경에는 작업을 중단했다가 다시 시작하는데 필요한 모든 정보를 포함 

**컨텍스트 스위칭**
- CPU의 '작업 환경'이 하나의 작업(스레드)에서 다른 작업(스레드)으로 바뀌는 것을 의미

CPU가 이전 값을 메모리에 저장하고(쓰기), 다시 불러오는(읽기) 작업을 수행해야 하므로 **작지만 무시할 수 없는 비용(오버헤드)** 이 발생. 이 때문에, 멀티 스레드가 항상 효율적인 것은 아니다

> [!tip] 그래도 멀티 스레드는 대부분 효율적!!!!! cuz 스위칭 비용 얼마 안 됨

---
### 멀티/단일 스레드 각각 유리한 상황 

---
#### 멀티스레드 유리한 상황 
> 상황 : CPU 코어 2개, 쓰레드 2개
- 각 스레드가 별도의 CPU 코어에서 **동시에(병렬로)** 실행될 수 있다.
- 두 스레드 사이에서는 컨텍스트 스위칭이 필요 없으므로, 단일 스레드 방식에 비해 이론적으로 약 2배 빠른 연산 속도를 얻을 수 있다.

---
#### 단일 스레드 유리한 상황 
> 상황2. CPU 코어 1개, 쓰레드 2개
- 물리적으로 한 번에 하나의 스레드만 실행될 수 있다.
- 연산 중간 중간에 **컨텍스트 스위칭 비용**이 발생
    - 스레드1을 멈추고 다시 실행할 때, 이전 연산 기록을 알아야 해서 CPU에서 불러와야 함 → 이로 인해, 컨텍스트 스위칭 비용 발생
- 이런 경우, 단일 쓰레드가 유리

이런 간단한 예시에서는 컨텍스트 스위칭 비용 체감 없다.

> [!WARNING] 실제로는 이렇게 간단하게 CPU개수와 스레드 개수를 맞추면 큰일난다

---
## 최적의 스레드 

---

### CPU 바운드 작업 vs I/O 바운드 작업

**각각의 스레드가 하는 작업**은 크게 2가지로 구분할 수 있다. 이 두 유형의 차이를 이해하는 것이 멀티스레드 성능 최적화에 매우 중요

1. **CPU-바운드 작업 (CPU-bound tasks)**
    - CPU의 연산 능력을 많이 요구하는 작업을 의미
    - 주로 계산, 데이터 처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우다.
    - 예시: 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학 시뮬레이션 등
      
2. **I/O-바운드 작업 (I/O-bound tasks)**
    - 디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업
    - 이러한 작업은 I/O 작업이 완료될 때까지 **대기 시간이 많이 발생**하며, CPU는 상대적으로 유휴(대기) 상태에 있는 경우가 많다. 쉽게 이야기해서 **스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때 까지 대기**한다.
    - 예시: 데이터베이스 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등

---
### 최적의 스레드 설계  Tip
> [!abstract] 최적의 스레드 설계 
> CPU 바운드 작업이 많은지, I/O-바운드 작업이 많은지에 따라 다르게 결정 必
> 
> 1. **CPU 바운드 작업** 
> 	- CPU코어 수와 같거나 약간 더 많은 수의 스레드 사용이 효율적 
> 	- 너무 많은 스레드 생성 시 오버헤드만 증가 
> 2. **I/O 바운드 작업**
> 	- CPU 코어 수보다 훨씬 더 많은 스레드 가질 수 있다.
> 	- 한 스레드가 I/O를 기다리는 동안 다른 스레드가 CPU를 사용할 수 있기 때문
> 	- CPU 대기시간을 최소화하고 전체 시스템의 응답성, 처리량을 극대화 

---
### 실무 얘기
실무에서 개발하는 대부분의 웹 은 CPU-바운드 작업보다는 **I/O-바운드 작업의 비중이 압도적으로 높다**
즉, 연산이 필요한 작업보다는, 대부분 사용자의 입력을 기다리거나, 데이터베이스를 호출하고 그 결과를 기다리는 등, 기다리는 일이 많다.

핵심 : 실무에서는 대부분 I/O 바운드 작업이 많다는 가정하에 설계하여 CPU의 유휴 시간을 최소화하고 처리량과 응답속도를 극대화해라 



