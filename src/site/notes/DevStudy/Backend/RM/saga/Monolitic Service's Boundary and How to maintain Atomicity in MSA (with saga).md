---
{"dg-publish":true,"permalink":"/DevStudy/Backend/RM/saga/Monolitic Service's Boundary and How to maintain Atomicity in MSA (with saga)/","noteIcon":"","created":"2025-12-03T14:52:49.888+09:00","updated":"2025-12-13T10:19:26.651+09:00"}
---




>Saga 패턴을 좀 더 깊이 공부하고자 유튜브에서 50분에 달하는 강의가 있길래 그걸 들을면서 요약한 글

https://www.youtube.com/watch?v=YPbGW3Fnmbc

목차
- 전통적 분산 트랜잭션 매커니즘인 2PC(Two Phase Commit)이 Micro 서비스에서는 쓰이면 안되는 이유
- 대안 : saga ➡ 마이크로서비스에서 트랜잭션을 구축하기 좋은 패턴 


### 0.1.  도입 
B2B 온라인 store를 운영한다고 가정하자
- 기본 제한 : Customer는 credit limit(신용 한도)이 있다.
- 즉, 주문의 total amount가 credit limit을 넘으면 안된다.

> 이거를 구축할 때, 너무 쉽다고 느껴질 수 있다. 그것은 monolitic application 구축에 익숙하기 때문이다.
> 마이크로 서비스로 구축하라고 한다면 약간 복잡하다.

## 1.  전통적 아키텍쳐와 한계 
### 1.1.  전통 아키텍쳐 특징 
전통적인 아키텍쳐에서는 @Transactional을 이용해서 서비스 메서드를 만들었을 것이다.
이 방식으로 order->payment -> inventory 흐름을 처리하는건 매우 간단하다
이게 ACID 프로그래밍 모델을 썼기에 가능한 것 
이러한 모델에서는 동시에 여러 트랜잭션의 요청이 들어와도 일관성을 보장한다.

### 1.2.  전통적인 monolitic application의 문제 
**확장에 한계가 있다.**
- 서비스가 성공하면 시간이 지남에 따라 점점 커질텐데 기존 전통적인 아키텍쳐에서는 개발, 테스트, 배포에서 엄청나게 느려지고 문제가 발생한다.
- 예를 들어, 하나가 실패하면 서버가 다운되고 서비스가 다운되는 문제, 수많은 모델들을 한번에 배포해야되는 문제 등 

> 즉, **속도 저하 + 장애 확산 + 독립적 개발 및 배포 등의 어려움**이 있다는 것 
> 이러한 문제들은 전통 아키텍쳐로는 해결할 수 없다.

## 2.  마이크로 서비스 

### 2.1.  등장 
앞서 말한 전통 monolithic application의 문제로 인해 MicroService가 나온 것이다.

>[!Question] 어떻게 해결했을까❓
>하나의 거대한 애플리케이션이 아니라 **기능별로 작고 느슨하게 결합된 독립 서비스 집합**으로 나눔.
>#느슨한_결합

이로 인해
- 서비스간에는 결합도가 낮아지고 더 간단해졌다.
- 병렬 소프트웨어 개발도 가능해졌다.
- 각 서비스는 다른 서비스에 종속적이지 않기 때문에 자유롭게 변형 가능하다 

우선 아래의 사진에서 MicroService 아키텍쳐를 보자 
![Pasted image 20250618093404.png](/img/user/supporter/image/Pasted%20image%2020250618093404.png)
고객 서비스, 주문 서비스 등 여러 서비스가 있고, 그 앞에 요청 라우팅 및 API 조합 등을 수행하는 **API 게이트웨이**가 있다.

한 가지 흥미로운 특징이 있는데, 바로 **각 서비스가 자체 데이터베이스를 가지고 있다는 점**이다.
물론, 데이터베이스 서버는 하나만 있을 수도 있고, 그 서버 내에서 각 서비스는 자체 개인 스키마 또는 개인 테이블을 가지고 있습니다. 실제 세부 사항은 중요하지 않지만, **캡슐화된 데이터**를 갖는다는 개념은 마이크로서비스 아키텍처의 핵심이다.

### 2.2.  아키텍쳐 문제점 

마이크로서비스 아키텍처를 채택함으로써 얻는 많은 이점이 있지만, 한편으로는 각 서비스가 데이터베이스를 캡슐화하게 되면 **데이터 일관성과 트랜잭션 관리**에 새로운 문제가 발생함.


#캡슐화된_데이터

**💢문제 예시** 
- 상황 : 주문 서비스에서 작업하고 있고 스키마를 변경하고 싶다. 
- 문제 : 근데 그 테이블에 접근하는 다른 5개의 서비스, 팀이 있다면❓그 변경 사항을 어떻게 언제 적용하고 조율할지 회의해야 함 ➡ 이는, 개발을 방해하고 자율성을 잃게된다.

> 결국 MicroService는 자율적이고 독립적인 병렬 개발을 진행해야 하는데 하나의 DB를 공유한다면 그렇지 못한다.

### 2.3.  2PC 분산트랜잭션의 한계
[[DevStudy/DB/Fundamentals of DB engineering/Concurrency Control/Two Phase Lock\|Two Phase Lock]]

**✔분산 트랜잭션이란❓**
- **둘 이상의 시스템(노드, DB 등)에 걸쳐 동시에 발생하는 하나의 논리적인 트랜잭션**  
- 즉, 여러 리소스를 묶어서 **모두 성공하거나 모두 실패해야 하는 상황**.

✔**2PC란❓**
- 분산 트랜잭션에서 원자성을 보장하기 위해 가장 널리 사용되는 프로토콜 중 하나
- Coordinator가 모든 참여 노드(Participant)에 요청 → 응답 수신 후 commit 또는 rollback 결정\
- **원자성 보장** 측면에서는 강력

💢**2PC의 단점** 
- **블로킹 문제** : Coordinator의 최종 결정을 기다리는 동안 해당 자원에 락을 걸기 때문에 다른 트랜잭션들이 해당 자원에 접근 못하는 문제 ➡ **성능 저하, 병목 요인**
- **단일 장애 지점** : Coordinator가 장애가 나면 다른 곳들, 트랜잭션들도 전부 지연되는 문제
- **성능 저하** : DB, 노드 간 네트워크 통신 및 락 유지로 단일 트랜잭션에 비해 성능 **오버헤드**가 크다.
- **강결합** : MSA의 독립성 환경에 적합하지 않다.

> 이러한 문제들로 인해 MSA에서는 2PC는 **비현실적인 접근**이며, **대안적인 트랜잭션 관리 방식**이 필요함.

## 3.  Saga 패턴 : MSA에 적합한 대안 
앞서 말했듯이, MSA에서 데이터의 일관성을 유지하기 위해 2PC는 힘들다. 다른 방법을 사용해야 한다.
이로 인해 등장한 것이 Saga 매커니즘이다.


### 3.1.  Saga 개념 
아이디어는 아래와 같다.
![Pasted image 20250618095238.png](/img/user/supporter/image/Pasted%20image%2020250618095238.png)
Saga는 분산 트랜잭션이 아닌, '로컬 트랜잭션의 시퀀스'인 Saga를 이용하는 것이다.
위의 사진을 보면 3가지 서비스(A,B,C)에 트랜잭션 대신 전체를 감싸는 Saga가 있다. 그리고 각 서비스는 로컬 트랜잭션을 갖고 있다.
- **하나의 분산 트랜잭션 대신**, **여러 개의 로컬 트랜잭션의 시퀀스**로 처리
- 각 로컬 트랜잭션은 **자신의 DB 내에서 수행**되며, 다음 단계 트랜잭션을 **이벤트로 트리거**함


### 3.2.  Saga를 이용한 주문 생성 예시 

#### 3.2.1.  전통적 saga 
![Pasted image 20250618100705.png](/img/user/supporter/image/Pasted%20image%2020250618100705.png)
**Step1. 주문 생성요청 - Order Service**
- 주문을 생성
- 완료되면 다음 Step의 trigger역할을 해준다.

**Step2. 신용 예약 - Customer Service** 
- 고객 서비스에서 또 다른 트랜잭션이 발생하여 신용 예약하려고 시도
- 이것도 완료되면, Order Service에 또 다른 트랜잭션이 발생시킴 

**Step3. 승인여부 결정 - Order Servcie** 
- 신용이 충분하면 주문을 승인하고, 신용이 부족하면 주문을 거부

> 이것을 조금 변형해볼 것이다.
#### 3.2.2.  전통적 saga의 문제와 보상 트랜잭션 
위에서 언급한 전통적 Saga 모델에는 몇 가지 복잡성이 있다.
특히, 가장 중요한 문제는 어떻게 롤백 처리할 것인가❓이다.
개별 트랜잭션이기 때문에 자동 롤백은 없음며 이전에 수행한 작업을 명시적으로 되돌려야한다.
만약 10단계 중 9단계에서 실패했다면? 이 로직을 개발자가 하나하나 명시적으로 되돌리는 로직을 짜는 것은 매우 복잡할 것이다.

또 다른 예시를 보자, 두 계좌 간에 돈을 이체한다고 상상해 봅시다. 출금 계좌에서 돈을 인출하고, 사가의 두 번째 단계로 입금 계좌에 입금하려고 할 때, 입금 계좌가 폐쇄된 것을 발견합니다. 그러면 출금한 것을 되돌려야 하는데, 이 시나리오에서는 입금을 해야 한다는 의미가 됩니다. 그러면 고객은 통장 명세서에 두 개의 거래를 보게 됩니다. 흥미롭게도 이 시점에서 출금 계좌도 폐쇄되었다는 것을 발견할 수도 있습니다. 그러면 입금 계좌에 입금할 수도 없고, 출금 계좌에서 인출한 것을 되돌릴 수도 없는 이상한 상황에 놓이게 됩니다. 그래서 이 시점에서는 어떤 비즈니스 프로세스든 더 높은 수준의 비즈니스 프로세스가 시작되어야 합니다. 따라서 이러한 다양한 보상 트랜잭션을 생각해 내려면 많은 시나리오를 고려해야 합니다. 이것이 하나의 과제입니다.

이를 해결해주는 개념이 '보상 트랜잭션'이다.
예를 들어 T1 ~ T4가 있다. 각 T에는 수행한 작업을 되돌리는 보상 트랜잭션이 있따. 




~머 여러 문제 언급 


## 4.  Saga Coordination 메커니즘 
이전에 기본적인 Saga소개로 끝났고, 이제는 그 문제를 해결하는 Coordination 메커니즘을 소개할 것 

아이디어 : 사가 단계 중 하나인 TI가 완료될 때, 다음으로 무엇을 할지 파악하기 위해 어떤 코드 조각이 실행되어야 한다는 것

이러한 Coordination 메커니증을 구현하는 2가지 모델이 있다.
1. Choreography : Saga 참여자들이 스스로 무엇을 할지 파악하는 
2. Orchestration : 다음에 무엇을 할지 결정하는 중앙 집중식 구성 요소

Choreography는 각 서비스에서 실행되는 일부 코드가 다음에 무엇을 할지 파악한다. 하지만 이는 서로를 결합시키는 경향이 있다.
따라서 더 깔끔한 모델은 Orchestration를 사용해 **중앙 집중식 의사 결정 구성 요소**를 갖는 것이다.
즉 서비스가 더 이상 사가 자체와 묶여 있지 않다는 점에서 좋다.

### 4.1.  Orchestration
이 실제 코디네이터 구성 요소는 **상태 머신(state machine)** 으로 모델링 할 수 있다.
![Pasted image 20250618102106.png](/img/user/supporter/image/Pasted%20image%2020250618102106.png)

Coordinator는 state machine ❓
- Coordinator는 흐름을 관리한다.
- 특정 **상태(State)** 에 머무르면서, 사가 참여자(서비스)에게 **명령(Command)** 을 보낸다.
- 참여자로부터 **응답(Event)** 이 돌아오면, 이 응답에 따라 다음 **상태로 전환(Transition)** 된다.
- 만약 실패가 발생하면, 이전 단계를 되돌리기 위한 **보상 트랜잭션**을 시작하며, 이 과정 또한 상태 전환의 흐름을 따른다.
- 이것은 간단한 모델이며, 우리는 이것을 쉽게 코딩할 수 있다.

> 각 상태는 사가의 특정 진행 단계를 나타내고, 이벤트는 상태 전환을 유발하며, 각 상태에서는 특정 명령을 실행

#### 4.1.1.  Orchestration의 두 가지 모델: Implicit Orchestration vs. Explicit Orchestration
Orchestration도 2가지 모델이 있다
1. Implicit Orchestration
2. Explicit Orchestration

이 2가지 방식은 **Coordinator의 구현 및 상태 관리 방식이 얼마나 명시적인가**에 따른 분류이다.

**1‍⃣ Implicit Orchestration**
> Coordinator의 상태 관리 로직이 별도의 **명시적인 상태 기계 정의 없이, 일반적인 애플리케이션 코드(예: 서비스 클래스의 메소드) 내에 암묵적으로 구현**되는 방식
- **구현이 용이하다** 
	- 개발자가 복잡한 상태 기계 프레임워크를 학습하거나 사용할 필요 없이, `if-else` 문이나 간단한 흐름 제어로 사가를 진행
	  
- **복구의 어려움**: 실패 발생 시 사가를 정확히 어느 지점에서 복구해야 할지 파악하고, 보상 트랜잭션을 실행하는 로직이 복잡해질 수 있다. 특히 장기 실행 OR 복잡한 분기 로직에서는 더더욱 어렵다. 
  이 경우 개발자가 모든 실패 시나리오를 수동으로 코딩해야하는 문제도 발생 
- **투명성 부족** : 사가의 전체 흐름과 가능한 모든 상태 전환이 코드 곳곳에 흩어져 있어, 한눈에 파악하기 어렵고 감사(audit)하기 힘들다

흠... 내가 이전에 Switch로 redis에서 상태 저장한 DTO 가져와서 파악하고 진행하는 그런 느낌이네 

**2‍⃣ Explicit Orchestration**
- 단일 Saga를 오케스트레이션하는 데 전적으로 책임이 있는 별도의 객체를 가질 수 있다.
- 직접 구현하지 않아도 된다 : 매우 시간을 절약하고 생산성 향상 
- 모듈화가 쉽다


### 4.2.  Explicit Orchestration 예시 

#### 4.2.1.  간단한 구현 model 
![Pasted image 20250618104040.png](/img/user/supporter/image/Pasted%20image%2020250618104040.png)
- 이 이벤트 기반 모델에서는 Order가 자체 유효성 검사를 조정하는 역할 (state machine 역할)
- **흐름** 
	1. 주문이 생성되고 "내가 생성되었습니다"라는 이벤트를 발행. 
	2. 고객 서비스가 해당 이벤트를 받아 신용을 예약하고, 신용 예약 결과를 나타내는 이벤트를 발행
	3. 주문은 이벤트 핸들러를 통해 상태를 변경. 이 경우 주문은 작은 상태 머신처럼 작동하며 (이 경우 고객 서비스와만 상호 작용하지만) 인벤토리 서비스도 있다면 주문은 인벤토리 서비스로부터 인벤토리 예약 완료 이벤트를 기다릴 수 있다.
- **문제 💢**
	- But, 이는 주문이 과도한 책임을 지게 되고, 서비스가 서로의 이벤트를 소비하면서 순환 종속성과 같은 미묘한 문제들이 있습니다. 작동은 하지만, 순환 종속성이 문제이다.
	- 쉬운 구현이지만 문제를 갖고 있다는 것
#### 4.2.2.  활용 - 명시적 코디네이터 객체를 갖기 
![Pasted image 20250618104431.png](/img/user/supporter/image/Pasted%20image%2020250618104431.png)
- 흐름 
	1. 주문을 생성하라는 요청이 들어오면 '**주문 생성 사가**(Create Order Saga)'**가 생성**되며, **즉시 주문을 생성** 
	2. '주문 생성 사가'는 고객 서비스에게 신용을 예약하라고 지시하고, Customer 서비스는 그렇게 한다. 
	3. Customer Service는 작업 수행 후 회신을 보내고, '주문 생성 사가'는 주문을 승. 

더 복잡한 사용 사례에서는 이 '주문 생성 사가'가 다섯 개의 다른 서비스에게 차례로 무엇을 할지 지시하는 등 훨씬 더 복잡한 상태 머신 모델을 갖는다.


사가 자체는 순수하게 **동작**이다. 이것은 stateless singleton이며, 스프링 버전에서는 스프링 빈으로 등록되어있다.


**✔메시지 Broker 사용 시 흐름 예시** 
![Pasted image 20250618110641.png](/img/user/supporter/image/Pasted%20image%2020250618110641.png)

메시지 브로커 사용 시 문제는 원자성이다.
하나의 트랜잭션이 아니기 때문에 중간에 잘못되면 데이터 정합성이 깨지는 문제 발생

이러한 문제를 해결하는 것이 OutBox 패턴이다.
![Pasted image 20250618110932.png](/img/user/supporter/image/Pasted%20image%2020250618110932.png)
보내고 싶은 메시지를 메시지 테이블에 저장하고 메시지 Publisher가 이에 접근해서 brokder에게 전달하는 것 
메시지를 메시지 테이블에 저장하는거는 Cusomer Service의 예약 로직과 동일 트랜잭션이라 ACID는 지켜진다.

문제는 Publisher가 접근하는 방법이다

> 대충 여기까지만 듣고 Spring StateMachine공부하는게 나을 듯 
