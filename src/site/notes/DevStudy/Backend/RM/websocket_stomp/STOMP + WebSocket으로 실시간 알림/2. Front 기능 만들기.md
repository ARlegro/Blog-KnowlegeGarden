---
{"dg-publish":true,"permalink":"/DevStudy/Backend/RM/websocket_stomp/STOMP + WebSocket으로 실시간 알림/2. Front 기능 만들기/","noteIcon":"","created":"2025-12-03T14:52:49.952+09:00","updated":"2025-12-13T10:21:02.685+09:00"}
---


실시간 채팅 구현을 위한 Front 생각 

일단 디자인을 구현하기 전에 JS에서 WebSocket을 구현하려면 어떻게 해야할까?

0. **sockJs, stomp 라이브러리 추가** 
```javascript
    <title>Real-Time Notifications</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
```
1. **STOMP 클라이언트 만들기 (feat. SockJS)**
	- 연결을 위한 객체 
```javascript
const socket = new SockJS('/ws'); // '/ws' = 서버의 WebSocket Endpoint 
const stompClient = Stomp.over(socket)  // SockJS 객체를 STOMP 클라이언트로 wrapping
```
	  
2. **STOMP 클라이언트로 connect 하기** 
	- stompClient.connect( headers, connect콜백함수, error콜백함수)
	- stompClient.connect( headers, connect콜백함수)
		- headers : 연결할 때 보낼 STOMP 헤더 ex. token (일반적으로 `{}` 비워둠)
		- `connectCallback`: 연결이 **성공했을 때** 실행되는 함수
		- `errorCallback` (선택): 연결이 **실패했을 때** 실행되는 함수
	```javascript 
	stompClient.connect( {}, fuction () {
			
			
	})
	```
	
3. **2번의 콜백함수 설정** 
	- 메시지 구독 로직 by `stompClient.subscribe`
	- 서버로 전송 로직 by `addEventListener -> stompClient.send`



Note : [[DevStudy/z.etc/Fundamentals/carfton-test/오류(or Tip)/Direct binding vs Event delegation\|Direct binding vs Event delegation]]
```javascript
$(부모요소).on("이벤트타입", "자식선택자", "핸들러 함수")

$(document).on("click", ".trash-btn", function(){

})
```
