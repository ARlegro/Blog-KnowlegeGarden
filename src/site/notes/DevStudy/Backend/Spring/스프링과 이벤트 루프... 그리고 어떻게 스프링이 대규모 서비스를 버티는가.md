---
{"dg-publish":true,"permalink":"/DevStudy/Backend/Spring/스프링과 이벤트 루프... 그리고 어떻게 스프링이 대규모 서비스를 버티는가/","noteIcon":"","created":"2025-12-28T00:42:03.398+09:00","updated":"2025-12-28T01:39:02.776+09:00"}
---




프로젝트를 하면서 어떤 언어를 사용하는게 적절할지에 대한 고민을 많이 한다.
막연하게 I/O작업이 많으면 python 또는 js계열을 쓰면 되겠지라고만 알고 있는데 이유에 대해 자세히 알고 싶어서 공부하기 위한 글 

## 1.  작업의 병목

서비스의 병목이 무엇인지 아는 것이 중요한다.

작업은 속도가 무엇에 의해 결정되느냐에 따라 크게 2가지로 나뉜다.
1. *CPU Bound*
	- 프로그램의 속도가 CPU의 계산 능력에 의해 결정되는 작업
	- ex. 복잡한 수학 연산, 암호화, 인코딩 등 
	  
2. *I/O Bound*
	- 프로그램의 속도가 데이터의 I/O속도에 의해 결정되는 작업
	- ex. DB 쿼리, API 등

## 2.  I/O 작업을 기다리는 차이 -  멀티스레드 vs 이벤트 루프

### 2.1.  멀티 스레드 
참고 : 전통적인 Servlet 기반 모델 기준(❌Webflux) -> 1개의 요청 - 1개의 스레드 

- *작동 원리*
	- 요청이 들어오면 Thread Pool에서 Thread를 하나 꺼내서 전담 마킹 시킴
	- 이 Thread는 I/O작업이 발생하면 **결과가 올 때까지 Blocking상태가 됨**
	  
- ✅*장점*
	- **안정적** : 하나의 스레드가 에러가 나도 다른 스레드에 영향을 주지 않음.
	- **직관적** : 순차적인 방식이 인간의 사고방식과 비슷해 코드 짜기 쉬움 
	  
- 💢*단점*
	- **자원 낭비** : I/O를 기다리는 동안 Thread는 아무것도 못하고 **메모리만 차지**
	- **대규모 시 Context Switching 비용** : Thread가 수천개가 필요해지면 CPU가 Thread를 갈아끼우는데 시간 다 씀 

### 2.2.  이벤트 루프

> 적은 수의 스레드가 멈추지 않고 계속 일하는 방식 

- *작동원리*
	- 요청이 들어오면 Loop가 이를 접수. 
	- I/O 작업이 시작되면 Loop는 "나중에 알려줘~"라고 던져놓고 즉시 다음 요청을 처리하러 감 
	  
- *✅장점*
	- **고효율** : I/O 대기 시간에 CPU가 거의 놀지 않아서 적은 자원으로 엄청난 수의 동시 접속 처리 가능 
	- **가벼움** : Thread 생성 비용, Context Switching 비용이 거의 없음 
	  
- *💢단점*
	- **CPU 작업에 약함** : Loop는 보통 하나라 복잡한 수학 연산 시작 시 **전체 서비스가 멈춰버림**
	- **콜백지옥 + 에러 핸들링 어려움** : 비동기 흐름 제어는 매우 까다로움


## 3.  대부분 I/O작업인데 왜 Spring을??

여태까지 대부분의 서비스들을 보면 CPU보다는 외부 API, DB 등의 I/O호출이 많았다.
하지만 왜 그렇게 다들 Spring을 쓴 걸까???

1. *트랜잭션 - 동기적 사고 모델*
	- 멀티스레드 + 동기 트랜잭션은 디버깅이 직관적이고 일관성이 있어서 **사람이 이해하기 쉽다**
	- 예외 터지면 롤백하면 되자나. 그냥 사람이 **실수할 여지가 적음**
	- *반면 이벤트 루프에서는❓*
		- 하나의 스레드가 여러 작업을 처리하므로 논리 흐름이 불안정하다.
	  
2. *안정성 - 대규모에 적합*
	- 비즈니스에서 속도보다 안정성을 중요시하는 경우가 많다.
	- 예를 들어 금융, 결제, 정상, 권한 등 
	- *반면 이벤트 루프에서는❓*
		- 보통 스레드가 하나라 예기치 못한 에러가 발생하면 전체 서비스에 영향을 끼치게 된다.
	- 즉, 스레드가 조금 놀더라도 안전하게 가자라는 마인드 
	  
3. *백프레셔 설계 난이도가 쉽다*
	- 백프레셔 = 받는 사람이 감당할 수 있는 만큼만 보내라고 신호 보내는 **제어 메커니즘**
	- 💢**이벤트 루프는 너무 높은 수용력**  
		- 요청을 너무 잘 받아서 메모리가 터질 위험이 있다.
		- 그래서 큐 제한, 세마포어, circuit breaker 등 개발자가 설계해야 함 
		  
	- **반면 Spring은**
		- 커넥션 풀, 스레드 풀, 톰캣 큐 등 실패 지점이 명확하기에 관리하게 쉽다
	  


>[!tip] 쉽게 말하면 복잡성 관리 때문이다.(Not 성능)

| 관점     | 이벤트 루프    | 스프링(동기)   |
| ------ | --------- | --------- |
| I/O 효율 | 매우 좋음     | 상대적으로 불리  |
| 트랜잭션   | 복잡        | 매우 안정     |
| 디버깅    | 흐름 추적 어려움 | 스택 기반 직관적 |
| 실수 위험  | 높음        | 낮음        |
| 대규모 조직 | 어려움       | 매우 적합     |

## 4.  대규모 서비스를 버티는 이유 

>[!QUESTION] 
>Spring Boot는 Thread Pool에 기본적으로 200개의 Thread 세팅이다.<br>
>근데 200개면 한 번에 200요청 아닌가? 그렇게 해서 대규모 처리를 어떻게해? 라는 질문에서 시작한 공부 

### 4.1.  사전 개념 - 스레드가 무작정 많으면 좋지 않은 이유 

>Thread는 비싼 자원이다.

- 스레드는 개당 약 1MB정도의 **Stack 메모리를 점유**
- OS레벨 Thread는 커널 스케쥴링 대상
- *즉, Thread가 많아질수록 OS 레벨에서는*
	- Context Switching 비용 증가
	- CPU 캐시 효율 감소 
	- 스케쥴링 오버헤드 증가가 일어난다.

즉, 무작정 속도를 높인다고 

### 4.2.  핵심 = 스레드 회전율 
동시 접속 != 동시 처리 

보통 서비스에서는 모든 요청이 동시에 들어오지 않는다.(요청마다 미세하게 시간이 다름)

*처리 속도 계산*  
- 하나의 요청 처리 시간 = 0.01 ➡**1개의 스레드가 1초에 100개 요청 처리** 
- 만약, 200개 Thread라면 ➡ 초당 2만건 처리 
  
따라서, Thread가 동시 접속자 수 만큼은 안되더라도 Thread하나가 빨리 끝나면 대규모 트래픽을 처리하기에 충분한다.
