---
{"dg-publish":true,"permalink":"/DevStudy/DB/Basic/B-Tree, B+Tree 이해/","noteIcon":"","created":"2025-12-10T16:55:29.024+09:00","updated":"2025-12-10T17:33:14.174+09:00"}
---


> 현대 DB의 전형적인 구조

참고 자료 : [[DevStudy/DB/Indexing/Key vs Non-Key column Index\|Key vs Non-Key column Index]]

---
## 1.  B-트리란? 

> 군형 잡힌 다진 트리로 **모든 리프 노드가 동일한 깊이**를 갖고, **하나의 노드가 여러 Key와 자식 포인터를 동시에 갖는** 구조

⭐즉, 트리 깊이를 얉게 유지하면서도 대량 데이터를 빠르게 탐색할 수 있도록 최적화된 구조



![Pasted image 20250808105334.png](/img/user/supporter/image/Pasted%20image%2020250808105334.png)

장점들 덕분에 아래 같은 상황에서 많이 쓰임
- DB 인덱스
- 파일 시스템

---
## 2.  B-트리가 필요한 이유 (vs BST)

*💢기존 이진 탐색 트리(BST)의 문제*
- 일반 이진 탐색 트리 구조는 **삽입 순서에 따라 트리가 한쪽으로 쏠리는 문제**가 있다 
- 최악의 경우 탐색시간이 O(N)이 될 수 있음

✔B-Tree는 
- 항상 균형을 유지하도록 만들어진다.
- 이로 인해, 노드가 많고 순서가 달라져도 깊이가 매우 얕아진다.

| **구조**             | **특징 및 효율성**                        | **한계와 B-트리 도입 배경**                                     |
| ------------------ | ----------------------------------- | ------------------------------------------------------ |
| **이진 탐색 트리 (BST)** | 각 단계마다 탐색 공간을 절반으로 줄여 효율적인 탐색이 가능   | 노드당 키가 하나여서 비교 횟수는 적지만, **데이터가 많을 경우 트리의 깊이가 깊어지는 문제** |
| **B-트리**           | 노드당 여러 개의 키를 저장하여 **트리를 '더 얕게'** 만듬 | **핵심:** **노드 접근 횟수 자체를 최소화하여 이 비용을 절감하는 데 유용**         |


---
## 3.  B-Tree 구조 특징

1. 하나의 노드가 여러 Key를 가질 수 있다.
2. 모든 리프 노드 깊이가 동일하다
	- 항상 균형을 유지하기 때문
	- 어떤 Key든 탐색 비용이 일정하다
	  
3. 하나의 노드 안에서 Key들은 정렬되어 있다

---
## 4.  DB가 B-Tree가 쓰는 이유 (실제론 B+Tree)

---
### 4.1.  주 요인 - 디스크 I/O 줄이기 
DB의 성능 최적화의 주 요인은 "디스크 I/O 줄이기"이다.

B-Tree는
- 한 노드가 여러 key를 가짐
- 하나의 노드가 디스크 한 페이지(보통 16KB)에 대응됨
- 따라서 **한 번의 I/O로 많은 key를 로딩 가능**

---
### 4.2.  노드와 디스크  I/O의 관계

*핵심 원리*
1. *노드 1 - Disk Page 1* 
	- B-Tree의 노드 1개당 DB에서는 disk page1개에 대응된다.
	- B-Tree에서 하나의 노드는 여러 개의 Key가 저장되어 있으므로
	  
2. *DB는 필요한 페이지만 최소한으로 읽어서 탐색*
	- 인덱스는 디스크에 저장되어 관리되는데, **페이지 단위로 관리되며 각 페이지는 노드 역할**을 한다.
	- 루트 노드 페이지부터 순차적으로 탐색 ➡ 필요한 노드 페이지만 읽음

---
## 5.  B+Tree ⭐

B-Tree의 개념에서 배운 원리는 비슷한데 큰 차이가 몇 개 있다.

---
### 5.1.  개념 및 원리

> 한 노드(Page)에 가능한 한 많은 key를 때려 넣어서 branching factor를 크게 만들고, 트리 깊이를 ‘비정상적으로’ 얕게 유지하는 구조


**B+Tree는**
- 내부 노드에는 **routing을 위한 key + pointer**만 두고
- 실제 데이터 위치(RID)는 **모두 리프 노드에만 저장**
	- 중간 노드: **key + child pointer**
	- 리프 노드: **key + 실제 데이터 위치(RID)**
	- 즉, 중간 노드의 Key는 단지 비교 기준이며 비교 결과에 따라 child pointer로 routing해준다. 따라서, 중간 노드에 내가 찾는 결과가 있을 수 없음
- 리프 노드는 Linked List로 서로 연결

|항목|B-Tree|B+Tree|
|---|---|---|
|내부 노드에 실제 데이터 저장|있음|없음|
|branching factor|작음|**내부 노드가 가벼워 훨씬 큼**|
|깊이|더 깊어지는 경향|**더 얕음**|
|범위 검색|비효율적|**초고속 (리프 연속 연결)**|

>[!tip]  애초에 B+Tree는 내부 노드가 가벼워 훨씬 더 많은 Key를 넣을 수 있어 깊이가 깊지 않음

---
### 5.2.  특징

1. *검색 비용 일정* ➡성능 안정성 증가
	- 모든 검색이 리프까지 내려가므로 항상 동일한 길이의 경로 탐색
	  
2. *얕은 트리 구조*
	- 중간 노드가 가벼움 ➡ branching factor 최대화 ➡ 얕은 트리 구조
	- 중간 노드에 데이터 payload 정보가 없으므로 더 많은 key를 담을 수 있음 
	- 이로 인해, Tree 깊이가 얕아지고 I/O가 감소한다.
3. *범위 검색 최적화 Cuz 리프노드가 Linked List로 연결 ⭐*
	- 리프가 정렬 + 연결되어 있어 원하는 시작 리프만 찾으면 나머지는 선형 스캔으로 매우 빠르게 조회 가능
	- 예를 들어, 리프를 탐색하다가 범위 검색 시 옆의 리프 노드를 읽어야 되는 경우가 있는데 이 때 바로 가능

---
### 5.3.  B+Tree 정리
B+Tree는 대규모 데이터 환경에서 탐색·삽입·삭제 **모두 O(log N)을 보장**하면서도 가장 비싼 비용인 **디스크 I/O를 최소화하도록 정교하게 설계된** 구조


이 때문에 PostgreSQL, MySQL 등 거의 모든 상용 DB가 인덱스의 기본 설계로 B+Tree를 채택

(PostgreSQL은 B-Tree라고 명시되어 있지만 실제 내부 동작은 B+Tree 식으로 함)