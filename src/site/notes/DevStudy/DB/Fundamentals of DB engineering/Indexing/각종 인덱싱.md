---
{"dg-publish":true,"permalink":"/DevStudy/DB/Fundamentals of DB engineering/Indexing/각종 인덱싱/","noteIcon":"","created":"2025-06-11T16:43:58.650+09:00","updated":"2025-12-07T21:04:02.242+09:00"}
---



## 1.  복합 인덱싱 (Composite Indexing)

### 1.1.  개념 및 특징 
> 두 개  이상의 컬럼을 하나의 Index로 묶어 만든 인뎅스 

ex. **(A,B) : A -> B 순서로 정렬된 B-Tree**를 가진다

| country | age |
| ------- | --- |
| KR      | 20  |
| KR      | 21  |
| KR      | 22  |
| US      | 19  |
| US      | 39  |
| US      | 50  |
- 복합 인덱싱에서 **왼쪽에 위치**한 것이 **최우선 정렬 기준**이다.
- 반드시, 왼쪽부터 순서대로 인덱스를 타야한다.
	- 중간부터 인덱스는 못 탄다.


### 1.2.  예시
```sql
SELECT * FROM user
WHERE country = 'Korea' AND age = 30;
```

country가 범위 좁히기 좋다면
```sql
CREATE INDEX idx_user_counry_age ON user(country, age);
```


>[!tip] 최우선 정렬 기준이 범위를 많이 좁히게 하면 좋다.
>순차적으로 인덱스를 타기 때문에 이래야 빠르게 찾아간다.


## 2.  커버링 인덱스 

> 특화된 복합 인덱스 

### 2.1.  개념 
> 쿼리가 조회하는 모든 컬럼이 인덱스만으로 해결되는 인덱스 

- 즉, 테이블 영역인 Heap/Table 을 읽을 필요가 없다.
- I/O가 불필요해지므로 매우 빠르다.

### 2.2.  예시 
자주 사용되는 쿼리가 아래라면 
```sql
SELECT name, age
FROM user WHERE country = 'KR';
```
다음과 같이 인덱스를 만들면 커버 가능하다
```sql
CREATE INDEX idx_user_country_name_age ON user(country, name, age)
```

쿼리가 필요한 모든 컬럼이 인덱스 안에 존재하기 때문에 테이블 접근이 0회이다.

### 2.3.  언제 좋은가 

1. 고성능 조회 필요 시 
2. Join 시 효율 상승 
	- Join은 양쪽 테이블을 번갈아 읽는 과정이라 비용이 크다.
	- 커버링 인덱스는 Join 키뿐 아니라 SELECT 에 필요한 모든 컬럼을 인덱스에 포함시켜 테이블을 읽는 횟수를 0으로 만들 수 있다.
3. 자주 조회되는 특정 패턴이 있을 때 


> [!WARNING] 그래도 인덱스다. 인덱스의 단점 잊지말기
> 읽기 성능을 높이고 쓰기 성능을 희생함 


## 3.  Unique Index 
> 제약조건을 추가하면 자동으로 생성되는 인덱스

> 보통 PRIMARY KEY를 하면 자동으로 인덱스가 생성이된다.
> 근데, 이거 말고도 UNIQUE를 사용해도 자동으로 인덱스가 생성된다



```SQL
create table test 
(
	id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	name VARCHAR(50) UNIQUE
);                                 
                               

																 Table "public.test"
 Column |         Type          | Collation | Nullable |           Default            
--------+-----------------------+-----------+----------+------------------------------
 id     | integer               |           | not null | generated always as identity
 name   | character varying(50) |           |          | 
Indexes:
    "test_pkey" PRIMARY KEY, btree (id)
    "test_name_key" UNIQUE CONSTRAINT, btree (name)
```
- name 필드에 UNIQUE만 넣었는데 인덱스에 포함되어있다.
- 이유 : Index의 원리를 이용해서 UNIQUE를 사용한다.


> 이런 인덱스를 고유 인덱스(Unique Index)라고 한다.

>[!tip] `UNIQUE`를 사용하면 인덱스 생성 ➡ 조회 성능 굿 Cuz 인덱스는 미리 특정 컬럼을 기준으로 정렬을 시켜놨기에 


