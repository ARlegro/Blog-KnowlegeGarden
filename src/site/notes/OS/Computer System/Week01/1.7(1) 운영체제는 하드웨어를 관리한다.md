---
{"dg-publish":true,"permalink":"/os/computer-system/week01/1-7-1/","noteIcon":"","created":"2025-07-13T13:03:16.452+09:00","updated":"2025-07-13T21:02:43.953+09:00"}
---



> OS가 복잡한 H/W 자원을 효율적으로 제어
> 사용자와 응용프로그램이 H/W를 쉽게 사용할 수 있도록 돕는다 

Next [[OS/Computer System/Week01/1.7(2) 운영체제는 하드웨어를 관리한다\|1.7(2) 운영체제는 하드웨어를 관리한다]]
참고: [[DevStudy/Backend/Java/multi/Multi-Tasking vs Multi-Processing\|Multi-Tasking vs Multi-Processing]]

---
### 운영체제란 ❓
![Pasted image 20250713132028.png](/img/user/supporter/image/Pasted%20image%2020250713132028.png)
```mermaid

flowchart LR 
H/W <--> |OS|사용자
```
- H/W와 사용자(or 응용프로그램) 사이에서 **중개자 역할**을 하는 S/W
- **목적**
	1. **보호**
		- 제멋대로의 응용프로개름들이 H/W를 잘못 사용하는 것을 막기 위해 
		- 자원 공유 시 충돌 방지 + 손상 방지 
		  
	2. **복잡성 추상화** (Like 스프링) ➡ 편의성 제공
		- OS는 **H/W의 복잡성을 숨겨**주고 **일관된 단순한 인터페이스를 제공**
		- H/W는 매우 복잡하며 각 장치마다 작동 방식이 다르다.
		- 추상화 기술은 사용자(or 프로그램)가 H/W장치들을 쉽게 조작할 수 있도록 해줌 

---
## 추상화 3가지 
> OS는 프로세스, 가상 메모리, 파일 을 통해 추상화를 달성했다.

![Pasted image 20250713133447.png](/img/user/supporter/image/Pasted%20image%2020250713133447.png)
> [!INFO] 프로세서 vs 프로세스
> - 프로세서 : 중앙 처리 장치(CPU)
> - 프로세스 : 프로그램의 인스턴스 

---
### 프로세스란❓
- **기본 정의** : 실행 중인 프로그램의 인스턴스 
	- 저장 장치(HDD/SDD)에 있는 프로그램은 단순한 정적 파일이다. 이를 실행하면 OS가 "**프로세스**"로 **인스턴스화**화면서 **동시에 메모리에 적재**한다.
	- 이 과정에서 **OS는 고유한 PID를 할당**하고 **독립적인 실행 공간**(힙, 스택, 코드 등)**을 만든다** 
- **추상화 관점 정의** : 실행 중인 프로그램을 관리하기 위한 운영체제의 추상화 단위
	- 이전 사진에서 볼 수 있듯이, 프로세스는 프로세서(cpu), 메인 메모리, 입출력 장치 등 **다양한 자원의 집합을 사용**하며, **OS는 이를 독립적으로 관리**한다 

>[!QUESTION] 동시 실행 착시 
>- 다수의 프로세서들은 동일한 시스템에서 동시에 실행될 수 있다.
>- 이때 사용자는 각 프로세스가 H/W를 배타적으로 사용하는 것처럼 느낄 것이다.
>- ❌No, 아니다. 대부분 실행 프로세스 수가 CPU숫자보다 더 많을 것이다.(물론 요즘은 멀티코어긴 함)
>	- 즉, 모든 프로세스가 동시에 실행될 수가 없다
>	- 그럼에도 사용자는 동시에 실행되는 것 같은 착각 
>	- ✅이 현상의 이유는 Context Switching(문맥 교환)이다.

>[!EXAMPLE] 참고 - Multi-Tasking : 한 컴퓨턴에서 프로세스가 여러 개 작동하는 것

---
#### Context Switching(문맥 교환)
>[!tip] OS는 H/W관리 및 Context Switching 과정을 추상화하여, 사용자에게는 마치 하나의 프로그램이 컴퓨터의 모든 자원을 독접하는 것처럼 보여진다.

>[!Example] 참고 : OS는 프로세스가 실행하는 데 필요한 "모든 상태정보의 변화를 추적"
>- 상태 정보 = 컨텍스트 
>- 이는, PC, 레지스터 파일, 메인메모리의 현재 값 등을 포함 
---
##### 과정 
1. **현재 프로세스 중단** 
	- 이 과정에서 시스템 콜 등에 의해 **제어권이 OS로** 넘어간다
 	> [!INFO] 시스템 콜이란❓
 	> - 사용자 프로그램이 OS의 기능을 요청하는 것 
 	> - (User Mode ➡ Kernal Mode) 로 전환해 자원을 안전하게 사용 
2. **중단한 프로세스의 Context 저장** 
	- 중단한 프로세스의 현재 상태(Context)를 PCB 메모리에 저장 
	- **PCB** = Process Control Block : OS가 관리하는 데이터 구조 
	- **PCB Memory** in PCB : OS(커널)가 소유하고 있는 메모리 공간

>[!QUESTION] 왜 메인 메모리가 아닌 별도의 PCB Memory구조를 가졌는가❓
>- PCB는 OS가 각 프로세스를 관리하기 위해 **커널 영역의 메모리 공간에 프로세스 정보들을 저장**한다.
>- PCB의 Memory는 사용자 공간(Heap, Stack, Code, Data 등)과는 분리되어 있다.
>- 이는, 보안과 안정성 때문이다
>	- 만약, 어떤 사용자가 메모리에서 다른 프로세스를 사용한다면 보안에 취약한 것이다.
>	- 따라서, PCB Memory라는 사용자가 접근하지 못하는 OS전용 메모리 공간을 두어 프로세스 정보들을 저장한 것 

3. **새 프로세스의 Context 복원** 
	- 이전에 중단되었던(or 새로운) 프로세스의 Context를 PCB 메모리에서 찾고 CPU레지스터로 복원 
	- **제어권 이동** : Kernal ➡ new Process 
	  	  
4. **새 프로세스 실행** 
	- 처음 시작하는 프로세스라면 새 프로세스의 처음부터 실행 
	- 이전에 중단되었다면 CPU는 새 프로세스의 중단 지점부터 다시 실행을 재개 

> [!WARNING] Context Switing은 오버헤드가 존재 
> - 레지스터, 캐시 등의 **상태를 저장/복원하는 데 시간이 필요** 
> - 따라서 빈번한 Context Swtiching은 성능 저하를 유발 



---

#### 커널과 프로세스 관리 

#추가_독립된-공간-할당 

> 프로세스의 관리 및 Context Switching은 주로 OS의 핵심 부분인 커널에 의해 관리된다.

- **커널** :  OS의 핵심 구성 요소(코드의 일부). 항상 메모리에 상주한다.
- **기능**
	- 프로세스 생성 및 삭제 
	- 사스템 콜 처리 
	- 메모리, CPU 자원 관리 
	- 파일 시스템 및 입출력 장치 제어 

- **작동 예시**
	1. 응용프로그램에 의해 요청된 작업을 수행한다. 
	2. 이 때, 응용프로그램은 시스템 콜을 통해 커널에 제어권을 넘겨준다.
	3. 커널은 요청된 작업을 수행하고 그 결과를 응용프로그램으로 반환한다.
		- H/W 자원(가상메모리)을 프로세스별로 적절히 배분 

> [!TIP] CPU는 가상메모리와 달리 쪼갤 수 없어서 각 프로세스가 공유하는 곳 

**추가 역할 : 프로세스의 독립성을 확보** 
- 각 프로세스는 고유의 가상 메모리(Virtual Memory)를 가지는데 이는 OS 커널 덕분이다.
- OS 커널은 요청된 작업을 수행하기 위한 메모리 접근 제어 및 스케쥴링을 통해 프로세스별 독립된 메모리 공간을 사용하도록 해준다. #독립된_공간
- 이렇게 관리를 안해주면 같은 메모리를 다른 프로세스가 공유하게 되어 심각한 버그를 일으킬 수 있다.
- 관리하는 것이 단순히 쉽게 하고 성능을 높이기 위한 것만은 아니라는 것


**Note : 커널은 별도의 프로세스가 아니다**
-  커널은 모든 프로세스를 관리하기 위해 시스템이 이용하는 코드와 자료구조의 집합이다

---

Next [[OS/Computer System/Week01/1.7(2) 운영체제는 하드웨어를 관리한다\|1.7(2) 운영체제는 하드웨어를 관리한다]]