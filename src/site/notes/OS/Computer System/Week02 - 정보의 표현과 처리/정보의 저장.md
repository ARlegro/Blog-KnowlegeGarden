---
{"dg-publish":true,"permalink":"/os/computer-system/week02//","noteIcon":"","created":"2025-07-18T22:32:34.854+09:00","updated":"2025-07-24T00:04:49.624+09:00"}
---


현대의 컴퓨터는 이진수인 비트로 표현되는 정보를 저장하고 처리한다.
비트는 디지털 혁명 수준이다.

비트 하나만 따로 분리해서 생각하면 그다지 좋지는 않다.
하지만 **비트들을 묶어서 비트 패턴에 의미를 부여하도록 특정 해석방법 적용 시 유의미한 원소들을 표시할 수 있다.**

### 3가지 인코딩
#### 1. 비부호형 인코딩 
> 가장 기본적인 정수 인코딩 방식 
- 모든 비트를 오직 숫자의 크기를 나타내는 데 사용하며, 
- 음수를 표현하지 않는다.(항상 0이상의 양수)
- **범위** : `0 ~ 2**n - 1` 
	- ex. 8비트 비부호형 ➡ 0부터 `2**8 - 1` 까지의 값을 표현 가능 
- ✅**장점**
	- 구현이 간단하고 직관적
	- 가장 넒은 양의 정수 범위를 가짐 
- 💢**단점**
	- 음수 표현 불가 
- **용도**
	- 메모리 주소, 이미지 픽셀 값, 개수, 크기 등 **항상 양의 값만 가지는 데이터 표현 시** 

#### 2. 2의 보수 인코딩 
> **가장 많이 사용**되는 **부호(+, -) 있는 정수 인코딩** 방식
- 양수와 음수를 모두 효율적으로 표현할 수 있다.
- 음수가 있으므로 덧셈만 있어도 뺄셈까지 처리가 가능하다 
- **원리** 
	- **최상위 비트**(MSB)를 부호 전용 비트로 사용 
	- 음수 표현 시 2의 보수를 구한다. (구하는 과정은 아래와 같다)
		- 원래 숫자의 모든 비트를 뒤집는다.
		- 그 값에 1을 더한다
	- 예시 - `-5`의 2의 보수 계산 (4비트 기준):
	    1. `5`의 2진수: `0101`
	    2. 모든 비트 뒤집기 (1의 보수): `1010`
	    3. 1 더하기: `1010 + 1 = 1011`
	    - `1011`은 4비트 2의 보수 인코딩에서 `-5`를 나타낸다

- **표현 범위** : `-2**(n-1)` ~ `2**(n-1) - 1`
- 양수를 표현할 수 있지만 비부호형 인코딩보다 표현할 수 있는 양수의 최대값이 절반으로 줄어든다.
- 사용되는 곳 : `int`, `short`, `long` 등 
  
#### 3. 부동소수점 인코딩 
> 실수를 컴퓨터에서 표현하기 위한 방식 




>[!tip] 똑같은 숫자 12345를 인코딩하더라도 부동소수점/정수인코딩의 바이트 패턴이 다를 것이다.

--- 

양수들 간의 곱은 항상 양수이지만, 오버플로우인 경우에는 특별한 값을 만들어낸다.

부동소수점 연산은 수의 제한된 정밀도 때문에 교환법칙이 성립하지 않는다.

컴픁터는 숫자를 인코딩하기 위해 여러 가지 이진수 표시를 사용 


### 1. 이진 데이터 - 바이트 순서 
> 여러 바이트로 이루어진 객체들을 저장하는 2가지 습관이 있다 .

**엔디안 = 바이트 순서** 

#엔디안 
#### 엔디안이란? 
1. **리틀엔디안** 
	- 가장 덜 중요한 바이트를 메모리에 먼저 넣는 관습 
	- 대부분의 Intel CPU에서 사용하는 방식이다
	  
2. **빅 엔디안**
	- 가장 중요한 바이트를 메모리에 먼저 넣는 관습 
	- 대부분의 IBM, Oracle 머신들이 이렇게 동작 

 **예시: `0x12345678`의 저장 방식**

| 바이트 순서 | Little Endian (일반적) | Big Endian |
| ------ | ------------------- | ---------- |
| `c[0]` | `0x78`              | `0x12`     |
| `c[1]` | `0x56`              | `0x34`     |
| `c[2]` | `0x34`              | `0x56`     |
| `c[3]` | `0x12`              | `0x78`     |

#### 엔디안 불일치로 문제가 되는 상황들
두 방법 모두 큰 문제는 없다.
근데 몇 가지 상황에서는 문제가 된다

> 실제 비트 배열 방식 vs 이를 해석하는 방식 ➡ 불일치 

#### 1. 네트워크 통신 - 이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때 

>[!danger] 문제 
>- 송신측이 네트워크를 통해 특정 값을 전송했는데 수신측이 이를 받아서 해석할 때 **바이트 순서가 뒤바뀌어버리고 해석 됨** 
>- **예를 들어,** 
>	- 리틀 엔디안(송신) : 0x12345678 이라는 4바이트 정수를 메모리에 78 56 32 12 순서로 저장
>	- 빅 엔디안(수신) : 순서대로 받아서 자신의 메모리에 78 56 32 12로 저장 -> 
>	- 💢**문제** : 빅 엔디안은 이를 0x78573412로 해석하여 **원래 값과 완전 다른 값** 

- **해결책** 
	- 네트워크 통신에서 "**네트워크 바이트 순서**"라는 표준을 정해둠 
	- TCP/IP 프로토콜은 모든 통신이 "빅 엔디안"방식을 따르도록 강제 
	- **방식** 
		- 데이터 보내기 전 : 호스트(송신측)의 바이트 순서를 네트워크 순서로 변환 
		- 데이터 받을 때 : 네트워크 바이트 순서를 호스트(수신측) 바이트 순서로 변환 
		- 이 과정을 거침 

#### 2. 정수 데이터를 나타내는 바이트들을 살펴볼 때 

 >[!tip] 시스템 디버깅 or 역공학, 포렌식 분석 등 매우 낮은 수준에서 데이터를 직접 다룰 때 중요

 >[!danger] 문제
 >- (컴퓨터가 아닌) **사람이 직접 메모리 내용을 들여다보거나** 메모리 덤프같은 이진 파일의 내용을 Hex Editor 등으로 **분석할 때 발생** 
 >- 예를 들어, 메모리 덤프를 보고 디버깅을 하려고 하는데 다른 엔디안으로 **착각해서 잘못 해석할 수** 있다.

   >[!Question] 메모리 덤프란 ❓
  	> - 특정 시점의 RAM의 내용을 그대로 저장한 데이터 파일 or 행위  
  	> - 일종의 **스냅샷**, 메모리의 상태(값, 포이터, 코드 등)를 그대로 기록 


#### 3. 프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때 

>[!danger] 문제 
>- **타입 안정성(Type Safety)을 의도적으로 우회**하여 **메모리의 바이트들을 다른 타입으로 강제로 해석하려고 할 때** 발생  
>- C언어에서는 `pointer casting` or `union`을 사용하여 **특정 데이터 타입의 값을 바이트 배열처럼 접근하는 경우**에 이런 문제가 발생한다.
>- ❗실행되는 코드 자체에 버그를 일으키기에 조심해야 함 
>- 보통 최적화, 인터페이스 개발 시 이런 문제 

C언어 예시 
```C
#include <stdio.h>

int main() {
		# ✅union
    union {
        int i;         // 4바이트 정수
        char c[4];     // 1바이트 문자 배열
    } data;

    data.i = 0x12345678; // 정수 0x12345678을 data.i에 저장 ➡ 4바이트로 저장됨 
    printf("Integer value: 0x%X\n", data.i); // 0x12345678

    printf("Bytes in memory: 0x%X 0x%X 0x%X 0x%X\n",
           (unsigned char)data.c[0], (unsigned char)data.c[1],
           (unsigned char)data.c[2], (unsigned char)data.c[3]);
           # 0 ~ 3 인덱스 값이 다른 결과로 저장되어 있을 수도 

    return 0;
}
```

`uinion`
- **하나의 메모리 공간을 여러 멤버 및 변수 타입이 공유**하는 구조 
- 위의 예시에서 `data`는 두 타입을 가짐 
	- `int i` ➡ 4바이트 정수
	- `char c[4]` ➡ 1바이트 문자 4개 
	- 이 둘은 **같은 메모리 공간을 겹쳐서 사용**한다

`(unsigned char)data.c[?]`
- 테스트 : `data.c[i]`를 하나씩 출력함으로써 바이트 단위로 메모리 접근을 해보는 것
- `unsigned` : 부호가 없는 정수 
- `unsigned char` : 0~255 범위의 1바이트(8bit) 정수형 데이터 타입 

> data에 저장이 될 때 생각과 다른 순서로 저장될 수 있다.


포인터 캐스팅은 컴파일러 타입 검사를 우회할 수 있지만 고려해야될 것이 많아짐 

--- 
### 포인터 참고 링크 
[[OS/Computer System/Week02 - 정보의 표현과 처리/C초보자 코너\|C초보자 코너]] - 포인터 

--- 
### 스트링의 표시 

C에서 String은 null(값 0을 갖는) 문자로 종료하는 문자열로 인코딩된다.
각 문자는 표준 인코딩에 따라 표시되며 가장 일반적인 인코딩은 ASCII 문자코드이다.

ASCII를 문자코드로 사용하는 모든 컴퓨터에서는 바이트 순서나 워드 크기와 무관하게 똑같은 문자열을 얻을 수 있다.
>[!tip] 즉, String은 플랫폼 독립적이다 unlike 이진 데이터 

--- 
### 이진코드가 컴퓨터마다 다른 이유 
#코드의_표시  #이식성 

아래의 코드를 다양한 환경에서 컴퓨터에서 컴파일하면 다른 기계어 코드를 생성한다.
```C
int sum(int x, int y){
	return x + y;
}
```
Linux 32 : 55 89 ~~~ c9 c3
Windows  : 55 89 ~~~ 5d c3
Linux 64 : 55 48 89 e5 89 ~~~ c9 c3 
➡ 인스트럭션들의 인코딩이 환경마다 모두 다르다 

>[!QUESTION] 왜 그럴까❓

#### 1. ISA (Intruction Set Architecture)의 차이 
>[!QUESTION] ISA란❓
>- **CPU가 이해하고 실행할 수 있는 명령어들의 집합**과 그 명령어를 **인코딩하는 방식**과
>- **레지스터 구조 등을 정의**하는 **H/W-S/W 인터페이스**이다.
>  > 컴퓨터마다 **사용하는 CPU의 종류가 다르면 ISA도 다르다** ❗❗
- 똑같은 `add`명령어라도 CPU가 다르면 표현하는 방식도 다르다 
- 위의 코드 중 `sum` 함수를 예시로 보면 내부적으로 `add`명령어를 수행할텐데 이 명령어가 **CPU마다 다르게 인코딩되기 때문에 기계어 코드가 달라지는 것**이다.

#### 2. 비트 수의 차이 (32bit vs 64bit)
- 똑같은 ISA라도 32bit 환경과 64bit 환경은 매우 다르다
- **레지스터 종류가 달라짐** 
	- 비트 시스템마다 다른 레지스터를 사용한다.
	- **레지스터가 다르면 명령어 인코딩도 달라짐** 
	- Note : 레지스터란 ❓ [[OS/Computer System/Week01 - 컴퓨터 시스템으로의 여행/1.4 프로세서(CPU)는 메모리에 저장된 인스트럭션(명령어)을 읽고 해석한다\|1.4 프로세서(CPU)는 메모리에 저장된 인스트럭션(명령어)을 읽고 해석한다]]
- **메모리 주소 공간도 달라짐**
	- 64bit에서는 훨씬 더 큰 메모리 주소 공간을 가질 수 있다.
	- 이에 따라 **포인터나 주소 연산 방식도 달라짐**
- 그 외에도 **함수 호출 규약의 차이** 등이 있다 



#### 3. OS의 ABI의 차이 
> OS가 다르면 ABI도 달라진다 ➡ 기계어 코드가 달라짐 

>[!QUESTION] ABI란❓ 
>- Application Binary Interface
>- **바이너리 수준에서 어떻게 상호작용할지에 대한 표준**이다.
>- Between 
>	- CPU아키텍쳐 ↔ OS   
>	- 프로그램 모듈 ↔프로그램 모듈 

- OS마다 호출 규약이 다르다 ➡ 인자 전달 방식, 레지스터 사용 규칙 등이 OS마다 다르다 
- OS마다 시스템 콜 방식이 다르다 ➡ 이 차이가 기계어 코드에 반영될 것 
- OS마다 실행 파일 포맷이 다르다 ➡ 메모리에 로드하는 방식이 달라진다. 

#### 4. 컴파일러 차이 

> 같은 OS, ISA라도 어떤 컴파일러를 사용했는지에 따라 생성되는 기계어 코드가 달라질 수 있다.



### Boolean 대수
> C에서는 비트들 간의 Boolean 연산을 지원한다

> **회로 설계 시 이점** 
> - Boolean 대수를 사용하여 **복잡한 논리 회로의 동적을 수학적으로 표현**하고, 이를 **최적화**하여 더 적은 수의 게이트로 동일한 기능을 구현 가능 ➡ 칩의 크기 줄이고 속도 높이고 전력 소모 줄임 
> - 컴퓨터의 모든 디지털 회로는 논리 게이트라는 기본적인 전자 회로들로 구성된다. 근데 회로들 중 AND 게이트, OR 게이트, NOT 게이트 등이 전부 Boolean 대수의 기본 연산을 물리적으로 구현한 것이다.

#### 부울대수와 부울링 

Boolean

#### 비트 백터 
> Boolean 값의 시퀀스 or 집합을 효율적으로 사용되는 자료구조이다.
- 각 비트가 하나의 독립적인 Boolean 값 or 플래그를 의미
- 이 비트들은 일반적으로 하나의 정수형 변수(int, long) or 정수형 배열에 압축되어 저장된다.
- **장점**
	- **공간 효율성** : 최대한 적은 바이트에 압축하여 저장 
	- **시간 효율성** : 비트 연산은 CPU에서 직접 처리되므로 매우 빠르다.
	- **간결한 코드**  
- 예를 들어 32개의 Boolean값 저장 시 
	- 기존 : 32 boolean 변수를 사용해야 했음 ➡ 32 바이트 사용 
	- 비트 벡터 사용 시 : 하나의 int(4Byte)변수에 모두 저장할 수 있다. ➡ 4바이트만 사용 
- **활용 예시**
	- 알고리즘 : 문제 해결에 비트의 논리를 적용하는 사고방식으로 문제 해결 가능 
	- OS 및 임베디드 
	- 네트워크 프로토콜 등 
### C에서의 비트수준 연산 - |, &, ^, ~, >>, <<

> 비트 자리별로 비교한다.

- **비트 AND (`&`)**
	- 두 피연산자의 해당 비트가 모두 1일 때만 결과 비트가 1 
	- **5 & 3** ➡ 5(010**1**) & 3(001**1**) ➡ 0001 ➡ **1** 
- **비트 OR (`|`)**
	- 두 피연산자의 해당 비트 중 하나라도 1이면 결과 비트가 1 
	- **5 | 3** ➡ 5(0101) | 3(0011)  ➡ 0111 ➡ **7**
- **비트 NOT (`~`)**
	- 피연산자의 모든 비트를 뒤집는다 
	- 주의 : ~ 연산은 2의 보수 표현땜에 예상과 다르게 음수를 반환할 수 있음  
- **비트 XOR(`^`)** - EXCURSIE-OR 
	- 두 피연산자의 **해당 비트가 서로 다를 때만 결과 비트가 1** 
	- **5 ^ 3** ➡ 5(0101) ^ 3(0011)  ➡ 0110 ➡ **6**

	```C
	#include <stdio.h>
	
	int main() {
	    int a = 5;   // 0101
	    int b = 3;   // 0011
	    int result = a ^ b;
	    printf("%d\n", result); // 6 (0110)
	    return 0;
	}
	```

### C에서의 논리 연산 - ||, &&, ! 

**✅개념** 
- C에서도 다른 언어처럼 논리 연산 OR, AND, NOT에 해당하는 **논리연산자인 `||`, `&&`. `!` 를 제공**한다
- 이 연산자들은 **참/거짓 여부를 판단**하며, 그 결과로 1 or 0을 반환한다
- 이러한 논리 연산은 비트수준 연산과 혼동될 수 있다. 둘의 동적은 전혀 다르다
	- 논리 연산은 0이 아닌 인자들을 전부 참으로 취급 
	- 인자들이 0 or 1로 제한되는 특별한 경우에만 비트단위 연산과 이에 대응하는 논리 연산이 동일한 동작을 한다 

>[!WARNING]  **비트** 단위 연산자는 **단축 평가를 하지 않는다**❗항상 모든 피연산자를 평가 

**☑특징 - 단축 평가**
- 논리 연산 수행시 표현식의 **결과가 이미 확정되면 더 이상 연산을 진행하지 않고 결과를 반환**한다 
- ex. a && b, a || b ➡ 첫 번째 인자로 계산이 결정될 수 있으면 두 번째 인자는 계산하지 않아도 된다.

### C에서의 쉬프트 연산 
> 쉬프트 연산 : 정수형 데이터의 비트 패턴을 좌우로 이동시키는 쉬프트 연산

#### 1. 좌측 쉬프트 - `X << K`
- **동작 방식**
	- **X의 비트들을 왼쪽으로 K칸 이동**시키고 **비워지는** 가장 오른쪽 K개의 **비트들은 0으로 채워짐**
	- 좌측 쉬프트는 부호 비트 상관없이 항상 우측이 0으로 채워짐 
- 효과 : 양수일 경우 `X`에 2^k 를 곱하는 것과 동일한 효과 
- 예시 : `int x = 5 (0101)`
	- `x << 2` ➡ 10100 ➡ 20 ( 5의 4배 )


#### 2. 우측 쉬프트 - `X >> K`
- **동작 방식**
	- `X`의 비트들을 **오른쪽으로 K칸 이동**시키고
	- **비워지는** 가장 왼쪽 K개의 비트들은 **쉬프트 종류에 따라 2가지 종류로** 나뉜다.

- **효과** : 양수의 경우, `X`를 `2^K` 로 나누는 것과 동일한 효과 

- **우측 쉬프트 종류**
	1. **논리 우측 쉬프트**
		- 비트를 오른쪽으로 옮길 때, 비워지는 **가장 왼쪽 K개의 비트들을 항상 0으로** 채운다
		- **언제 사용**❓ 주로 부호 없는 정수에 대해 사용 
		  
	2. **산술 우측 쉬프트** 
		- 비트를 이동시킬 때, 비워지는 가장 왼쪽 K개의 비트들을 최상위 비트와 같은 값으로 채운다
		- 최상위 비트는 숫자의 부호를 나타내는데(음수면 1) 이 숫자로 채우면 된다
		- **언제 사용**❓ 주로 부호 있는 정수에서 사용 
	
비부호형 데이터 ➡ 논리 우측 쉬프트를 사용
부호형 데이터 ➡ 산술 우측 쉬프트를 사용

음수에 논리 우측 쉬프트를 적용하면 완전 다른 수가 되어벼리기에 이상함 

>[!EXAMPLE] 참고 : 쉬프트 연산보다 덧셈이 높은 우선 순위를 가진다
>- 1 << 2 + 3<< 4  == 1 << (2 + 3) << 4 

