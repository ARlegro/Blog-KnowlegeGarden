---
{"dg-publish":true,"permalink":"/os/computer-system/week02/data-representation/","noteIcon":"","created":"2025-07-22T23:21:01.151+09:00","updated":"2025-07-24T00:19:03.981+09:00"}
---

> 정보의 표시 

이 섹션에서는 비트(bit)를 사용하여 정수를 인코딩(Encoding)하는 2가지 방법을 설명할 것이다.
1. 0 or 양수만 표현할 수 있는 방식
2. 음수, 0, 양수 모두 표현할 수 있는 방식 

### 정수 데이터 타입 

- **C언어는 다양한 정수 데이터 타입을 지원**한다.
- 예를 들어
	- char
	- short
	- long
	- unsigned : 부호 없는 정수형(0 or 양수)  ex. `unsigned int x = 10`
	- signed : 부호 있는 정수형. (생략 가능 ❗)
	- 음수 포함 여부도 설정 가능 

>[!tip] unsigned를 쓰는 이유 - 더 넓은 양수 범위를 쓰기 위해 
>- 아래의 표는 프로그램에서 각 타입이 가질 수 있는 값의 범위를 보여준다.
>- 자세히 보면 똑같은 타입인데도 **unsigned가 붙으면 최대값이 커진다**
>- unsigned를 쓰면 음수 표현에 쓸 비트를 양수에 쓰는 것???
>- | C 데이터 타입         | 최소값 (Minimum)              | 최대값 (Maximum)              |
| ---------------- | -------------------------- | -------------------------- |
| `[signed] char`  | -128                       | 127                        |
| `unsigned char`  | 0                          | 255                        |
| `short`          | -32,768                    | 32,767                     |
| `unsigned short` | 0                          | 65,535                     |
| `int`            | -2,147,483,648             | 2,147,483,647              |
| `unsigned`       | 0                          | 4,294,967,295              |
| `long` (32비트)    | -2,147,483,648             | 2,147,483,647              |
| `unsigned long`  | 0                          | 4,294,967,295              |
| `long` (64비트)    | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| `unsigned long`  | 0                          | 18,446,744,073,709,551,615 |
| `int32_t`        | -2,147,483,648             | 2,147,483,647              |
| `uint32_t`       | 0                          | 4,294,967,295              |
| `int64_t`        | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| `uint64_t`       | 0                          | 18,446,744,073,709,551,615 |

>[!EXAMPLE] unsigned를 쓰는 대표적 상황
>주로 양수만 표현해야 할 때 쓰인다
> 1. **배열 인덱스** : 인덱스는 음수가 될 수 없기에 
> 2. **길이/크기 관련된 데이터** 
> 3. **비트 연산** : 비트는 0 or 1이다. 즉, 음수가 될 수 없다.
> 4. **하드웨어/레지스터? 등** 


>[!EXAMPLE] 특이점 - signed 타입의 음수개수가 양수개수보다 1 크다 
>- 0을 포함하는데 쓰이기 때문 

```yaml
0000 0000 → 0
...
0111 1111 → 127

1000 0000 → -128  ⬅ 가장 작은 음수
...
1111 1111 → -1
```
- 8비트 기준으로 총 표현 가능 조합은 2^8 = 256이다. 
- 근데 0을 빼면 255
- 일단, **맨 앞 비트는 부호를 결정하는 비트**이다. 
- ⭐127을 비트로 표현하면 0111 1111 인데 여기서 + 1 한다면❓1000 0000 이 된다.
- 근데, 1000 0000 은 맨 앞 비트가 1로 음수를 뜻한다. 이는 -128을 의미
- **따라서, `sighned char = 128` 을 하면 char는 사실 -128 로 찍힌다.**
- 이러한 현상으 **'오버플로우'** 라고 함 
- 이렇게 되는 원리가 **2의 보수체계가 원형 시계 같은 구조**이기 떄문 


### 비부호형의 인코딩 

>[!tip] 비부호형의 이진수 표시는 0 ~ (2^n-1) 사이의 모든 숫자가 **w비트 값으로 유일한 인코딩**을 갖는다 ➡ 비부호형 인코딩의 유일성

#### 비트 벡터 
>[!EXAMPLE] 참고 - 비트백터란 ❓
>- 정의 
>	- 0 과 1로 이루어진 고정 길이의 배열
>	- 단순히 **여러 개의 비트를 순서대로 나열한 것**을 의미
>- `x = [1, 0, 1, 1`] ⬅ 4비트 짜리 벡터 
>- 일반 인덱스와 달리 **x = [x(w-1), x(w-2), ..., x1, x0]** 로 표시한다. 그 후부터는 `x = [x(w-1), x(w-2), ..., x1, x0]`

w비트의 정수형 데이

#### B2U₍w₎(x) 함수 

> B 2 U = Binary to Unsigned = 바이너리데이터를 unsigned로 바꾼다 
> 즉, **비트 벡터 x를 부호 없는 정수로 바꾼다**는 뜻 

- $x_i$ = 1 이면 $2^i$ 를 더한다는 뜻
- $x_i$ = 0 이면 더하지 않는다.
- `x = [1, 0, 1, 0]
	- $x_0$ = 0 ➡ 더하지 않는다
	- $x_1$ = 1 ➡ $2^1$ = 2를 더한다
	- $x_2$ = 0 ➡ 더하지 않는다
	- $x_3$ = 1 ➡ $2^3$ = 8을 더한다
	- 총 값 = 2 + 8 = 10


Note : `w`비트로 표현 가능한 부호 없는 정수 범위 = 0 ~ ($2^n$ - 1)


### 2의 보수 인코딩 

**보통 맨 앞 비트는 가장 중요한 비트(MSB)** 이다.
2의 보수 형식은 이 MSB를 음수 자리라는 것을 해석하는 형태로 정의된다.
참고로, 여기서 쓰이는 MSB를 '**부호 비트**'라고도 불린다
#### B2T₍w₎(비트벡터)
> B2T = Binary To Two's complement = 바이너리 to 2의 보수 


B2T₍w₎의 예시이다
![Pasted image 20250723001349.png](/img/user/supporter/image/Pasted%20image%2020250723001349.png)
- 사진을 보면 음수 표현 시 맨 앞 비트값이 음수가 되었다.
- 그럼에도 그 뒷부분의 비트는 전부 양수로 표현 
- 따라서 
	- 1111 1111 ➡ -128 + 64 + 32 + 16 + ... + 1 = - 1 
	- 1000 0000 ➡ -128 + 0 = - 128
	- -128 - 1 = `1000 0000 + 1111 1111` = `0111 1111` = 127 

--- 
### 고정 크기 정수형 
> 일부 프로그램에서는 데이터 타입이 **특정 크기로 인코딩되는 것이 매우 중요**

#### 문제 발생 
-  `int`, `long`, `shot`는 크기가 고정되어 있지 않다💢
- 이런 데이터 타입은 컴파일러/OS/CPU에 따라 다르게 비트가 정해진다.
- 이렇게 값의 저장 범위가 달라지는 현상은 **프로그램의 이식성을 떨어뜨린다**

--- 
#### 그래서 나온 해결책 : stdint.h 

위의 문제를 해결하기 위해 ISO C99 표준에서 `stdint.h`라는 **헤더 파일**을 만들어서 **비트 크기의 명확한 타입을 제공**했다 
```c
#include <stdint.h>
```

이 파일 안에 타입들은 아래와 같은 타입들이 있고, 각 타입은 컴퓨터가 바뀌어도 고정된 크기의 바이트를 제공한다

| 타입 이름      | 뜻                      | 예시               |
| ---------- | ---------------------- | ---------------- |
| `int8_t`   | 정확히 **8비트 signed 정수**  | -128 ~ 127       |
| `uint8_t`  | 정확히 *8비트 unsigned 정수** | 0 ~ 255          |
| `int16_t`  | 16비트 signed 정수         | -32,768 ~ 32,767 |
| `uint16_t` | 16비트 unsigned 정수       | 0 ~ 65,535       |
| `int32_t`  | 32비트 signed 정수         | -21억 ~ 21억       |
| `uint32_t` | 32비트 unsigned 정수       | 0 ~ 42억          |
| `int64_t`  | 64비트 signed 정수         | 어마어마히 큼          |
| `uint64_t` | 64비트 unsigned 정수       | 더 큼              |

**✅ 고정된 크기 선언 예시** 
```c 
// 이렇게 고정된 크기(비트)를 설정할 수 있음 cuz stdint.h
int32_t a = 100; // 32bit(4byte) 정수
uint16_t b = 5000; // 16bit(2byte) 정수

// 출력시에도 다른 형식 메크로 필요 
printf("a = %" PRId32 ", b = %" PRIu64 "\n", a, b);

```

**✅ 내장된 메크로 사용 예시** 
```c
#include <stdint.h>
#include <stdio.h>
#include <inttypes.h>
int main(){
  printf("%d\n", INT32_MAX); // 2147483647
  // long or long long
  printf("%" PRId64 "\n", INT64_MAX); // 9223372036854775807
  printf("%d\n", INT32_MIN); // -2147483648
  // long or long long
  printf("%" PRId64 "\n", INT64_MIN); // -9223372036854775808
  return 0;
}
```

--- 

### 부호 있는 숫자의 대체 표현 (1의 보수)

> 여태까지 부호 있는 수를 '2의 보수'로 표현했다. But 다른 표준 표현 방식도 있다. 그것이 바로 **'1의 보수'** 표현 방식이다. 
> - 2의 보수 : 현대 컴퓨터들 방식
> - 1의 보수 : 옛날 컴퓨터들 방식 

>[!danger] 현대에는 거의 안씀 

#### 만드는 법


![Pasted image 20250723084636.png](/img/user/supporter/image/Pasted%20image%2020250723084636.png)
- 최상위 비트가 2의 보수와 **다른 가중치를 가진다**
	- **1의 보수 : $-x_{w-1}(2^{w-1} - 1)$**
	- 2의 보수 : $-2^{w-1}$
- 나머지 비트는 일반 2진수처럼 해석한다
- 0도 부호가 있다 ex. -0 or +0
	- +0 = `[0000]`
	- -0 = `[1111]`



#### 2의 보수 ➡ 1의 보수 
> 비트를 모두 반전 

| 값   | 이진수 (4비트) |
| --- | --------- |
| +5  | `0101`    |
| -5  | `1010`    |
| +0  | `0000`    |
| -0  | `1111`    |
- 5는 기본 2진수 표현으로 바꾸면 `0101`이다
- -5를 표현하려면 이제 5의 **비트를 그냥 뒤집으면 된다.**
- 심지어 **-0 도 표현이 가능**하다

### 비후호형과 부호형간의 변환 

C언어에서는 다양한 숫자 데이터 타입 간의 캐스팅(형 변환)을 허용한다. 예를 들어, 
```c
// 기존 
int x

// 변환 
(unsigned) x  //✅x의 값이 부호 없는 값으로 변환 


// 기존 
unsigned u

// 변환 
(int) u // 부호 있는 정수로 변환 
```


캐스팅의 효과 = 비트 값은 동일하게 유지 But 비트 해석방식이 변경된다.

#### (부호 있는 정수 ➡ 부호 없는 정수) 시 일어나는 일 
>[!QUESTION] 부호 있는 정수(signed int)를 부호 없는 정수(unsigned int)로 캐스팅하면 실제로 어떤 일이 일어날까❓

**Note : short int = short** 

```c
short int v = -12345
unsigned short uv = (unsigned short) v // ✅ 타입 캐스팅
print("v = %d, uv = %u\n", v, uv)
// V = -12345, UV = 53191
```
- `short int`와 `unsigned short`는 2Byte(16비트) 정수이다.
- v는 음수가 가능하지만 uv는 양수만 저장이 가능한 상태이다.
- **음수 v를 unsigned short로 캐스팅** 
	- 캐스팅 전 v는 `[11001111 11000111]`= `0xCFC7` 비트로 메모리에 저장되어 있었다.
	- 이 상태에서 (unsigned short)로 캐스팅하면 **C언어는 비트를 그대로 놨둔 다음에 해석**한다.
	- 즉, **비트는 그대로 유지**하고, 단지 해석 시 **부호 없는 수로 해석**한다는 것이다
	- `[11001111 11000111]`= `0xCFC7`  ➡ 부호 없는 수로 해석 시 53191

>[!tip] 비트는 그대로 유지, But 해석 방식만 unsigned로 
>- 숫자는 변하지만 비트는 변하지 않는다


#### 연습 문제 풀이 
> x 가 주어질 때, 이 x를 함수 $T2U_4(x)$를 사용한다면 어떻게 해석되는가❓

*$T2U_4(x)$* = Two's complement to Unsigned ➡ 4비트의 2의 보수 표현을 부호 없는 정수로 변환
![Pasted image 20250723100049.png](/img/user/supporter/image/Pasted%20image%2020250723100049.png)

| x   | 2의 보수일 때  | $T2U_4(x)$ |
| --- | --------- | ---------- |
| -1  | $1111_2$  | 15         |
| -5  | $1011_2$  | 11         |
| -6  | $1010_2$  | 10         |
| -4  | $1100_2$  | 12         |
| 1   | $0001_2$  | 1          |
| 8   | ❌4비트 범위 밖 | ❌4비트 범위 밖  |
- 특징 1. 양수를 unsigned로 바꾸면 값이 변하지 않는다.
- 특징 2. **음수를 unsigned로 바꾸면** 단순히 그 **음수에 $2^w$ 를 더한 값**이 된다 ⭐⭐

>[!tip] 특징 2는 이전에 언급했던 MBS의 가중치의 차이를 볼 수 있는 특징이다
>- 2의 보수에서는 MBS가 $-2^(w-1)$이였다면
>- unsigned에서는 MBS가 그냥 값 $+$2^(w-1)$이다.
>- 따라서, MBS가 음수여서 뺴줬던거를 2번 더하면($+2^{w-1}$)) 그게 unsigned 


#### (비부호형 ➡ 부호형)
> unsigned에서 2의 보수로의 변환 시 일어나는 일 

![Pasted image 20250723100923.png](/img/user/supporter/image/Pasted%20image%2020250723100923.png)
- 부호 없는 값 `u`를 2의 보수(signed)형으로 해석할 때
- u가 작으면 : 그 값 그대로 signed 값
- u가 범위 초과 시 : u에 $2^w$ 을 빼서 음수로 해석한다
- Note : $TMax_w$ = 2의 보수 signed 정수의 최대값 



#### 결론 

>[!tip] 캐스팅이나 변환 시 비트는 그대로!!! (해석만 다르게)



### C에서의 부호형과 비후호형의 비교

#### 개념 및 연습문제 
>[!tip] signed 값이 unsinged 갑소가 섞이면 ➡ C에서는 **전부 unsigned로 바꿔서 계산**

**연습 문제** 
Q. 2의 보수를 사용하는 머신에서 32비트 프로그램을 실행해서 수식을 들 계산한다고 가정할 때 아래의 표를 완성하고 캐스팅과 관계연산의 효과를 설명하시요 


| 표현                           | Typte                            | Evaluation                                 |
| ---------------------------- | -------------------------------- | ------------------------------------------ |
| -2147483647-1 == 2147483648U | int == unsigned ➡ **unsigned**   | ✅**True**                                  |
| -2147483647-1 < 2147483647   | 둘다 int ➡ **signed**              | ✅**True**                                  |
| -2147483647-1U < 2147483647  | unsigned < int ➡ **unsigned**    | ❌False <br>214748364**9**U < 2147483647U   |
| -2147483647-1 < -2147483647  | 둘다 int ➡ **signed**              | ✅**True**                                  |
| -2147483647-1U < -2147483647 | unsigned < signed ➡ **unsigned** | ✅**True**<br>2,147,483,648 < 2,147,483,649 |




#### 명시적 + 묵시적 형변환 

> C에서는 비부호형과 부호형 간의 형 변환을 허용한다

**✅명시적 형 변환** 
```C
int tx, ty;
unsigned ux, uy;
 
tx = (int) ux
uy = (unsigned) ty;
```


✅묵시적 형 변환 
```c
```C
int tx, ty;
unsigned ux, uy;
 
tx = ux  // signed로 묵시적 캐스팅 
uy = ty; // unsigned로 묵시적 캐스팅 
```



### 숫자의 비트 표현 - 확장 

>[!QUESTION] 작은 비트의 정수를 큰 비트로 변환할 때 어떻게 해야할까❓

예를 들어 16비트 `short` ➡ 32비트 `int` 로 바꾼다고 가정하자
```c
short x = -12345; // 1100 1111 1100 0111
int y = x; 
```
- 16비트의 수가 32비트로 표현되어야 한다
- 이때, **빈 앞자리 비트들을 뭘로 채울지 결정하는 룰**이 必
- 이 룰에는 2가지 방법이 있다
#### 확장 방법 1. Zero Extenstion
#0의확장

- **언제 사용하는가**? `unsigned` 타입일 때 사용 
- **방식은**? 앞자리를 0으로 채움 

```c
short x = -12345; // 1100 1111 1100 0111
int y = x;  // 0000 0000 0000 0000 1100 1111 1100 0111
```
#### 확장 방법 2. Sign extenstion

- **언제 사용하는가?** `signed`타입일 때 사용 
- **방식은?** 최상위 비트(MSB)를 복사해서 채운다
```c
short x = -12345; // 1100 1111 1100 0111
int y = x;  // 1111 1111 1111 1111 1100 1111 1100 0111
//✅ 음수니까 1로채워
```
- 이렇게 복사해도 되는 이유 ➡ **2의 보수 인코딩의 특별한 구조 덕분**


#### signed ➡ unsigned 시 완전히 다른 결과 조심 💢

일반적으로 -12345를 unsigned로 표시하면 53191이다. But 아래의 코드를 보면 4294954951로 나온다. 이유가 뭘까❓
```c
short sx = -12345;
unsigned uy = sx;
// uy = 4294954951
```
- C에서는 **`unsinge uy`는 내부적으로 `(unsigned)((int) sx)`로 처리**된다.
- 즉, **먼저 signed로 확장**한 **다음에 unsigned로 바꿔지는 것**이다.
- 여기서는 (int) sx 로 앞에 1이 채워진 다음에 그 상태에서 unsigned 캐스팅이 되는 것 
>[!tip] C 표준 - 모든 연산 전에 작은 타입들(short, char)은 int로 승격시킨다.
>- 예전에는 H/W가 int중심이라 short가 성능이 불리해서 연산 시에는 int가 유리했다. 따라서 C를 처음 만들 때, **연산시에는 자동으로 묵시적 int 형변환**을 약속했던 것 
>- 따라서, 위의 예시에서는 **uy = sx가 되기 전에 sx를 int로 강제 signed 캐스팅** 했던 것 

만약 기대했던 53191로 값을 받고 싶다면, **unsigned short로 캐스팅 후 확장** 
```c
unsigned uy = (unsigned)(unsigned short) sx; // zero 확장 
```
### 숫자의 비트 표현 - 절삭 
#절삭 #Truncation

> 비트의 개수를 줄일 경우 


```c
int x = 53191;
short sx = (short) x;
int y = sx 
```
- 상황 : 32bit의 int를 16비트의 short로 절삭했다. 

#### 경우 1. unsigned 절삭 시 - zero-based 해석
- zero-based 해석 : 앞의 비트를 자르기만 하면 됨 
- 단순히 값만 줄어든다.
- **예시 - 4비트 값 12 = $1100_2$**
	1. **절삭(3bit로)** : $100_2$
	2. **해석** : 4 + 0 + 0 = 4 

#### 경우 2. signed 절삭 시 - 2의 보수 해석
- 자른 다음에 다시 부호 처리하는 것이다.
- 값이 음수가 될 수도 있다.
- **예시 - 원래 4비트 값 -4 = $1100_2$**
	1. **절삭(3bit로)**  : $100_2$ 
	2. **2의 보수로 해석** : MBS가 1이니까 -4 + 0 + 0 = -4


### 버그 : Singned Unsigned를 잘못 사용했을 경우 
> 앞서 말했듯, C언어는 묵시적 타입 변환을 제공한다.<BR>
> 하지만 이렇게 직관적이지 않은 변환은 종종 예상치 못한 버그를 발생시킨다.

아래의 코드를 보면 **length가 0일 때 심각한 버그가 발생**한다.
```C
float sum_elements(float a[], unsigned length) {
    unsigned i;
    float result = 0;

    for (i = 0; i <= length - 1; i++)
        result += a[i];

    return result;
}
```

**버그 발생 이유** 
- length가 unsigned인데 -1 을 한다면 **언더플로우가 발생**해서 `length-1`은 4294967295U가 된다.
- 결국, 이러한 언더플로우로 인해 **메모리 에러**가 발생 

**해결방법** 
- **방법 1. `i < length` 로 변경**
	- `-1`이 없기 때문에 length는 그대로 0이고 i랑 그대로 비교하게 된다.
	- 이때는 문제 발생하지 않음
	  
- **방법 2. unsigned ➡ signed int  `(float a[], int length)`**

