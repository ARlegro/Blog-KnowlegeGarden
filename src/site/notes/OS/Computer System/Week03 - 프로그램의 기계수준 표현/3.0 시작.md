---
{"dg-publish":true,"permalink":"/OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.0 시작/","noteIcon":"","created":"2025-07-28T15:30:33.927+09:00","updated":"2025-08-01T01:14:33.721+09:00"}
---



> 컴퓨터는 기계어(바이트의 sequences)를 실행한다. 

머신 프로그램은 2가지 형태가 있다.
1. **오브젝트 코드** 
	- 실제 컴퓨터에서 실행되는 
	- CPU가 실행하는 명령어를 인코딩하는 일련의 바이트
	- 사람이 보고 이해하기 어렵다
	  
2. **어셈블리 코드** 
	- 바이트를 좀 더 이해하기 쉽게 텍스트 형태로 되어 있음 
	- 옛날에는 이걸로 프로그래밍을 했음 


### 기계어의 역할 - 저수준의 작업을 인코딩
- 데이터 조작
- 메모리 관리
- 저장 장치에 데이터를 읽고 쓰기 
- 네트워크로 통신 


### 컴파일러가 하는 일

>[!tip] 소스 코드를 CPU가 이해할 수 있는 명령어 집합(ISA)에 맞춰 번역하고, OS 환경에 맞는 실행 파일을 생성

- 소스 코드 ➡ **기계어 코드를 생성** 
	- **최적화 및 검사** : 언어의 문법과 의미를 분석하여 최적화된 코드 구조 생성 
	- OS + H/W 고려한 코드 생성 ex. 리눅스/윈도우 용 실행파일
	- 대상 컴퓨터의 인스트럭션 집합(ISA)을 기준으로 **CPU가 이해할 수 있는 명령어로 변환**
		- CPU마다 사용하는 명령어 체계가 다름 
			
- **gcc 컴파일러 예시** 
	1. **전처리 + 컴파일** : 개별 명령어들을 어셈블리어 형태의 코드로 변환한다 (`.s`파일)
	2. **어셈블링**
		- 어셈블리어 ➡ 실행 가능한 **기계어로 변환** 
		- 생성 파일 : `.o`파일 
		- 아직 실행 불가능한 객체 코드 💢
	3. **링킹** 
		- 여러 개의 목적 파일과 라이브러리를 연결한다.
		- a.out or 지정한 실행 파일 형태로 결과가 나온다. 



### 어셈블리어 VS 고수준 언어(C)

- **고수준 언어**는 높은 추상화 기능으로 인해 개발자는 상세하게 구현할 필요가 없다. 이로 인해 생산적이고 버그 발생 가능성을 줄여준다. 
- 반면, **어셈블리어**는 프로그램의 저수준 명령어를 직접 지정해야 한다.

> 최신의 최적화된 컴파일러를 사용하면 어셈블리어만큼 아주 효율적인 코드가 생성될 수 있다.


>[!QUESTION] 어차피 컴파일러가 최적화된 어셈블리 코드 만드는데 왜 기계어를 배우는가❓

- 컴파일러의 최적화 기능을 이해하고 코드의 근본적인 비효율성을 분석하기 위해???
- 컴파일러 or 추상화 계층이 숨기는 정보를 이해하기 위해 
	- 예를 들어, 동시성 프로그램에서 스레드끼리 어떻게 정보를 공유/비공유 할 수 있는지 
	- 취약점 공격 시 런타임을 이용한 방식이 있는데 이를 방어하는 방법을 이해하려면 **프로그램의 기계 수준 표현에 대한 지식이 必** 

> 결론 : 프로그래머는 **컴퓨터가 프로그램을 실행하는 방식을 이해**하기 위해  **컴파일러가 생성한 코드를 읽고 이해할 수 있어야** 한다 (직접 작성까지는 ㄴㄴ)



Next : [[OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.1, 3.2 - 역사적 관점, 프로그램 인코딩\|3.1, 3.2 - 역사적 관점, 프로그램 인코딩]]