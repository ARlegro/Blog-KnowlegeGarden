---
{"dg-publish":true,"permalink":"/OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.1, 3.2 - 역사적 관점, 프로그램 인코딩/","noteIcon":"","created":"2025-07-28T15:27:36.872+09:00","updated":"2025-08-01T01:14:26.896+09:00"}
---


이전 : [[OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.0 시작\|3.0 시작]]


## 3.1 - 역사적 관점 
### x86

- **Intel CPU 계열의 명령어 집합 구조**(ISA)
- Intel 8086 CPU에서 시작된 아키텍처의 계보로, 그것을 따르는 CPU 명령어 체계 전체를 의미
- **32비트 명령어 체계**로 되어있다.
	- 레지스터, 주소공간, 명령어 형식 등을 포함 
	  
- Intel, AMD 모두 **x86 아키텍쳐를 기반으로 CPU를 생산**한다

>[!QUESTION] X86-64 는??
>- **64비트 확장 명령어 체계**로, AMD가 가장 먼저 확장했다.
>- 32비트 CPU에 비해 더 많은 메모리 사용, 더 빠른 처리, 더 넓은 공간 등의 이점을 제공 
>- 종류 : AMD64(원조), Intel 64비트 


> x86 마이크로프로세서는 수십 년 동안 성장해왔다.
![Pasted image 20250728161801.png](/img/user/supporter/image/Pasted%20image%2020250728161801.png)
- 사진은 인텔 CPU의 트렌지스터 수를 그래프로 나타낸 것이다.
- **트렌지수터가 많으면 좋은 점** 
	- **더 많은 연산 가능** : CPU나 GPU가 한 번에 처리할 수 있는 작업이 늘어남 
	- **병렬 처리 향상** : 코어 수 증가, 스레드 수 증가 → 멀티태스킹 성능 상승 
	- **더 복잡한 회로 설계 가능** : 인공지능, 3D 게임, 고속 통신 등 고성능 연산 가능   
	- **캐시 메모리 확장** : CPU 내부의 **빠른 임시 저장소**도 트랜지스터로 구성됨 
	- 등등 


## 3.2 - 프로그램 인코딩 

`gcc -0g -o p p1.c p2.c`  
- 파일 p1.c, p2.c를 컴파일 한다고 가정할 때의 명령어 
- `-0g` : **디버깅 가능한 최적화 모드**로, 실전 디버깅할 때 많이 쓰이는 **실속형 옵셔너**. 디버깅을 위해 **중요 정보는 유지**, **가벼운 최적화**는 적용
	- 반면, `-01`, `-02`, `-03` 이거는 최적화 수준을 더 높인 것. **But** 이러면 원본 코드와 너무 달라서 이해하기 어렵도록 심하게 변환된 코드가 생성될 수 있다.
- `-o p` : 컴파일 결과 실행 파일을 p라는 이름으로 저장 
- `p1.c, p2.c` : 컴파일 할 C 소스 코드 파일들

### GCC 내부적으로 하는 일 

> 참고 : [[OS/Computer System/Week01 - 컴퓨터 시스템으로의 여행/1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.\|1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.]]

#컴파일4단계

1. **전처리기 실행** 
	- `#include, #define, typedef, extern` 과 같은 구문을 처리하여 **매크로를 확장하고 필요한 헤더 파일을 삽입**한다.
	- **주요 작업**
		- `#include` 로 지정된 **헤더 파일 삽입** 
		- `#define`으로 정의된 **모든 매크로 치환/확장**
		- **조건부 컴파일 처리** (`#ifdef` 등 )
	- 결과 : `?.i`라는 파일이 생성 (But 디스크에는 저장 ❌)
	  
2. **컴파일 단계**
	- 전처리된 코드(`*.i`)를 **어셈블리어 코드(`*.s`)로 변환**한다.
	- 문법 분석, 중간 코드 생성, 최적화가 수행된다. 
	- **최적화 옵션**  ex. 불필요한 명령어 제거 등
		- `-0g`같은 옵션이 있으면 **최적화를 적용**한다  (디버깅 친화적 최적화)
		- `-02, -03` : 성능 엄청 최적화 

	  
3. **어셈블 단계**
	- 어셈블리어 ➡ 실행 가능한 **기계어로 변환** 
	- **생성 파일** : 실행 불가능한 객체 파일(`.o`파일)
	- 아직 실행 불가능한 객체 코드 💢
	  
4. **링크 단계** 
	- 여러 개의 목적 파일(`.o`)과 라이브러리를 **연결하여 하나의 실행 가능한 파일을 생성**한다
	- **주요 작업**
		- 함수 호출의 실제 위치 연결 (라이브러리와)

	- **결과**
		- 기본값 : a.out 
		- `-o filename` 으로 지정한 실행 파일 형태로 결과가 나온다. 


### 기계 수준 코드 

> 컴퓨터 시스템은 구현의 세부 사항을 숨기는 여러 가지 추상화 형태를 사용한다. 대표적으로 2가지를 볼 것 

#### 추상화 1. ISA
> 기계 수준 프로그램의 형식과 동작은 ISA(Instruction Set Architecture)에 의해 정의됨

- **정의** : CPU가 이해하는 명령어 체계
- ISA는 CPU 설명서 같은 것 : 레지스터, 명령어 형식, 명령어 의미를 알려주고 각 명령어가 CPU 상태에 어떤 영향을 주는지 알려준다.
- **효과** ⭐⭐
	- 레지스터, 명령어 등의 복잡한 내부를 몰라도 쉽게 코드를 짤 수 있다.

>[!tip] 컴파일러의 도움 
>- 컴파일러가 C코드의 추상적 실행 모델을 실제 기계 수준 명령어로 바꿔준다.
>- C에서 쓰는 `for`, `if`, `malloc`같은 추상 코드 ➡ **ISA 수준의 낮은 수준 명령어로 변환** 


#### 추상화 2. 가상 메모리 
> 기계 수준 프로그램에서 사용하는 메모리 주소는 가상 주소 

참고 
- [[OS/Computer System/Week01 - 컴퓨터 시스템으로의 여행/1.7(1) 운영체제는 하드웨어를 관리한다\|1.7(1) 운영체제는 하드웨어를 관리한다]], [[OS/Computer System/Week01 - 컴퓨터 시스템으로의 여행/1.7(2) 운영체제는 하드웨어를 관리한다\|1.7(2) 운영체제는 하드웨어를 관리한다]]
- [[OS/Computer System/Virtual Memory⭐\|Virtual Memory⭐]]

![Pasted image 20250715144758.png](/img/user/supporter/image/Pasted%20image%2020250715144758.png)
- C 코드에서 사용하는 포인터, 배열 인덱스 등은 **진짜 물리적 주소가 아니라 가상 주소**이다.
- OS와 H/W가 이 **가상 주소를 실제 주소와 매핑**해주는 것 


### 기계 코드 수준에서만 보이는 것들 
> - 기계 수준 코드를 보면 C개발자는 볼 수 없는 프로세서 상태의 일부가 보인다. 
> - C만 보면은 H/W 상태를 전혀 신경 안 쓴다. 
> - 하지만 기계어로 가면 이 상태가 드러나고 직접 조작을 해야한다. C에서는 추상화 되어서 몰랐겠지만 기계 수준에서는 구체화되었을 것 


> ☑안보이는 것들 
#### 1. PC (프로그램 카운터)
- **다음 명령어의 메모리 주소**를 나타내는 CPU 내부 레지스터 
- x86-64에서는 이걸 `%rip`이라고 부름 (RIP = Register Instruction Pointer)

####  2. 정수 레지스터 파일
- 주소(pointer) or 정수 데이터를 보관한다
- 64비트까지 뭐든 담을 수 있는 16개의 명명된 위치가 포함되어 있다.
- 단순, 함수 전달/리턴 값 저장 외에도 **스택 포인터, 기준 포인터 등 중요한 시스템에도 쓰인다.**

#### 3. 조건 코드 레지스터
- CPU **연산의 결과/상태 정보를 저장**하고, 이를 바탕으로 **조건 분기 명령이 실행될지 여부를 결정하는 데 사용** 
- 즉, 조건 코드는 분기 명령어가 실행될 조건을 판단하는 데 사용 
	
#### 4. 백터 레지스터 세트
- 하나 이상으 정수 or 부동 소수점 값을 보관할 수 있다.
- 한 번에 여러 데이터 연산을 위해 최적 

### 예시 : C ➡ 어셈블리 코드 

✔어
```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 5);
    return result;
}
```

위의 C코드를 컴파일(`gcc -Og -S -o add.s add.c`)하면 아래처럼 된다
- `-S` : 어셈블리 파일(`.s`)생성 

**✔어셈블리어** 
```asm 
add:
    mov     eax, edi      ; edi = a, eax = 임시 저장소
    add     eax, esi      ; esi = b, a + b 결과가 eax에 저장됨
    ret                   ; 반환

main:
    mov     edi, 3        ; 첫 번째 인자 a = 3 → edi
    mov     esi, 5        ; 두 번째 인자 b = 5 → esi
    call    add           ; add 함수 호출
    mov     eax, eax      ; 결과는 eax에 있음
    ret
```
- 레지스터 기반으로 동작(고속 저장 장치 저장소)

> 당연히 이해하기 힘들 것.
> 지금은 그냥 이런게 이렇게 변하는구나 정도만 이해 ㄱ 


### C vs 기계어 메모리 모델 차이 

|                   | C언어                                              | 기계어                           |
| ----------------- | ------------------------------------------------ | ----------------------------- |
| 타입별 선언/메모리        | 서로 다른 데이터 타입(int, float) 선언하고 메모리에 저장            | 메모리는 단순히 큰 바이트 배열일 뿐 타입 개념 없음 |
| 집합(배열/구조체) 데이터 처리 | 타입별로 메모리 해석을 다르게 한다.                             | 배열도 단순히 연속된 바이트일뿐             |
| 스칼라 데이터 유형 처리     | `int`, `unsigned int`, `int*` 등 부호/포인터 여부 엄격히 구분 | 그냥 전부 비트어리 취급                 |


>[!tip] 정리
>- **C 언어** : 타입 기반 추상화
>- **기계어** : 물리적 메모리 주소 기반 처리 


> 머신이 실행하는 프로그램은 **단순히 일련의** 명령어를 인코딩하는 **바이트 시퀀스**

### 디스어셈블링을 통한 기계어 수준 해석

> 기계어(바이너리 코드)를 사람이 읽을 수 있는 **어셈블리어**로 역변환(reverse translation)하는 프로그램 또는 기능
- ✅오직 바이트 시퀀스에만 기반하여 어셈블리 코드를 결정 
- ❌프로그램 소스 접근 
- gcc가 생성한 어셈블리 코드와 약간 다른 명령어 명명 규칙을 사용. ex. 접미사 생략 

```bash
linux> objdump -d prog  
# prog = 디스어셈블리 할 파일명 
```


![Pasted image 20250731125616.png](/img/user/supporter/image/Pasted%20image%2020250731125616.png)
- 위는 기계어로 변환된 파일을 어셈블리어로 추출한 내용이다.
- 기계어, 어셈블리어를 알면 이 내용을 해석할 수 있음
- **해석 예시** 
	- 최종 메모리 주소 : `0000~~~400540 <multistore>` ⬅ 이를 링커가 해준 것 
	- 함수간 호출 연결을 링커가 해줬다 : `callq 40058b <mult2>`
		- 컴파일 단계에서는 다른 함수의 정확한 위치를 몰라서 call 명령어는 비어있는 상태이다.
		- 하지만 링크는 이 위치를 알고 있으므로 call 명령어에 대한 정확한 상대 주소를 채워 넣어서 저렇게 된 것 

> 이렇게 **머신의 저수준 기능에 접근하기 위해서**는 **어세블리 코드로** 직접 내려가야 한다.

> [!INFO] 어셈블리 코드 형식은 1가지가 아니다.
> - 기본적으로 gcc, objdump 등은 기본 형식인 ATT로 어셈블리 코드를 보여준다.
> - 하지만, MS or Intel의 문서는 Intel형식의 어셈블리 코드를 보여준다.
> 	- Intel형식 코드 보려면 `gcc -Og -S -masm=intel mstore.c`


### 프로그램 메모리 구조 


메모리 영역 구성 중 일부
![Pasted image 20250729130102.png](/img/user/supporter/image/Pasted%20image%2020250729130102.png)

| 영역                              | 설명                                                                    |
| ------------------------------- | --------------------------------------------------------------------- |
| **실행 코드 영역**                    | **실행 가능한 기계 명령어**가 포함되어 있다.<br>(값이 변하지 않는 데이터)                        |
| **데이터 영역**                      | 전역/ 정적 변수를 저장<br>(값이 변하지 않는 데이터)                                      |
| **OS 정보 영역** <br>(커널, 공유 라이브러리) | 시스템 호출, 라이브러리 참조 등 관리 정보 포함                                           |
| **스택 영역**                       | **함수의 호출**과 관계되는 **지역변수, 매개변수, 리턴 주소 등**이 저장되는 영역. (함수 호출이 완료되면 소멸 됨) |
| **힙 영역**                        | 프로그래머가 **할당/해제하는 동적 메모리 공간** (`malloc`, `calloc`)                     |

> 위의 메모리는 CPU가 직접 접근하는 것이 아니라 가상 주소와 가상 테이블을 통해 접근된다.
> **프로그래머가 사용하는 모든 주소는 OS가 제공한 가상주소이다**

### 가상 주소를 사용하는 이유 
링크 : [[OS/Computer System/Virtual Memory⭐\|Virtual Memory⭐]]

### X86-64 가상 주소 특징 

- 주소 크기는 **64bit** 인데, ⭐But **실제로는 하위 48bit만** 사용(상위 16비트는 전부 0 or 1로 고정)
- 즉, 주소 공간 : $2^{48}$ = 256TB 
- 실제 대부분의 프로그램은 MB ~ GB만 접근하기에 이렇게 








