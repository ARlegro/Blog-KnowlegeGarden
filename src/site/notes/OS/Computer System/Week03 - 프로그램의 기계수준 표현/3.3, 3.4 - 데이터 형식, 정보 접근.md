---
{"dg-publish":true,"permalink":"/OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.3, 3.4 - 데이터 형식, 정보 접근/","noteIcon":"","created":"2025-07-31T13:42:55.477+09:00","updated":"2025-08-08T10:34:59.502+09:00"}
---


#### 컴퓨터에선 Word❓

- CPU가 **한 번에 처리하거나 전송할 수 있는 기본 데이터 단위** 
- H/W따라 Word의 크기가 다르다

| 아키텍쳐      | Word 크기       |
| --------- | ------------- |
| 8bit CPU  | 8bit (1byte)  |
| 16bit CPU | 16bit (2byte) |
| 32bit CPU | 32bit (4byte) |
| 64bit CPU | 64bit (8byte) |

> But, Intel은 원래 16bit에서 시작했기에 **보통 Word라는 단어를 16bit 데이터 타입**을 말할 때 사용한다
> - 32bit : 더블 Word
> - 64bit : 쿼드 Word 


## 3.4 정보 접근

### CPU 아키텍쳐 변화에 따른 레지스터 변화 

>x86(16bit CPU) ➡ IA-32(32bit) ➡ x86-64(64bit)로 발전하면서 **레지스터 크기와 이름이 확장**되었다.

#### 최종 구조 맛 보기 
#x86-64  
> 각 레지스터에서 64bit를 얻으려면 `%r`, 32bit를 얻으려면 `%e`버전을 사용하면 된다.
![Pasted image 20250731140326.png](/img/user/supporter/image/Pasted%20image%2020250731140326.png)
- 위의 그림은 현재 64bit CPU 아키텍쳐(x86-64)에서의 **전체 레지스터(16개)의 구조**이다.
- **각 레지스터는 서로 다른 목적으로 이용**된다. ex. stack pointer용 레지스터는 런타임 스택의 끝 부분을 가리키기 위해 사용 
- 자세하게 각 레지스터의 프로시저를 구현하는 방법은 3.7에서 할 것 
- 각 Bit는 값을 저장하고 검색할 수 있는 위치이다.


#### 변화

1. **16비트 시절** 
	- 16bit CPU 시절에는 **기본 레지스터가 8개**였다.
	- 이 레지스터들은 전부 2Byte(16bit) 크기였다.
	  
2. **32bit 시절** 
	- 여전히 레지스터는 8개 `%e`
	- 대신, 기존 8개의 레지스터의 크기가 전부 4Byte(32bit)가 됨 
	  
3. **64bit 시절** 
	- 이제 레지스터 8개가 추가되어서 **총 16개의 레지스터**가 되었다.
	- 이 레지스터들의 크기는 전부 8Byte(64bit)가 됨 


#### 레지스터는 중첨된 구조 
> 하나의 레지스터 블록 안의 작은 부분에도 접근 가능 
- 위의 최종 구조를 보면 한 레지스터 블록에 여러 부분이 있는 것을 볼 수 있다.
- 이는 **레지스터가 중첩된 구조**로 되어 있다는 뜻이고 **부분적으로 접근이 가능**하다는 뜻이다.
- 다른 말로, 하위 바이트만 조작도 가능하다는 것
- 위의 사진을 보면 8bit, 16bit, 32bit, 64bit 단위로 동일한 레지스터의 일부만 읽거나 쓸 수 있다는 것 
- **✅부분 접근의 장점**
	- **빠른 데이터 처리(속도)**
		- 레지스터 블록의 전체 bit를 쓸 필요 없이 일부나 변경하면 된다
	- **메모리 절약**
		- 레지스터 하나를 여러 용도로 쪼개서 재사용 가능
	- **코드 최적화** 
		- 64bit짜리를 다 채우는 어셈블리 코드를 짜지 않아도, 8bit짜리 코드를 짤 수 있다.
		- 이렇게 되면 **코드의 길이도 짧아지고 적재 효율도 나옴**
	- **I/O 장치와 호환**
		- I/O 작업 시 명령은 기본 1Byte(8bit) 단위로 동작한다
		- 64bit짜리 레지스터를 

>[!tip] 작게 쓰면 나중에 재정리하기도 편하자나 


### 특별한 레지스터 : 스택 포인터(Stack Pointer)
> - 일반적으로 다른 레지스터들은 마음대로 용도를 정할 수 있다.
> - But **Stack Pointer는 CPU와 OS에서 이미 엄격하게 정해진 용도로만 써야** 한다.
![Pasted image 20250804162551.png](/img/user/supporter/image/Pasted%20image%2020250804162551.png)
#### Stack Poiner란?
- **Stack이라는 메모리 영역의 현재 최상단 주소**를 가리키는 레지스터 
- 즉, Stack Pointer가 가리키는 위치가 스택의 가장 top이고 push, pop 시 자동으로 이 값을 변경한다

#### 특별한 이유 
- **CPU 명령어가 Stack Poiner에 엄청 의존적**이다.
	- CPU가 **특정 명령어들을 수행**할텐데 CPU는 이 때 반환주소를 **Stack에 저장하거나 꺼낸다.** 
	  
- **OS와 ABI(Application Binary Interface) 규약**이 정해져있다
	- 항상 16byte의 정렬 상태를 유지해야 하며,
	- 반드시 정확한 위치를 가리켜야 한다.
	  
- **잘못 건드리면 프로그램 망가짐**
	- Stack Pointer가 비정상적으로 변경되면 함수 호출도 엉망이되고 값을 잘못 불러와이상하게 프로그램이 종료된다.


### 오퍼랜드 식별자 

#### 개념 
> **오퍼랜드** : 그 명령어가 작용할 대상 (피연산자)
> - 명령어의 구성 = 연산 코드 + 오퍼랜드
> - 대부분의 인스트럭션은 1개 이상의 오퍼랜드를 가진다.

- 오퍼랜드는 **연산을 수행 할 Source값**과 그 **결과를 저장할 목적지(destination)의 위치를 명시**한다.
	- **Source** 값 : 상수 or 레지스터의 주소 or 메모리의 바이트 
	- **결과** 값 : 레지스터 or 메모리에 저장 

#### 오퍼랜드의 종류 타입
> 오퍼랜드는 3가지 방식으로 지정된다

1. **상수(immediate)**
	- 프로그램 **안에 값 자체가 포함되어 있는** 형태 
	- **명령어가 실행될 때**, CPU는 메모리, 레지스터를 참조하지 않고 **즉시 이 값을 사용**한다 
	- 예시
		```asm
		mov eax, 10  ; 즉시값 10을 eax에 저장 
		add eax, 5  ; 5더함 
		```
	- **특징**
		- **빠르다** Cuz 메모리 접근 없음
	  
2. **레지스터** 
	- CPU내부 레지스터에 저장된 데이터를 오퍼랜드로 사용 
	- 레지스터 이름 자체 = 오퍼랜드로 명시 
		```asm
		mov eax, ebx  ; eax로 ebx 값을 복사한다.
		add eax, ecx  ; eax에 ecx 값을 더한다.
		```
	- **특징**
		- **🥇가장 빠르다** Cuz CPU 내부 저장소 접근 
		- 특정 레지스터는 제한적으로 사용해야 함 
	  
3. **메모리** 
	- 메모리 주소를 통해 데이터에 접근하는 방식
	- 주소 계산에 상수, 레지스터, 인덱스, 배율 등을 조합 가능
		```rsm
		mov eax, [1000h]      ; eax ⬅ 메모리 주소 0x1000 값 (상수)
		mov eax, [ebx]        ; eax ⬅ ebx가 가리키는 메모리 값 (레지스터)
		mov eax, [ebx+4]      ; eax ⬅ (ebx + 4) 위치 값 (인덱스)
		mov eax, [esi+edi*4]  ; eax ⬅ (esi + edi×4) 위치 값 (배율)
		```
	- **특징**
		- 상대적으로 **느리다** Cuz 메모리 접근 
		- **유연한 주소 지정** 가능 


### 데이터 이동('move') 인스트럭션 
> **가장 많이 사용**되는 인스트럭션으로, **데이터를 한 위치에서 다른 위치로 복사**하는 명령

#### move 클래스 구성 - 4가지 
- `movb`, `movw`, `movl`, `movq`

| 명령어             | 효과        | 설명                      |     |
| --------------- | --------- | ----------------------- | --- |
| **`mov` S, D**  | **D ⬅ S** | **이동 (Move)**           |     |
| `movb`          |           | Move byte               |     |
| `movw`          |           | Move word               |     |
| `movl`          |           | Move double word        |     |
| `movq`          |           | Move quad word          |     |
| `movabsq` I , R | R ⬅ I     | Move absolute quad word |     |
|                 |           |                         |     |

> `movabsq`
> - absolute 주소 or 큰 상수(64bit)를 64bit 레지스터로 옮기는 명령
> 	- mov : 값 복사
> 	- s : sign-extend(부호 확장)
> 	- b : source가 1byte(8bit)
> 	- q : destination이 8byte(64bit)
> - **8bit를 읽고(소스) ➡ 64bit로 확장하되 확장 시 부호비트(최상위 비트)를 복사해서 나머지 비트를 채운다.**
> 	- 예를 들어, 0xAA의 8bit를 64bit 변환 시
> 	- 0xAA는 이진수로 10101010이다. 이 때 부호 비트는 1이므로 
> 	- 10101010앞에 비트들을 전부 1로 채울 것 
> 	- 이렇게 되면 10101010앞에 상위 56bit가 전부 1이 된다. 1111은 16진수에서 F인데 14개의 F가 있는 것. 즉, 16진수로 표현하면 0xFFFFF~ AA 가 된다
> - 원래 단순 `movq`는 32bit 상수까지만 넣을 수 있지만 `movabsq`는 64bit 상수를 그대로 레지스터에 넣을 수 있다.


#### 접미사 규칙 
>[!QUESTION] mov 뒤에 오는 접미사는 무슨 의미일까?
>- `mov` 오퍼랜드는 **접미사로 크기를 지정**한다
>	- `b` = 8bit, `w` = 16bit, `l` = 32bit, `q` = 64bit
>- 접미사는 레지스터 크기에 맞춰 정해진다. ⭐
>	- **대상 크기 = 명령어 접미사 크기**   << 여야 한다.

| 접미사 | 데이터 크기     | 예시 레지스터                        |
| --- | ---------- | ------------------------------ |
| `b` | 1바이트(8비트)  | `%al`, `%bl`, `%cl`, `%dl`     |
| `w` | 2바이트(16비트) | `%ax`, `%bx`, `%cx`, `%dx`     |
| `l` | 4바이트(32비트) | `%eax`, `%ebx`, `%ecx`, `%edx` |
| `q` | 8바이트(64비트) | `%rax`, `%rbx`, `%rcx`, `%rdx` |

참고 : [[OS/Computer System/Week03 - 프로그램의 기계수준 표현/레지스터 구조\|레지스터 구조]]

**-12(%rbp) 의미 : %rbp 기준 12byte 아래에 있는 메모리 위치** 




#### ⭐mov에서 안되는 규칙 

1. ❌**Destination(목적지)에 즉시값(상수)을 메모리처럼 사용할 수 없다.**
	- ex. `mov %rax, $6 ❌` 
2. ❌**두 오퍼랜드 모두 메모리여서는 안된다**
	- 메모리를 다른 메모리로 **직접 복사하는 것은 허용되지 않는다.** 
		- `mov (%rax) (%rbx) ❌`
	- **이유**
		- 편의를 위해 x86-64에서 제한 
		- CPU는 메모리 ↔ 메모리 직접 이동을 지원하지 않음 
		- 굳이 하고 싶다면 **"메모리 ➡ 레지스터 복사 ➡ 레지스터 값을 다른 메모리에 복사"**  이런 식으로 ㄱ  
	  
3. **접미사로 정한 데이터 폭이 소스와 목적지에 모두 동일하게 적용된다**
	- `movl %rax, (%rsp) ❌` : `rax`는 64bit 레지스터인데 `movl`은 32bit 연산이다. 따라서 **피연산자 크기 불일치**로 안됨
		```asm
		✅ 가능한 것들 
		movq %rax, (%rsp)     ; 64비트 ↔ 64비트
		movl %eax, (%rsp)     ; 32비트 ↔ 32비트
		movb %al,  (%rsp)     ; 8비트 ↔ 8비트
		
		❌불가능한 것 
		movl %rax, (%rsp)     ; ❌ 64비트 레지스터를 32비트 명령어로 사용
		movb %eax, (%rsp)     ; ❌ 32비트 레지스터를 8비트 명령어로 사용
		```
>[!tip]  64bit 모드의 자동 '제로 확장'
>- 32bit 레지스터에 쓰기를 하면 자동으로 상위 32bit를 0으로 확장한다.
>- `movl %eax, %edx   ;  %rdx = zero_확장(%edx)'


4. 인덱스 레지스터로 %rsp 사용 불가능 


## Pointer (메모리 참조) 
[[OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.4(2) - 정보 접근하기\|3.4(2) - 정보 접근하기]]


