---
{"dg-publish":true,"permalink":"/OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.4(2) - 정보 접근하기/","noteIcon":"","created":"2025-08-04T23:51:57.895+09:00","updated":"2025-08-08T10:35:07.650+09:00"}
---

[


이전 : [[OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.3, 3.4 - 데이터 형식, 정보 접근\|3.3, 3.4 - 데이터 형식, 정보 접근]]


> 우선, 포인터를 배울 것 

## 메모리 참조 

### 메모리 참조 기본 

x86-64에서는 괄호(`()`)안에 있는 레지스터를 쓰면, 그 **레지스터의 값이 주소라고 보고, 해당 주소의 메모리 내용을 읽거나 쓴다** 
```asm
mov (%rax), %rbx  ; 
```
- `%rax` 안의 값을 주소로 보고, 그 주소(메모리 주소)의 데이터를 가져옴 

```asm
mov %rcx, (%rbx) ; 
```
- `%rcx`의 값을 `%rbx`값의 메모리에다가 적음 


### 변위(displacement) + 레지스터 
> 변위 뜻(나무 위키) : 한 점의 최종 위치와 처음 **위치 간의 차이** 

괄호 앞에 숫자를 붙이면 **주소에 offset을 더한 위치를 참조**하게 된다.

```asm
mov 8(%rax), %rbx  ; rbx에 rax + 8 주소의 메모리 값을 저장 
mov %rcx, -16(%rdx) ; rdx - 16 주소의 메모리에 rcx 저장
```

### 레지스터 2개 + 상수 
x86-64는 주소 계산을 `Base + Index X Scale` 로도 표현할 수 있다.
- Base : 배열 시작 주소 
- Index : 인덱스 
- Scale : 요소 크기 
```asm
mov (%rax, %rcx, 4), %rdx 
```
- 해석 : (주소 = `rax + rcx*4`) 를 rdx에 저장 

### C언어의 포인터 특징과 어셈블리 코드

#### 특징 1. C언어의 포인터 = 단순한 주소
> C언어에서 **포인터**라고 부르는 것이 **어셈블리어에서는 단순히 주소**이다.
```c
#include <stdio.h>

int main(){
  int a = 10;  
  
  // pointer 선언 = a의 주소를 저장 
  int *p = &a;  // 

  printf("%p\n", p);  // p자체 => x의 주소
 
	// 역참조 유형 1 ✅
  printf("%d\n", *p);  // *p => 주소 p가 가리키는 값 = 10

	// 역참조 유형 2 ✅
	y = 1
	*p = y   // y 값을 p가 가리키는 위치에 쓰는 역참조 
	
}
// 0x7fff75493d0c
// 10
// 5 
```

>[!tip] 역참조 시 일어나는 일 
>- 포인터를 역참조(`*p`)하는 것은 아래의 2가지 과정으로 이루어진다.
>	1. 포인터를 레지스터에 복사
>	2. 레지스터를 메모리 참조에 사용 


#### 특징 2. 지역변수들은 종종 레지스터에 저장된다.
> 레지스터 접근이 메모리 접근보다 속도가 더 빠르다.


### 3.4 연습문제 
#### 문제 
`sp`와 `dp`의 값이 각각 레지스터 `%rdi`와 `%rsi`에 저장되어 있다고 가정합니다. 다음 표의 각 항목에 대해 지정된 데이터 이동을 구현하는 두 가지 명령어를 작성하세요. 첫 번째 명령어는 메모리에서 읽고, 적절한 변환을 수행하며, `%rax` 레지스터의 적절한 부분을 설정해야 합니다. 두 번째 명령어는 `%rax`의 적절한 부분을 메모리에 써야 합니다. 두 경우 모두 `%rax`, `%eax`, `%ax`, 또는 `%al`일 수 있으며, 서로 다를 수 있습니다.

**참고:** C에서 크기 변경과 "부호" 변경이 모두 포함된 캐스팅을 수행할 때, 연산은 크기를 먼저 변경해야 합니다 


| src_t         | dest_t        | 명령어               |
| ------------- | ------------- | ----------------- |
| long          | long          | movq (%rdi), %rax |
| char          | int           |                   |
| char          | unsigned      |                   |
| unsigned char | long          |                   |
| int           | char          |                   |
| unsigned      | unsigned char |                   |
| char          | short         |                   |

#### 풀이 
> **핵심 1. 흐름** 
> - 원본 주소(`%rdi`)에서 읽어온 값을
> - `%rax`계열 레지스터의 적절한 부분에 변환한 뒤, 
> - 목적지 주소(`%rsi`)로 다시 쓰는 명령어

> **핵심 2. 타입크기** 
> - 'char' = 1byte(8bit)
> - 'short' = 2byte(16bit)
> - 'int' = 4byte(32bit)
> - 'long' = 8byte(64bit)

 >**핵심 3. C캐스팅 규칙** 
 >- **크기 확장 후**, 부호 해석에 따라 **확장 방식(sign or zero)이 결정**된다
 >- 즉, 비트 크기를 맞추고 부호 여부에 따라 확장 종류 선택) 

1. **char ➡ int** 
	- 정답 : `movsbl (%rdi), %eax`  +  `movl %eax, (%rsi)`
	- `char`는 1byte(8bit), `int`는 4byte(32bit)이다.
	- char는 부호가 있는 타입이므로 **"부호 확장"이 필요**하다
		- 부호 확장 종류 1) zero-extenstion  2) sigh-extenstion
	- **명령어 1. `movsbl (%rdi), %eax`**  
		- `movsbl` = mov with **sign-extenstion byte -> long** (sign-extension으로 mov)
		- `(%rdi)` : 메모리 피연산자. **레지스터 `%rdi`에 담긴 주소가 가리키는 1byte를 읽는다** 
		- `%eax` : 32bit 목적지
		- 1byte의 최상위 비트를 복사해서 32bit 값으로 확장한 뒤 `%eax`에 저장한다.
		  
	- **명령어 2. `movl %eax, (%rsi)`**
		- `movl` = move long (32bit)
		- `%eax` = 이전에 sigh-확장된 32bit 정수
		- `(%rsi)` = 2번째 인자의 메모리 값 
		  
	- `(%rsi)`와 `(%rdi)`
		- 함수 인자 전달 시에 레지스터가 받는 규칙이 있따.
		- 1번째 = `%rdi`
		- 2번째 = `%rsi`
		- 3번째 = `%rdx`
		- 4번째 = `%rcx`
		- ....

2. **char ➡ unsigned** 
	- **비트 확장 먼저** by C캐스팅 규칙
	- **명령어 1. `movsbl (%rdi), %eax`** 
		- `sp`가 가리키는(`%rdi`) 1byte char값을 부호 확장하여 `%eax`에 저장 
	- **명령어 2. `movl %eax, (%rsi)`**
		- `%eax`의 4byte값을 `dp`가 가리키는 주소에 쓴다.

.... 나중에 하자....

### 스택 데이터의 저장과 추출 

