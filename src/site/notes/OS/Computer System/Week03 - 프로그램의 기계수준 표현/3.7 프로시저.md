---
{"dg-publish":true,"permalink":"/OS/Computer System/Week03 - 프로그램의 기계수준 표현/3.7 프로시저/","noteIcon":"","created":"2025-08-05T23:45:19.569+09:00","updated":"2025-08-08T10:35:11.320+09:00"}
---




값을 반환하지 않고 동작만 수행하는 함수(`void`형)


### 프로시저 호출의 3가지 핵심 요소 
Preview 

> 가정 : 프로시저 P가 프로시저 Q를 호출하고 다시 P로 리턴 

프로시저를 기계어 수준으로 처리하기 위한 많은 특성들이 존재한다.

#### 1. 제어 흐름 이동 
- 함수를 호출하면 실행 흐름을 옮기고, 끝나면 정확한 위치로 돌와와야 한다. (`call`, `ret`)
- 아래의 3가지를 모두 해야 한다.
	1. **제어 이동** : 호출자가 피호출자에게 `Jump`
	2. **복귀 주소 저장** : 피호출자를 호출 후 **다음 줄의 주소를 스택에 저장**해야 한다.
	3. **제어 복귀** : 호출한 함수가 끝나면 `ret`명령어로 복귀 주소로 `jump`
```c
void P() {
    Q();         // Q를 호출
    // 여기로 다시 돌아와야 함 ⭐
}
// Return Address는 결국 스택에 저장됨 
```

#### 2. 매개변수 전달
- 함수 간 **데이터 전달(인자)** 과 **데이터 반환(리턴값)** 은 컴퓨터 구조에서 **정해진 규칙(호출 규약)** 에 따라 처리됨
- 눈에는 안 보이지만, 실제로는 **레지스터나 스택을 이용해 값을 전달하고 돌려받는 구조가 숨어 있다**

#### 3. 지역 데이터
- 함수 내 지역변수들을 저장할 공간은 스택에 동적으로 만들어진다.
	- 함수가 호출되면 **스택 프레임이 생성**되는데 여기에 **지역변수, 복귀 주소, 이전 `%rbp` 등이 저장**된다
	- 함수가 끝나면, 해당 스택 프레임이 제거되고 메모리 자동회수된다.


## 주요 특징 1. 런타임 스택 
프로시저 호출 동작방식의 주요 특징은 **스택 자료구조의 LIFO 메모리 관리 방식을 활용할 수 있다**는 것 

> 스택은 **일반 메모리의 한 영역**, 그저 **거대한 바이트 배열**

>[!tip] 스택 목적
>- **프로시저의 호출과 반환과 관련된 상태를 관리하는데 사용**된다. ex) 리턴 정보 저장, 레지스터 저장, 지역 변수 저장 등

### 스택 프레임의 역할 
함수가 호출되면 해당 함수를 위한 스택 프레임이 스택에 할당된다. 이 **스택 프레임은 함수 실행에 필요한 다양한 정보**를 담고 있다.
>**스택 프레임에 저장되는 정보**
1. **반환 주소** 
	- 호출한 함수의 다음 명령어 주소 
2. **지역 변수**
	- 함수에서 선언된 지역변수들이 저장 
3. **매개변수**
	- 함수 호출 시 전달되는 인자들을 저장하는 공간 
4. **저장된 레지스터**
	- 함수 호출 전 사용중이던 레지스터 값들을 백업

### 프로시저 호출 동작 방식(feat. 스택 프레임) 
P와 Q라는 함수가 있다고 가정하겠다
1. **P가 Q를 호출 시** 
	- Q 호출 시 우선, Q실행이 완료된 후 P로 돌아올 **반환주소가 스택에 먼저 저장**된다. 
	- **이 주소는 P의 스택 프레임의 일부**로 간주 
2. **Q의 스택 프레임 생성**
	- 새로운 **스택 프레임을 생성**하고 **스택포인터를 조작**하여 스택의 크기를 확장한다 
	- 이 스택 프레임은 Q 자신의 지역변수, 필요 레지스터 등을 저장하기 위한 것 
	  
3. **Q실행 후 반환**
	- Q가 실행을 마친 후, Q의 **스택 프레임은 메모리에서 해제**된다.
	- 스택포인터는 원래 위치로 되덜려진다.
	- 이전에 **저장해둔 반환 주소를 참조하여 P의 실행을 재개** 

> **LIFO** 방식 덕분에, **최근 호출된 함수의 메모리가 가장 먼저 해제**될 수 있다 ➡ **효율적 메모리 관리 가능** 

> [!WARNING] 예외  
> **모든 함수가 스택 프레임을 필요로 하지는 않는다.** 아래의 2가지 조건을 모두 만족한다면 스택 프레임이 필요 없을 수 있음
> 1. 모든 지역 변수를 레지스터에 저장할 수 있을 때 
> 2. 다른 함수를 호출하지 않는 리프 프로시저일 때 
>
>이러한 조건을 만족하는 경우 스택 없이 레지스터만으로 함수 실행하여 성능 최적화 가능 


## 주요 특징 2. 제어의 이동 

**함수의 호출과 반환**은 **프로그램의 제어 흐름을 옮기는 과정**이다.
이 과정은 주로 `call`과 `ret` 두 가지 핵심 어셈블리 명령어를 통해 이뤄진다.

### 1. call명령어 : 함수 호출 

함수 P가 Q를 호출한다고 했을 때, `call Q`명령어가 사용된다.
이 명령어는 아래의 2가지 중요 작업을 수행한다.
1. **반환 주소 저장** 
	- 현재 실행 중인 명령어의 **바로 다음 주소를 스택에 push**
	- 이 주소는 Q가 실행을 마친 후 **돌아와야 할 위치**를 나타내면 반환주소라고 함 
2. **프로그램 카운터 값 변경** 
	- PC값을 호출된 함수 Q의 시작 주소로 설정 

### 2. ret명령어 : 함수 반환 
호출된 함수 Q가 끝나면 `ret`명령어가 사용된다.
이 명령어는 아래와 같은 방식으로 동작한다
1. **반환주소 복원**
	- 스택의 최상단에 저장되어 있던 **반환주소를 pop**하여 가져온다. 
2. **PC 복원** 
	- PC값을 **pop한 반환 주소로 설정** 

## 주요 특징 3. 데이터 전송 

함수 호출 시 제어흐름의 이동 뿐만 아니라 **인자를 전달하고 반환값을 돌려받는** 과정도 있다. 이러한 데이터 전달은 레지스터를 통해 이루어진다.

### 인자 전달 규칙 
x86-64에서 함수에 인자를 전달하는 방식은 레지스터를 통하는데 표준 방식은 아래와 같다.
- 최대 6개의 인자는 지정된 순서대로 **6개의 레지스터**를 통해 전달된다. 
	- 1번째 인자: `%rdi`
    - 2번째 인자: `%rsi`
    - 3번째 인자: `%rdx`
    - 4번째 인자: `%rcx`
    - 5번째 인자: `%r8`
    - 6번째 인자: `%r9`
- 💢만약, 인자가 6개가 넘으면 stack에 저장된다 

> [!WARNING] 인자의 데이터 크기에 따라 다른 레지스터를 쓸 수도 있다 (ex. %edi)


### 반환 값 전달 규칙 
- 함수가 값을 반환할 때, 그 결과 값은 **`%rax` 레지스터**에 저장
- 호출한 함수는 `%rax`레지스터에서 반환 값을 읽어 사용 


## 스택에서의 지역저장공간 
