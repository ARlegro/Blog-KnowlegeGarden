---
{"dg-publish":true,"permalink":"/OS/Computer System/chapter06-메모리계층구조/커널 영역 심화/","noteIcon":"","created":"2025-08-13T14:17:30.492+09:00","updated":"2025-08-15T12:19:21.592+09:00"}
---

*관련 자료* : [[OS/Computer System/Virtual Memory\|Virtual Memory]]

### Preview : 커널 영역으로의 전환

#### 영역 : User and Kernal`
가상 메모리는 User 영역과 Kernal 영역으로 구분된다.
- *User 영역* : 사용자 프로그램이 실행되는 공간
- *Kernal 영역* : OS가 관리하는 보호된 공간(Kernal 모드로 전환해야 접근 가능)

자세한 내용 : [[OS/Computer System/Virtual Memory\|Virtual Memory]]

#### 모드 : User, Kernal
1. *User 모드*
	- *개념* : CPU가 **제한된 명령어만** 실행할 수 있는 상태 💢
	- *특징* : ❌특정 I/O 작업, 메모리 직접 접근, 장치 제어 등의 **명령이 불가**
	- *왜 이렇게 막아 놨는가❓* #보안 #안정성
		- 이렇게 막아 놓은 작업들은 시스템 전체에 영향을 주는 아주 민감한 작업들이다. 
		- 이렇게 막아 놓음으로써 이상한 코드가 **시스템 자체를 망가뜨리는 것을 막고자** 설계 (Kernal이 중간 관리자 느낌)
	  
2. *Kernal 모드*
	- CPU가 모든 명령어를 실행할 수 있는 상태
	- **H/W에 직접적으로 접근이 가능**하다. 
	- **OS의 핵심 부분에도 접근이 가능**

#### 모드 전환의 필요성과 언제 전환되는가?
>[!tip] 모드 전환이 필요한 이유와 전환 
**OS의 개입이 필요한 작업**(인터럽트, 시스템 콜)들일 경우 커널 모드로 전환해야 한다.<br>
>

> [!QUESTION] 그렇다면 언제 User모드 ➡ Kernal모드 로 전환되는가?
> 1. *H/W 인터럽트*
> 	- 키보드/마우스 입력, 네트워크 패킷 수신 등도 메모리 I/O 영역에 접근해야 돼서 커널 모드 전환이 必
> 2. *시스템 콜* 
> 	- 파일 쓰기(`write()`), 읽기(`read()`) 작업은 디스크 Driver 제어가 필요하므로 커널 모드 전환이 必

#### 전환 시 임시 저장 
Kernal모드에서 **언젠간 User모드로 전환해야** 하기 때문에
User Mode로 전환하기 위해 프로세스의 중요한 정보들을 **PCB, 공용곤간에 저장**
![Pasted image 20250813133831.png](/img/user/supporter/image/Pasted%20image%2020250813133831.png)


### 임시 저장소 1. PCB (Process Control Block) 
> [!WARNING] ❌회로용 PCB가 아니다❌

![Pasted image 20250813141843.png](/img/user/supporter/image/Pasted%20image%2020250813141843.png)

#### 개념 
> PCB = 프로세스 제어 블록

- *개념* 
	- **프로세스의 Context를 담는 곳** 
	- 특정한 프로세스를 관리할 필요가 있는 **정보(메타 데이터)를 포함**하는 **운영체제 커널의 자료구조**. 
	- 걍 쉽게 프로세스 여러 개 다루고 관리해야하는데 그런 정보들 담아줄 프로세스용 DB라고 보면 됨 
	  
- *생성과 소멸*
	- 프로세스가 생성될 때마다 해당 프로세스의 고유 PCB가 생성되고 
	- 프로세스가 종료되면 PCB는 제거됨
	  
- *효과*
	- 나중에 중단된 프로세스가 다시 실행될 때, PCB에 적힌 정보를 읽어와 정확한 시점부터 작업 재개 가능 


> 정리 : 프로세스의 **전반적인 정보**(상태, PID, 메모리, CPU 레지스터 정보 등)를 관리

#### 요소 간단히 보기 
참고 영상 : [프로세스 제어 블록](https://www.youtube.com/watch?v=4s2MKuVYKV8)

1. *PID(Process ID)*
	- 특정 프로세스의 **고유번호** 
	- 이를 통해 특정 프로세스를 **식별**할 수 있다.
	  
2. *Process State*
	- 프로세스의 **상태**  ex. 실행 중, 대기 중, 종료 등 
	  
3. *PC(Program Counter)*
	- 특정 프로세스에서 **다음에 실행될 명령어의 주소** 
	  
4. *CPU 레지스터*
	- 특정 프로세스가 현재 사용중인 레지스터를 알려준다.
	  
5. *메모리 관리 정보*
	- 특정 프로세스에 의해 사용중인 메모리 정보 or Page Table 정보  
	  
6. *입출력 상태 정보*
	- 특정 프로세스에 할당된 입출력 장치 정보
	  
7. *그 외* : 스케줄링 정보, 회계 정보 등 

Note : 프로세스는 H/W영역에 바로 접근 못 함 


### 2. 커널 스택 
#### 개념
> 정의 : OS가 *Kernal 모드에서 함수를 호출할 때 사용*하는 스택 
> - **임시로 작업이 수행되는 공간**
> - 커널 호출 함수의 매개변수, 지역 변수, 복귀 주소 등을 저장하는 메모리 공간 

*✔예시를 통한 개념 이해*
- 인터럽트가 발생하면 **커널모드로 전환**됨 
- 이 때, **인터럽트를 처리하기 위해 Kernal은 인터럽트 핸들러를 실행**
- 이 ***핸들러가 사용하는 함수의 매개 변수, 지역변수 등***을 쌓는 곳이 **"커널 스택"**
- "작업을 위한 메모장" 같은 곳 

#### 저장되는 정보 
1. **호출 인자** : 사용자가 Kernal에 전달하는 매개변수들 
2. **커널의 함수가 사용하는 지역변수/반환 주소**


