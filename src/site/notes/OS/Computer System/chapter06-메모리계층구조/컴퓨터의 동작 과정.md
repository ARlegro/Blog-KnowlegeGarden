---
{"dg-publish":true,"permalink":"/OS/Computer System/chapter06-메모리계층구조/컴퓨터의 동작 과정/","noteIcon":"","created":"2025-08-13T09:29:07.288+09:00","updated":"2025-08-21T11:04:55.329+09:00"}
---

컴퓨터의 동작 과정을 알아야 OS가 어떤 방식으로 수행하는지 알 수 있음

### 기본적인 컴퓨터 시스템 구조 
> **CPU와 각 장치들은 서로 연결되어 메모리를 공유** 

![Pasted image 20250813104456.png](/img/user/supporter/image/Pasted%20image%2020250813104456.png)
- 또한, 각 장치마다 다른 장치와의 상호 작용을 도와주는 장치들이 있다. ex. Controller, Adpater, Interface
- 이렇게 작동되면 모든 기계들은 동기화가 되어 잘 작동한다.

---
### 부팅 과정 
참고 : [[OS/Computer System/chapter06-메모리계층구조/6.1-저장장치 기술(2)\|6.1-저장장치 기술(2)]]

1. **전원이 켜진 후 ROM**에 저장된 **초기 프로그램(펌웨어)을 실행**한다
	- 일반적으로 PC에서는 이를 BIOS(Basic Input/Output System) or UEFI라 함 
 >[!tip] 펌웨어는 ROM에 저장되어 있다 ➡ 변경이 불가능 ➡ **항상 같은 방식으로 초기화** 작업 
펌웨어 = S/W - H/W의 중간 다리 역할  (참고 : [[OS/Computer System/chapter06-메모리계층구조/6.1-저장장치 기술(2)\|6.1-저장장치 기술(2)]] - 펌웨어)
2. 초기 프로그램은 CPU/RAM/HDD/모니터 등 **주요 H/W 장치들을 점검하고 초기화**한다(기본 설정 적용)
3. **OS를** 찾아서 **메모리에 적재**한다 By OS Boot Loader
4. **OS 실행**
	- 메모리에 적재된 OS 커널이 본격적으로 실행 됨(*커널 : 컴퓨터의 모든 자원을 관리하는 OS 일부*)
	- 이때부터, **여러 장치 Driver, 각종 서비스들을 실행** ➡ 사용자가 컴퓨터를 사용할 환경을 구축 
	  
5. **인터럽트 기반 시스템 시작** 
	- OS가 완전히 실행되면, 컴퓨터는 사용자의 입력을 받거나 통신을 할 준비가 된 것

>[!QUESTION] 그럼 부팅이 끝나고 어떻게 작업들을 처리하냐❓
>모든 과정은 **인터럽트** 라는 신호를 통해 이루어진다.

---
## 인터럽트 ⭐⭐
사전 개념 참고 : [[OS/Computer System/chapter06-메모리계층구조/커널 영역 심화\|커널 영역 심화]]
> CS 작동 원리를 공부하려면 이런 개념은 기본 탑재 必

---

### 1. 개념 및 중요성
#### 개념 
#CPU방해 
> CPU가 특정 이벤트를 처리할 수 있도록 **현재 실행 중인 작업을 잠시 중단 시키는 신호** 
- **인터럽트가 발생하면 CPU는 하던 일을 중단하고, 인터럽트를 먼저 처리함** 
- 이때 하는 처리를 "서비스 루틴"이라고 함(일반적으로 OS가 처리)
	- 서비스 루틴이 종료되면 CPU는 중단되었던 연산을 재개


---

#### 인터럽트 작동 원리
참고 : [[OS/Computer System/chapter09-가상메모리/Virtual Memory\|Virtual Memory]]

![Pasted image 20250813160720.png](/img/user/supporter/image/Pasted%20image%2020250813160720.png)
1. *CPU에게 인터럽트 발생시키기*
	- 외부 장치 or 프래그램 이벤트 or 상태변화 발생 시 CPU에게 알리기 위해 인터럽트를 발생 시킴 
	  
2. *하던 일 중단하고 임시 저장*
	 - CPU는 1번 요청을 받아들이기 위해 실행 중인 작업을 잠시 멈춘다.
	 - 실행 중이었던 작업의 정보(레지스터 값, 상태 정보)를 담고 있는 CPU 내부의 **여러 레지스터의 값들을 커널 스택에 Push(저장)** 
	   
3. *처리 후 위치로*
	- **인터럽트 처리** 후 **커널 스택 pop해서 원래 위치로** 돌아가며 기존에 하던거 다시 처리 

![Pasted image 20250813131433.png](/img/user/supporter/image/Pasted%20image%2020250813131433.png)

뭐... 인터럽스 서비스 루틴이니 중첩 인터럽트니 우선순위 판별 방법이니... 굳이 지금 알 필요 없을 듯 

---

#### 필요한 이유 
1. *효율적인 CPU* 
	- *CPU = 컴퓨터의 뇌* ➡ 시스템의 거의 모든 연산이 CPU를 거침 
	- H/W, S/W 모두 **특정 이벤트 요청 시 CPU에 신호를 보내 작업을 요청**(ex. H/W ➡ 데이터 준비상태, 상태 변경 정보 전달)
	- ⭐**CPU가 여러 장치 상태를 계속 확인할 필요가 없어서** CPU는 하던 일만 하면 됨
	  
2. *빠른 응답 가능*
	- 긴급 or 우선순위 작업을 **즉시 처리 가능** 

3. *동시처리 **처럼** 보이게 가능*
	- 인터럽트 덕분에 사용자 입장에서는 여러 작업이 동시에 진행되는 것처럼 보임
	- **Why**❓ #시분할 
		- CPU는 원래 한 번에 하나의 프로세스만 처리 (단일 코어 기준)
		- 근데 인터럽트 발생 시 **현재 작업과 다른 작업을 번갈아**가면서 하는데, 이 때 여러 작업이 단일 코어로도 **동시에 진행되는 것처럼** 보임 

---
### 2. 인터럽트 유형 
인터럽트는 다양한 이유로 발생 할 수 있다.
> 발생 원인 or 처리 방식에 따라 다양한 유형 가능 

![Pasted image 20250813161833.png](/img/user/supporter/image/Pasted%20image%2020250813161833.png)
#### 1. 외부 I/O 인터럽트 
> 원인 : CPU 외부 장치의 상태 변화 or 요청 동작으로 인해 발생하는 인터럽트

- **특정 장치의 상태 변화**(ex. 키보드 누름, 네트워크 패킷 come) or **데이터 전송 요청**과 같은 **H/W 이벤트**에 의해 발생
- **특징** 
	- **CPU와 독립적**으로 발생 ➡ CPU와 **비동기적 처리** (현재 CPU 실행과 무관)

*"CPU와 비동기다" = 현재 CPU에서 실행 중인 개별 명령어와 무관하다.*


>[!tip] 일반적으로 **비동기 예외는 정상 방식**이다
>- 보통 예상할 수 있는 일들을 비동기로 처리함으로써, 현재 실행 중인 프로그램이 종료되지 않도록 함 (처리 후 바로 재개하도록)
>- ex. 네트워크 패킷 수신 인터럽트 


---

#### 2. 내부 인터럽트
> 원인 : 프로그램의 **실행 도중 예상치 못한(오류) 상황**에서 발생하는 인터럽트
- 주로, **CPU가 명령어를 실행하는 도중**에 발생 ➡ **동기적** 처리 
- ex. Overflow, Page Fault(잘못된 메모리 접근), Divide 에러 => 시스템 예외 발생 


---

#### 3. S/W 인터럽트
> 원인 : 사용자가 의도적으로 **특정 기능을 수행하기 위해** 발생시키는 인터럽트
- CPU가 특정 명령어를 실행할 때 발생. 
- 이거는 코더가 제어 가능 

- *예시*
	- *System Call* 
		- 파일 입출력, 메모리 할당, 프로세스 생성 등 **OS의 서비스를 요청할 때 사용**
	- *디버깅 도구* 사용 (브레이크 포인트)

---
### 3. 심화 : 핸들러 사용하는 2가지 방법
> 인터럽트 요청 시 처리할 수 있는 2가지 방법이 있다.

#### 방법 1. RAM에 미리 핸들러 적재  
1. OS가 어떠한 종류의 인터럽트인지 확인
2. 인터럽트 **핸들러**를 호출해서 **인터럽트 처리** 
	- OS가 **미리** 모든 인터럽트 **핸들러 코드를 RAM에 적재**해둠 

>[!danger] 이 방법은 RAM이 모든 인터럽트의 처리 루틴을 가지고 있어야 함 ➡ 메모리 제약

---

#### 방법 2 ⭐- 필요할 때 로딩(Lazy Loading)

>[!tip] 모든 인터럽트의 처리 루틴을 가지고 있지 않는다(메모리 효율적)
>- 최근 os는 이거 많이 채택


**✔원리** 
1. *핸들러는 디스크에만 저장(SSD, HDD)*
	- 인터럽트를 다루는 핸들러를 HDD, SSD 등에 넣어 놓음
	  
2. *OS는 핸들러의 위치(주소)만 기억*
	- 인터럽트를 다루는 핸들러 포인터들을 OS가 가지고 있음(백터 테이블로) 
	- 백터 테이블 : 인터럽트 유형별 주소 가리키는 테이블
		![Pasted image 20250813160055.png](/img/user/supporter/image/Pasted%20image%2020250813160055.png)
		- 실제 서비스 루틴 주소 : Program Address 
		- 우선순위 결정 : Vector No.
		![Pasted image 20250813160800.png](/img/user/supporter/image/Pasted%20image%2020250813160800.png)


**☑*장단점***
- *✅장점* : 메모리 절약 가능 (필요한 핸들러만 불러오므로)
- *💢단점* : 디스크 접근이라 RAM 접근보다 느림  
