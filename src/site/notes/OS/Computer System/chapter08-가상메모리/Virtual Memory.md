---
{"dg-publish":true,"permalink":"/OS/Computer System/chapter08-가상메모리/Virtual Memory/","noteIcon":"","created":"2025-07-13T17:00:57.171+09:00","updated":"2025-08-18T01:18:52.013+09:00"}
---

#메모리_관리_기법 

**Preview**
- 실제 물리적 메모리보다 더 큰 메모리를 사용하는 것**처럼 보이게 하는** 메모리 관리 기법 
- HDD공간을 메모리처럼 활용하여 프로그램이 마치 실제 메모리가 충분한 것처럼 작동 
- (프로세스가 독점적으로 사용하는 것처럼 메모리 가상화)

>[!EXAMPLE] Window 시스템에서 메모리 운용 3가지 방법
>1. **가상 메모리** 시스템 활용
>2. 메모리 맵
>3. 힙 

### 가상 메모리기법❓

> 컴퓨터 시스템이 실제 물리적 메모리(RAM)보다 훨씬 더 큰 메모리를 사용하는 것**처럼 보이게 하는** 기술 (By HDD공간을 RAM처럼 사용)

### 가상 메모리란 ❓
#메모리_추상화

 OS는 프로세스, 가상 메모리, 파일 을 통해 추상화를 달성했다.
![Pasted image 20250713133447.png](/img/user/supporter/image/Pasted%20image%2020250713133447.png)
---
#### 개념
- **메모리를 추상화**하여 각 프로세스에게 독립적인 메모리 공간을 제공
	- OS는 각 프로세스에게 독립된 가상 메모리 공간을 준다
	- 예를 들어, 32bit 운영체제에서 OS가 어떤 프로세스에게 32bit 공간(4GB)을 준다면 그 프로세스는 그 범위 내에서 메모리 사용 

>[!QUESTION] 근데, RAM은 보통 16GB인데 한 애플리케이션에 4GB나❓
>- 이건 말이 안 된다.
>- 즉, OS가 부여한 가상 메모리 주소는 **실제 RAM 용량과 무관**하게 각 프로세스에게 주어지는 **"논리적"인 공간**이다.
>- 이로 인해, RAM이 16GB여도 64bit 애플리케이션 여러개를 동시에 실행할 수 있다.

---
#### 4GB는 너 것이 아니다 💢
> 한 애플리케이션에 부여된 4GB의 가상 메모리 공간 전체는 사용자가 쓸 수 있는 곳은 아니다!! 
- 보통 사용자 영역과, Kernal 영역을 2GB씩 파티셔닝한다 
- User가 Kernal영역에 직접 접근하려고 하면 애플리케이션은 강제 종료된다.(User 영역을 거쳐야)
![Pasted image 20250729134400.png](/img/user/supporter/image/Pasted%20image%2020250729134400.png)

---
#### 커널 영역 가상 메모리 일부는 하나를 가리킴 
>⭐사실 모든 프로세스에게 부여된 Kernel 영역 가상 메모리의 일부는 **실제로는 하나이다**

![Pasted image 20250813131433.png](/img/user/supporter/image/Pasted%20image%2020250813131433.png)
- 모든 프로세스에게 독립적으로 부여된 **가상메모리의 커널 영역 중 일부**는... 사실 그 메모리는 실제 공간 하나를 가리킨다.
- "가상 메모리는 선형적이다"말의 의미는❓메모리가 연속적인 배열 형태로 되어 있다는 뜻(논리적으로) 	ex. *4GB 배열 -> char[43억]*
- **32bit 어플리케이션 ➡ 4GB만큼 배열 메모리처럼 생긴 가상 메모리가 주어짐**(64bit는 16EB로 4GB보다 43억배?? - 1bit 당 주소공간 2배 늘어남 - $2^{32}$)
 

> 가상 메모리의 진짜 주소는 RAM일수도 HDD일수도 (이건 OS의 메모리 매니저가 해줌)
![Pasted image 20250813133317.png](/img/user/supporter/image/Pasted%20image%2020250813133317.png)

![Pasted image 20250730195702.png](/img/user/supporter/image/Pasted%20image%2020250730195702.png)

### 심화 : 커널 영역 
참고 : [[OS/Computer System/chapter06-메모리계층구조/커널 영역 심화\|커널 영역 심화]]


---
### 가상 메모리 페이징 ⭐

#### 페이징 기법❓ 
- **가상 메모리 주소 공간을** 고정된 크기인 "**페이지(Page)**" 단위로 쪼개고, **물리 메모리**도 동일한 크기의 **프레임(Frame)** 단위로 나누어 ➡ **가상 주소를 물리 주소로 매핑하는 메모리 관리 기법** (보통 페이지, 프레임은 4KB로 동일하게 끊어준다 - 매핑 쉽게)![Pasted image 20250730190220.png](/img/user/supporter/image/Pasted%20image%2020250730190220.png)
	- 이 배열에 stack, heap, 커널 코드 모두 그 안에 들어있음

 
>[!example] 가상 주소(VA) 구조 = (P, D)
>- P : Page Number(페이지 번호)
>- D : Offset (오프셋, 거리) - 페이지(프레임) 첫 번째부터 얼마나 떨어져 있는지
![Pasted image 20250730191155.png](/img/user/supporter/image/Pasted%20image%2020250730191155.png)

---
#### 매칭 과정 
> 가상 주소의 페이지와 물리 주소의 프레임을 1:1로 매핑해주는 매핑 테이블이 있다.

4GB짜리 가상 메모리를 4KB 페이지 단위로 나눴다고 가정하자 
![Pasted image 20250730190522.png](/img/user/supporter/image/Pasted%20image%2020250730190522.png)
**주소 변환 과정 (가상 주소 ➡ 물리 주소)**
1. 가상 주소 설정: CPU는 가상 주소를 만든다 
2. 매핑 : OS가 관리하는 페이지 테이블에서 페이지에 해당하는 프레임 번호를 찾는다.
3. 변환 : 최종 물리 주소(PA)를 (F, D)로 변환한다.
4. PA를 통해 실제 메모리에 접근할 수 있다.

---
#### ✅장점 
1. **외부 단편화가 발생하지 않는다.**
	- 메모리 공간에 여러 블록들을 임의로 막 배열하다보면 자잘자잘하게 남는 공간들이 생길 것이다.
	- 이러한 공간들이 계속 된다면 메모리는 충분한데 연속적인 큰 블록이 없어서 새로운 프로세스가 사용하지 못하는 현상이 발생한다 => 빈 공간이 여기저기 흩어져 남는 
	- **페이징의 해결 방식**
		- 메모리를 고정된 크기로 나눠 논리적인 부분은 단편화 시키고 
		- 물리 메모리에서는 작은 빈 공간들이 흩어져 있어도 이를 **재조합하여 프레임단위로 만들고 프로그램 실행**한다 Cuz 프로세스는 연속된 공간을 요구하지 않기 때문 
	  
2. **메모리 활용률 향상 By Lazy Loading**
	- 필요한 페이지만 메모리에 적재할 수 있다.
	- 프로세스 실행에 당장 필요한 몇 가지 메모리만 적재한 뒤, 나머지는 나중에 필요할 때마다 불러오는 구조
	- 즉, 8GB짜리 게임을 실행할 때, 기본 기능만 쓰고 있을 때는 2GB만 메모리에 불러와서 사용하고 실제로 추가 기능을 쓰려 할 때는 더 불러오는 것 
	  
3. **실제 주 기억장치(RAM)이 연속적인 물리 주소일 필요가 없다**
	 - 페이징 기법이 없을 떄는 연속 할당 방식으로 외부 단편화를 방지하기 위해 연속된 물리주소를 지향해야 했다.
	 - 하지만, 이 기법으로 인해 물리주소가 여기저기 흩어져 있어도 No problem (재조립 가능)

#### 💢단점 
1. **내부 단편화 발생 가능**
	- 1byte짜리 메모장인데 4KB나 할당되어서 낭비 
	  
2. **Page-in 발생 시 성능 저하**
	- 가상 메모리 기법은 RAM뿐만 아니라 HDD를 쓴다고 했었다.
	- 초기에는 RAM을 쓰다가 RAM이 꽉 차면 현재 잘 안쓰는 애플리케이션들을 HDD에 매핑을 시키는데 이를 Page-out이라고 한다.
	- 이렇게 안쓰는 애플리케이션들을 나중에 필요해서 쓸 때 다시 주 기억장치인 RAM으로 가져와야 하는데 이것이 Page-in이다.
	- 이러한 현상이 자주 발생된다면 디스크 접근이 많아져 성능 저하를 발생시킨다.


--- 

## 여기서부터 다시 적으면 됨 

### 사용 이유 
> 각 프로세스가 자신만의 가상 주소 공간을 가지게 되면??

#### 이유 1. 프로세스 독립성 보장 
- 가상 메모리에서는 프로세스가 실제 사용하는 메모리 공간을 OS로부터 배정 받는다. 이 과정에서 OS는 **타 프로세스가 사용중인 메모리를 절대 배정하지 않는다.**
- 이로 인해 
	- 각 프로세스가 **다른 프로세스의 메모리 영역에 접근하거나 영향을 주지 않게되고**
	- **시스템 안정성이 높아진다** 

#### 이유 2. 메모리 공간 확장 

- 가상 메모리 기법을 통해 프로세스는 **물리 메모리보다 더 큰 메모리 공간을 사용할 수 있게** 된다. 
- 이로 인해
	1. 메모리 부족 문제를 해결
	2. 더 많은 프로그램 동시 실행 가능 



프로그램이 다운될 때 공간 확보 가능???

>개발자는 프로그램 실행 시 필요한 공간을 고려하면서 개발하지 않아도 된다???



