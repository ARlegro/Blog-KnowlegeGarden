---
{"dg-publish":true,"permalink":"/OS/C언어, 자료구조, 알고리즘/키워드공부/GCC/","noteIcon":"","created":"2025-08-07T17:15:02.617+09:00","updated":"2025-08-18T01:07:53.497+09:00"}
---




>[!QUESTION] 컴파일이란?
>- **소스 코드를 컴퓨터가 이해하고 실행할 수 있는 기계어로 번역**해주는 도구
>	- 사람이 작성한 코드는 대부분 컴퓨터가 이해할 수 없는 언어이다.
>	- 따라서, 컴퓨터가 이해할 수 있게 해야 하는데, 이 역할을 하는게 컴파일러


### GCC 개념 

✔**GCC (GNU Compiler Collection)**
- 여러 프로그래밍 언어를 지원하는 컴파일러들의 모음 
- **중요성** 
	- 많은 오픈 소스 프로젝트의 **표준** 컴파일러로 사용됨(OS만드려면 필수일 듯?)
	- **넓은 생태계**  : 사람들이 많이 쓴다 ➡ 자료 多 + 대부분 S/W의  기반 


✅**역할 및 특징** 
1. **다양한 언어 지원** 
	- C, C++만 지원하는 것이 아니라, go, fortran, java 등 다양한 언어에 대한 컴파일도 가능 
	  
2. **최적화**
	- 단순 코드 번역만 하는 것이 아니라 최적화 기능을 제공해 속도를 높이거나 메모리 사용량을 줄인다 
	  
3. **크로스 컴파일 가능**
	- 다른 CPU 아키텍쳐용 실행 파일을 만들 수 있다. ex. x86 -> ARM 용



### GCC 내부 동작 구조 
#4단계 

>GCC 내부적으로 하는 일 

```bash
# 기본 컴파일 (sourc.c파일을 source라는 실행파일로 변환)
gcc source.c -o source 
```

#### 1. 전처리 
- `#include, #define, typedef, extern` 과 같은 구문을 처리하여 **매크로를 확장하고 필요한 헤더 파일을 삽입**한다.
- **주요 작업**
	- `#include` 로 지정된 **헤더 파일 삽입** 
	- `#define`으로 정의된 **모든 매크로 치환/확장**
	- **조건부 컴파일 처리** (`#ifdef` 등 )
- 결과 : `?.i`라는 파일이 생성 (But 디스크에는 저장 ❌)


#### 2. 컴파일 단계
- 전처리된 코드(`*.i`)를 **어셈블리어 코드(`*.s`)로 변환**한다.
- 문법 분석, 중간 코드 생성, 최적화가 수행된다. 
- **최적화 옵션**  ex. 불필요한 명령어 제거 등
	- `-Og`같은 옵션이 있으면 **최적화를 적용**한다  (디버깅 친화적 최적화)
	- `-O2, -O3` : 성능 엄청 최적화 

```bash
# test.c = 소스파일, test = 컴파일 할 파일명 
➜ gcc -Og test.c -o test
➜ ./test
a = 12345678, b = 87654321

# 디버깅 하려면 -g 추가하여 컴파일 후 실행 
➜ gcc -Og -g test.c -o test
➜ ./test
```
	  
#### 3. 어셈블 단계
- 어셈블리어 ➡ 실행 가능한 **기계어로 변환** 
- **생성 파일** : 실행 불가능한 객체 파일(`.o`파일)
- 아직 실행 불가능한 객체 코드 💢
	  
#### 4. 링크 단계
- 여러 개의 목적 파일(`.o`)과 라이브러리를 **연결하여 하나의 실행 가능한 파일을 생성**한다
- **주요 작업**
	- 함수 호출의 실제 위치 연결 (라이브러리와)
	- **결과**
	- 기본값 : a.out 
	- `-o filename` 으로 지정한 실행 파일 형태로 결과가 나온다. 
- 링크 심화 자료 : [[OS/Computer System/chapter07-링커/링커\|링커]], [[OS/Computer System/chapter07-링커/재배치 in 링커\|재배치 in 링커]]

