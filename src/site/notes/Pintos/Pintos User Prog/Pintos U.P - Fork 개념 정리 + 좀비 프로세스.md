---
{"dg-publish":true,"permalink":"/Pintos/Pintos User Prog/Pintos U.P - Fork 개념 정리 + 좀비 프로세스/","noteIcon":"","created":"2025-10-04T11:27:12.105+09:00","updated":"2025-12-03T11:19:49.420+09:00"}
---

## 1.  Fork란 
Unix 계열 **운영체제**에서 **새로운 프로세스를 생성**하는 시스템 콜

- 부모 프로세스의 **주소 공간 전체(코드, 데이터, 힙, 스택 등)** 를 그대로 복사하여 자식 프로세스를 만든다
- 부모와 자식은 **독립된 프로세스**가 되며, 서로 다른 PID를 가집니다.
- 단, **복사된 자식의 실행 흐름은 fork 호출 직후**부터 시작합


## 2.  Fork 동작 과정 
> 현재 실행 중인 프로세스를 **복제**합니다.

### 2.1.  부모 프로세스가 할 일 
1. 자식에게 전달해 줄 값들을 담을 바구니 만들기 by `malloc`
2. 자식에게 전달할 값 바구니에 담기
3. thread_create 호출하면서 바구니 전달
4. 자식 신호 대기
5. 깬 뒤 자원 정리 

### 2.2.  자식 프로세스가 할 일 
1. 부모가 넘겨준 값 받기
2. 부모의 CPU 레지스터 복사
3. 자식의 페이지 테이블 생성 및 활성화
4. 부모의 가상 주소 공간 복사
5. 부모의 fd 테이블 복사
6. 부모 깨우기
7. 성공 처리

## 3.  Fork 특징 

### 3.1.  Copy-on-Write(COW)
참고 : Pintos Project 2 에서는 COW방식을 사용하지 않는다(실제 OS는 사용)


`fork()`는 부모 프로세스의 모든 메모리 공간을 즉시 복사하는 것이 아니라, **Copy-on-Write(쓰기 시 복사)** 라는 기술을 사용 ➡ 효율성 증대 

❓*어떻게 이런게 가능❓*
- *처음은 읽기 전용* 
	- `fork()`호출 시 부모-자식은 **같은 메모리 페이지 공유**하고 이 메모리 페이지들은 **읽기 전용**이다.
- *Lazy 복사본 생성*
	- 만약 부모나 자식 프로세스 중 **하나가 공유된 메모리 페이지에 쓰기를 시도**하면, OS가 그때서야 **해당 페이지의 복사본을 생성**하여 각각의 프로세스가 독립적인 페이지를 갖게 한다..
    
- *효과*
	- 덕분에, 안 쓰는 부모 프로세스의 메모리를 복사하는 불필요한 비용을 크게 절감할 수 있다.

### 3.2.  자식과 부모는 독립적

- `fork()`가 성공적으로 반환된 순간부터 **서로 독립된 실행 흐름**을 가진다. 
- 부모가 하던 작업이 자식에게 영향을 주지 않고, 자식이 하던 작업도 부모에게 영향을 주지 않는다.


### 3.3.  자식은 부모 프로스의 자원을 그대로 물려받음 
`fork()` 시스템 콜을 통해 생성된 자식 프로세스는 부모 프로세스의 자원을 그대로 물려받는다.
- 주소 공간
- FD
- 레지스터
- 환경 변수, 현재 작업 디렉토리 등


## 4.  Fork 시 ...
### 4.1.  좀비 프로세스
![Pasted image 20250924233153.png](/img/user/supporter/image/Pasted%20image%2020250924233153.png)
- 실행을 완료했지만, 부모 프로세스가 아직 종료 상태를 읽어가지 않아 **프로세스 테이블에 남아 있는 프로세스**

> [!WARNING] 좀비 프로세스는 버그가 아니다
> - 자체는 버그가 아니다. 
> - 부모에게 종료 상태를 전달하기 위한 중간 상태일 뿐
> - 단, 이 **상태가 지속될 경우 문제가 발생**하는 것 💢

#### 4.1.1.  발생 원리 예시 
![Pasted image 20250924230836.png](/img/user/supporter/image/Pasted%20image%2020250924230836.png)
(출처 : [greeksforgeeks](https://www.geeksforgeeks.org/operating-systems/zombie-processes-prevention/))
♻
> 원인 : 자식 프로세스의 종료 상태 정보를 부모 프로세스가 아직 수집하지 않아서 

1. *fork로 자식 프로세스 생성(부모)*
2. *자식 기다림 - wait (부모)*
	- 부모 프로세스는 자식을 `wait`한다
	- 이유 : **자식의 종료 상태를 회수**해서 커널에 남아 있는 최종 기록들을 제거하기 위해서
	- 대부분의 자원들은 자식에서 해제 했지만 일부 정리 필요
	  
3. *프로세스 실행(자식)*
4. *프로세스 작업 끝 +  exit()호출 (자식)*
	- 자식 프로세스가 작업을 마치고 `exit()`을 호출한다.
	- 이 때, 자식이 사용했던 대부분의 자원(메모리, 파일 등)들을 회수한다.
	- 그러나 부모 프로세스에게 자식의 종료 상태를 알리기 위해 일부는 PCB에 남겨놓는다 
>[!danger] 
>- 자식 프로세스는 종료 과정에서 PCB를 남겨뒀다는 것.
>- 그 프로세스는 프로세스 목록에 남아 있고, 좀비가 된다.
>- 점점 좀비 프로세스가 많아지면 ~되고 OS가 느려지고 문제까지 발생 가능 

#### 4.1.2.  좀비 프로세스가 문제인 이유 (실제 OS기준)
1. Process Table 차지
2. PID 고갈

➡️ 새로운 프로세스 생성 제한 가능

![Pasted image 20250924174339.png](/img/user/supporter/image/Pasted%20image%2020250924174339.png)
(Note : Pintos는 자식에서 스케쥴러에게 제거 trigger를 제공하는 로직이 되어 있어서 실제 OS와 약간 다르다)

>[!tip] 좀비 프로세스 문제 예방법
>Pintos에서는 wait()만 사용했어서 방법이 하나만 있는 줄 알았는데 여러 방법이 있다고 한다.
>1. `wait()` 시스템 콜 사용
>2. `waitpid()` 시스템 콜 사용
>3. 'SIGCHLD' 시그널 무시
>4. 시그널 핸들러 사용
>5. 이중 fork (Double fork)


#### 4.1.3.  좀비를 안남기는 핵심 로직 - wait()
`wait()`는 좀비 프로세스 생성을 **방지**하는 핵심적인 방법 
![Pasted image 20250924231645.png](/img/user/supporter/image/Pasted%20image%2020250924231645.png)
1. *부모는 `wait()` 호출로 대기 상태에 빠짐*
2. *자식 실행 완료 후 자원 대부분을 해제 (최소한의 정보는 P.T에)*
3. *부모 프로세스에게 알림*
	- *Pintos* : semaphore를 활용한 동기화 방식으로 status 확인 시키도록 
	- *실제 OS* : 커널이 부모 프로세스에게 자식의 종료 관련 Signal을 보냄 (시그널 무시 설정 시 커널이 자식 프로세스 종료 시 자동 정리)
4. *정보 수거 및 완전 소멸(부모)*
	- **부모는 자식의 종료 상태를 확인하고 PID 반납, PCB 해제 등 남은 기록들을 정리**한다. (실제 OS와 Pintos는 약간 다름)


>[!tip] 실제 OS vs Pintos 의 좀비 상태 알림 
>1. *실제 OS* 
>	- **커널이** 부모 프로세스에게 **자식의 종료 관련 Signal을 보냄** 
>	- **자동 정리도 가능** : 시그널 무시 설정 시 커널이 자식 프로세스 종료 시 자동 정리
>	  
>2. *Pintos* 
>	- **`semaphore`를 활용한 동기화 방식**으로 status 확인 시키도록 

>[!tip] 실제 OS vs Pintos 의 좀비 정리
>3. *실제 OS* 
>	- **자식의 PCB(`task_struct`)를 확인**하고 **종료 상태를 가져온다.** 
>	- 이러한 수확(reaped)과정이 일어나면 PID 반납, PCB(`task_struct`) 정리 등을 한다.
>   
>4. *Pintos* 
>	- **부모-자식 관계를 끊는 역할**. 
>	- PCB(TCB) 관리 없음
>	- 💢**PID 반납도 없고 재사용도 안함** 
```C
// 자식 프로세스의 exit()
void thread_exit (void) {

  ASSERT (!intr_context ());
	...
  do_schedule (THREAD_DYING);  // DYING 상태로 만들고 스케쥴러에게 위임 
```



*부모 프로세스에게 알림*
- *Pintos* : semaphore를 활용한 동기화 방식으로 status 확인 시키도록 
- *실제 OS* : 커널이 부모 프로세스에게 자식의 종료 관련 Signal을 보냄 (시그널 무시 설정 시 커널이 자식 프로세스 종료 시 자동 정리)

*정보 수거 및 완전 소멸(부모)*
	- **부모는 자식의 종료 상태를 확인하고 PID 반납, PCB 해제 등 남은 기록들을 정리**한다. (실제 OS와 Pintos는 약간 다름)
 

### 4.2.  고아 프로세스
> `PID 1(init/systemd)`이 모든 고아의 wait()를 자동 호출 

부모가 자식의 상태값을 회수하지 않고 메모리를 해제하지 않은채로 종료되면 자식은 고아 프로세스가 된다.

고아 프로세스가 되면 Linux에서는 PID 1 이 아래와 같은 작업을 함
- PID 1은 **주기적으로 고아 자식이 종료했는지 확인**하고
- 종료 했다면 `wait()`로 `exit status`를 회수하고 
- zombie를 바로 제거 

> 즉, 부모가 `wait()`를 호출하지 않고 죽어도 PID 1(init 프로세스)이 자동으로 그 자식을 인수해 wait를 수행해 청소해주는 구조





## 5.  EXEC



---
## 6.  fork()를 사용한 프로세스 생성 
> `fork()`를 사용하여 **별도의 복제 프로세스를 생성**할 수 있다.


- 현재 프로세스의 **복사본인 자식 프로세스를 생성** 
- 💢**부모의 완벽한 복사본은 아니다** : 다른 점들이 몇 개 있다. ex. PID, 보류중인 신호, 메모리 잠금 여부 등 
- **부모-자식 간 주소 공간은 쓰기 전까지는 공유**된다 : 쓰기 시에는 Copy-On-Write 메커니즘으로 
  
이는 C, C++에서 라이브러리 함수로도 제공된다.

---
### 6.1.  fork() 호출 과정 

현재 프로세스가 `fork()`를 호출하면 아래와 같은 순서로 동작한다
1. *새 프로세스 생성 + PID 부여*
	- 커널은 새로운 프로세스를 위한 **여러 가지 자료 구조를 생성**하고 
	- **고유 PID를 부여**
	  
2. *가상메모리 사본 생성*
	- 새로운 프로세스를 위해 기존 프로세스의 가상 메모리 공간과 동일한 사본을 생성한다
	  
3. *페이지 테이블 준비*
	- 부모의 페이지 테이블을 복제 
	- But PTE들이 가리키는 물리 Frame은 공유되고 뭐...  읽기전용만들고 쓰기 시 Copy-On-Write해서 사적 공간... 이렇게 만드는데... 이유 굳이 적을 필요 없고 필요할 때 공부 ㄱ 


`fork()`가 호출된 후, 부모와 자식의 실행은 다음과 같이 나뉜다.
1. 부모와 자식 모두 동시에 실행될 수 있다.
2. 부모는 자식이 완료될 때까지 기다릴 수 있다.

---
## 7.  execve()
#시스템콜 

> *다른 프로그램을 현재 프로세스의 위치에 새로 실행*하는 시스템 콜 
- 호출하는 프로세스의 **껍데기는 가만히 두고,**
- 안에 들어있는 프로그램을 **통째로 새로운 프로그램으로 갈아끼우는** 


>[!tip] fork() vs execve()
>- fork() : 현재 프로세스 복제 후 자식 프로세스는 새로 생성 
>- execve() : 기존 프로세스를 대체



