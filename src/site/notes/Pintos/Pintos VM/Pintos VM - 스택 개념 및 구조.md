---
{"dg-publish":true,"permalink":"/Pintos/Pintos VM/Pintos VM - 스택 개념 및 구조/","noteIcon":"","created":"2025-12-03T16:03:22.882+09:00","updated":"2025-12-13T09:26:33.437+09:00"}
---


## 1.  함수 호출에서의 스택(Call Stack)


> [!info] 함수 호출 흐름(복귀 주소)과 함수의 실행 상태(지역 변수·매개변수)를 관리하는 메모리 스택 구조
> - OS에서의 Stack의 가장 중요한 용도는 "함수 호출"을 관리하는 것. 



*콜 스택의 주요 역할*
1. *함수 호출 관리* 
	- 해당 함수가 호출되면 복귀 주소를 스택에 저장한다
	- 해당 함수가 끝나면 스택의 top을 pop하여 어디로 돌아갈지 결정한다
	- 즉, **프로그램의 실행 흐름을 이어주는 핵심 장치.** 
2. *지역, 매개변수, 레지스터 데이터 저장* 


> 콜 스택이 없다면 함수에서 돌아갈 위치를 기억할 수 없어서 프로그램 함수 호출 자체를 안전하게 할 수 없음 


## 2.  Stack Frame
> 함수가 호출될 때마다 해당 함수 실행에 필요한 정보들을 묶어 스택에 추가되는데 이 단위를 Stack Frame이라 부른다

Stack Frame에 저장되는 일반적인 정보
1. *복귀주소* 
2. *이전 Frame 포인터*
	- 복귀 시 안정적인 기준점 확보 역할 

3. *매개변수*
	- 함수를 호출할 때 전달된 인자 값
4. *지역변수*
	- 함수 내에서 선언된 변수들 


>[!QUESTION] 복귀 주소가 있는데 왜 이전 Frame Pointer(FP)가 필요한가❓
>- 복귀 주소는 함수가 끝난 후 돌아갈 위치를 알려줄 뿐이고, 실행 중 변경되는 rsp 대신 고정된 기준점이 필요합니다. (Cuz rsp는 계속 변화해서 정확한 위치 계산 번거로움)
>- 프레임 포인터는 **지역 변수·매개변수 접근을 단순하게** 하고, 백트레이스나 디버깅을 위해 이전 프레임과 체인 구조를 만드는 역할을 합니다. 
>- 그래서 복귀 주소만으로는 충분하지 않고 FP가 반드시 필요합니다.


## 3.  스택 구조 
> 대부분 가상 메모리의 가장 높은 주소에서 시작 

*현대 OS에서의 Stack*
- 스택은 **VM의 상단에 위치**한다
- 그리고 **아래 방향(주소가 감소하는 방향)으로 성장**한다.
- 높은 주소  ➡ 스택 시작
- push 하면 주소 감소


✔*Linux / Unix / MacOS 표준 구조* 
```SCSS
0x00000000  ---------------------
             Text ( 코드 )
             Data
             BSS
             Heap     ↓ (주소 증가)
             ... 여유 공간 ...
             Stack    ↑ (주소 감소)
0xFFFFFFFF  ---------------------
```
- Stack 시작 (`PHYS_BASE`)
- push할 때 스택 포인터(rsp/sp)는 주소 감소 방향으로 움직인다.
- 즉, 스택은 성장할 때 주소가 감소한다.


>[!tip] 
>거의 모든 OS에서 스택은 가상 메모리의 가장 높은 주소 영역에 위치하며, 주소가 감소하는 방향으로 성장한다


## 4.  Stack Overflow

### 4.1.  개념 

>제한된 Stack 영역이 **새로운 Stack Frame을 더 이상 저장할 수 없을 정도로 가득 찼을 때** 발생하는 현상

- 스택의 **크기는 제한**되어 있으며 보통 프로그램이 시작될 때 **OS에 의해 미리 정해진다.**
	- 실제로 Pintos에서도 제한하는 부분이 있다

### 4.2.  발생 원인 
- *언제 발생하는가❓*
	1. 함수 호출이 너무 깊게 중첩될 경우
	2. 함수 내에서 너무 많거나 큰 지역변수가 선언되어 스택 공간을 초과할 경우 

### 4.3.  Stack Overflow의 결과 💢
>[!QUESTION] Stack Overflow가 나면 무슨일이 일어나는가❓

Stack Overflow가 일어나면 OS는 다음과 같은 단계를 거쳐 조치를 취한다
1. Segmentation Fault or 유사한 메모리 접근 오류가 발생 
2. OS는 이를 **치명적인 오류로 간주**하고 **해당 프로세스를 강제로 종료**시킨다.
3. 그 결과, 프로그램은 비정상적으로 종료된다.

### 4.4.  Stack Overflow 방지법

1. 재귀 함수 작성 시 정확한 종료 조건을 명시하기
2. 너무 큰 지역변수 할당 피하기
3. Stack 대신 Heap 메모리를 동적할당하는 방법 고려하기 


## 5.  스택 vs 힙 (간단히)

| **특징**    | **스택 (Stack)**             | **힙 (Heap)**                                                  |
| --------- | -------------------------- | ------------------------------------------------------------- |
| **목적**    | 함수 호출, 지역 변수, 복귀 주소 저장     | 동적 할당되는 데이터 저장 (e.g., C/C++의 `malloc`/`new`, Java/Python의 객체) |
| **성장 방향** | **아래** 방향 (주소 감소)          | **위** 방향 (주소 증가)                                              |
| **할당 방식** | 컴파일 시/런타임 시 **자동** 할당 (빠름) | 런타임 시 프로그래머가 **수동** 할당 (느림)                                   |
| **수명**    | 함수가 종료되면 **자동 소멸**         | 프로그래머가 **명시적으로 해제**하거나 **GC**에 의해 해제될 때까지 유지                  |
