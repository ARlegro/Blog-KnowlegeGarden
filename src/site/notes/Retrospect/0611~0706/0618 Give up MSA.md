---
{"dg-publish":true,"permalink":"/Retrospect/0611~0706/0618 Give up MSA/","noteIcon":"","created":"2025-06-20T21:45:38.012+09:00","updated":"2025-07-13T21:30:19.863+09:00"}
---



**이전 : Rabbit MQ에 MSA 아키텍쳐 도입 도전기** 
- [[Retrospect/0611~0706/0616 R.M으로 시작해서 MSA를 겉 배우게 되다.\|0616 R.M으로 시작해서 MSA를 겉 배우게 되다.]]
- [[Retrospect/0611~0706/0617 R.M + Saga-Pattern Impl. (feat. redis)\|0617 R.M + Saga-Pattern Impl. (feat. redis)]]

---
### MSA까지 오게 된 이유 
처음 이 공부를 하며 프로젝트를 시작하게 된 계기는, 외부 API를 여러 번 호출하는 긴 트랜잭션 구조에서 오는 복잡성과 비효율성을 분해하고 싶다는 고민 때문이었다.
전통적인 모놀리식(monolithic) 애플리케이션에서는 `@Transactional`만 잘 활용하면 손쉽게 ACID를 보장할 수 있다. 실제로 필드에서도 그렇게 구현된 경우가 많을 것이다.
하지만 문제는 확장성이다.  (+결합도)
서비스가 성장하면 자연스럽게 기능이 많아지고, 그에 따라 개발, 테스트, 배포 단계에서 점점 병목이 생긴다. 특히 서로 강하게 결합된 구조는 유지보수와 장애 대응 측면에서도 치명적이다.
이러한 문제들을 해결하고자 등장한 것이 **MSA**이고 지금 내가 하려는 결합도를 낮추려는 코드 전략도 이를 통해 해결할 수 있다는 것을 알게된 후 공부하게 됐다.

---
### 처음에는 회의적 
사실 처음부터 MSA를 학습하려던 건 아니었다.
다. 약 3달 전, 한 대기업 IT서비스 기업에 재직 중인 멘토님이 “Microservice Architecture는 꼭 알 필요 없다. 나도 모른다”는 말을 했던 게 기억에 남는다. 그때는 나도 굳이 파고들 생각이 없었고 지금도 비효율적인 공부라고 생각한다..
하지만 내 코드의 **결합도를 낮춰보고** 싶었고, 좀 더 **모듈화된, 객체지향적인 구조**를 만들어보고 싶다는 욕심이 생겼다. 그렇게 시작한 것이 **RabbitMQ**였다.
RabbitMQ에서 시작된 관심은 자연스럽게 **트랜잭션 처리 문제**로 이어졌고, **Saga Pattern**, 나아가 **Spring StateMachine**에까지 발을 들이게 되었다.

---
### 결론 : Give Up ➡ 수동 보상 트랜잭션으로 마무리 
처음에는 MSA에서 데이터의 일관성을 보장할 수 있는 **Saga Orchestration** 구조를 Spring의 상태 머신 프레임워크로 구현하려고 했다.
(이 링크처럼 : https://techblog.woowahan.com/19491/)

하지만 현실은 복잡했다.
기존 Monolitic 방식에서는 정말 단순하게 처리됐던 로직이 MSA 구조에서는 너무 많은 고려 사항이 생겼다. 가장 큰 고민은 **Atomicity**였다.
1. RabbitMQ처럼 비동기 메시징을 사용할 경우, 각 이벤트는 서로 다른 트랜잭션 단위로 동작한다. 이때, 예를 들어 Order와 Payment 로직이 비동기로 실행되었을 때 Payment는 외부 통신으로 지연되고, Order는 더 빨리 실패할 수 있다. 문제는 이처럼 **아직 성공도 실패도 아닌 중간 상태의 이벤트들**이다. 이를 해결하기 위해 Redis로 각 이벤트의 상태를 `pending`, `success`, `fail`로 구분하려 했지만, 수동으로 로직을 짜기엔 구조가 너무 복잡해졌다
2. 그 와중에 Spring의 상태 머신이 있다는 것도 알게 되어 Doc을 보고 Spring공식 유튜브에서하는 설명영상도봤지만, 러닝 커브도 크고 학습 대비 효율이 떨어진다고 판단했다.

> 곧 **크래프톤 정글** 입소를 앞두고 있는 상황이라 학습 방향의 효율성도 고려해야 했다.

우선은, 설계한거랑 어느정도 구현한게 아쉬워서라도 간단하게 수동으로 보상 트랜잭션으로 saga-pattern구현만 해보고 이 프로젝트는 마무리를 하려 한다.

---
### 삽질 속 남은 것들 
회고록에는 적지 않았지만 Rabbit MQ부터 시작해서 지금까지 거의 1주일? 정도 시간을 쏟았다. 
프로젝트에 **RabbitMQ**를 도입하고, **Saga Pattern** 구현을 시도하며, **MSA의 구조적 복잡성과 트레이드오프**를 몸소 체험한 시간이었다.

구현 자체는 단순하게 끝내지만, 얻은 인사이트는 명확하다.
- 기존 아키텍처의 한계가 무엇인지
- MSA가 어떤 문제를 해결해주며
- 어떤 대가(trade-off)를 감수해야 하는지
- 그리고 그 복잡함을 극복하기 위한 프레임워크가 무엇이 있는지를 파악하게 되었다.

향후 3~5일 정도 이 프로젝트를 마무리 짓고, 입소 전까지는 이전에 공부했던 Java, Spring, DB 등 기반 지식들을 정리하는 데 집중할 계획이다.

> 참고 [[DevStudy/Backend/RM/saga/Monolitic Service's Boundary and How to maintain Atomicity in MSA (with saga)\|Monolitic Service's Boundary and How to maintain Atomicity in MSA (with saga)]]


