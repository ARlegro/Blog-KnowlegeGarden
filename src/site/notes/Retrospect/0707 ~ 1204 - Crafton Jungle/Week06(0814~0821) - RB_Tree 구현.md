---
{"dg-publish":true,"permalink":"/Retrospect/0707 ~ 1204 - Crafton Jungle/Week06(0814~0821) - RB_Tree 구현/","noteIcon":"","created":"2025-08-18T00:39:47.602+09:00","updated":"2025-09-05T02:29:18.643+09:00"}
---

---
### RB_Tree 삭제 벽 느꼈던 썰 

RB_Tree 삽입 부분을 이해하고 구현한 뒤에는 이런 생각이 들었다. "별거 아닌데? RB_Tree가 그렇게 어렵다 했는데 뭐가 어렵단거지??"
이런 자만심이 생긴채로 천천히 해도 된다고 생각해 여유를 가지고 CS공부를 파고 있었다.
이제 슬슬 다시 RB_Tree 시작해볼까? 하고 RB_Tree의 "특정 노드 삭제" 부분에 대한 이론 영상을 봤다.
.....뭐지?? 뭐라는거지?? 조금 충격이었다. 4시간 정도 공부를 해봤는데 감이 잡히지 않았다.
이렇게 저렇게 멘탈이 나간채로 있다가 토요일이기도 하고 Refresh좀 할 겸 동료들과 새벽까지 맥주를 마셨다.

---
### 삭제를 이해하고 유레카 외친 썰 
어제 새벽 4시 쯤에 들어갔는데 9시도 안돼서 눈이 떠졌다. 몸이 기억하고 있나보다. 더 잘까 했지만 어제 감도 못 잡은 RB_Tree 삭제를 어떻게든 해야겠다는 생각으로 아침 운동 가볍게 하고 일요일이지만 강의실로 출근을 했다.

https://youtu.be/6drLl777k-E?si=BiJVkzKu1eh0WX2k
어제 위 영상을 보면서 왜 이해가 안됐을까? 복기를 해봤다. 가장 부족한 점은 이진트리의 삭제 이론도 알지 못한다는 점이였다. A -> B 이런 식으로 갔어야 됐는데 바로 B부터 시작하니 이해가 안된다고 판단했다.
그래서 이진트리의 이론 영상을 봤다. 생각보다 너무 쉬워서 이론 정리(자료 : [[DevStudy/Argorithm/번외-Red_Black_Tree/B_Tree - Delete\|B_Tree - Delete]])만 하고 다시 한번 RB_Tree 삭제 영상을 처음부터 봤다. 그렇게 기초부터 닦고 차분히 ExcaliDraw에 그림을 그려가며 이해하던 중 헤드셋을 집어던졌다. 분명 어제 그렇게 감도 안 잡히던게 다 이해가 되버렸다 ㄷㄷ. 어제만 해도 왜 이런 과정이 있지?를 이해하지 못했다면 지금은 완전히 이해하고 남에게 다 설명할 수 있을 정도가 됐다.
![Pasted image 20250818005031.png](/img/user/supporter/image/Pasted%20image%2020250818005031.png)
생각보다 여러 개념들이 많이 필요해서 트리 변경에 대한 기초/원리가 없다면 못 푸는 문제였었다. 일단 아이디어/이론은 어려운 부분 전부 이해했으니 다시 내가 좋아하는 CS 공부를 하러 갔다 
- [[DevStudy/Argorithm/번외-Red_Black_Tree/RB_Tree - Delete\|RB_Tree - Delete]]
- [[DevStudy/Argorithm/번외-Red_Black_Tree/doubly_black 해결하기 in RB_Tree\|doubly_black 해결하기 in RB_Tree]]

---
### 트리 전부 까보면서 디버그한 썰 
RB_Tree 노드 삭제 메서드를 테스트 일부를 통과하고 다른 테스트를 진행 하던 도중 트리의 색을 확인하는 로직에서 오류가 떴다. 삽입만 이루어졌을 때의 오류라 RB_Tree 삽입 메서드에서 일부 버그 로직이 있다고 판단했다.

Insert로직은 며칠동안 한번도 안 봐서 복습 겸 정리 내용을 한 번 훑어보고 Insert로직을  분석했다. 한 2시간쯤 찾다가 2~3가지 문제를 발견했다.
1. *필드 비교 에러* 
	- color를 비교하는 if문에서 color가 아닌 다른 필드를 비교했던 것 
	  
2. *색깔 초기화 작업 시 다른 변수에 부여*
	- 삽입을 하면서 중간중간 회전과 색변경이 필요한데, 그 때 **이상한 변수에 색 변경을 주고 있었다.** 
	- 이로 인해서 **색관련 불균형이 발생**하고 RB_Tree의 **5번 속성을 만족시키지 못하고** 있었다.
	  
아주 사소한 실수인데 참... 
예전에 필드 비교 에러가 은근 많이 일어난다는 애기를 듣고 설마 그러겠어?라고 코웃음을 쳤던 적이 있는데 내가 지금 그러고 있었다. 사소한 실수로 몇 시간을 날려버리는 상황이 발생하지 않게 좀 더 섬세하게 코드를 작성하는 습관을 가져야겠다.

---
### RB_Tree 무한 루프 빠진 썰 
```C
  test_init();
  test_insert_single(1024);
  test_find_single(512, 1024);
  test_erase_root(128);
  test_find_erase_fixed();
  test_minmax_suite();
  test_to_array_suite();
  test_distinct_values();
  test_duplicate_values();
  test_multi_instance();
  test_find_erase_rand(10000, 17); :CHE
  printf("Passed all tests!\n");
}
```
Week 06의 RB_Tree 미션을 클리어하려면 위의 테스트 메서드들을 전부 통과해야 했다.

근데 테스트를  마지막 테스트 메서드인 10000개의 Random 데이터를 삽입/삭제하는  `test_find_erase_rand`부분에서 문제가 생겼다. 문제는 다음과 같다.

---
#### 1. 무한루프로 디버그 어려움 
- make test 명령어를 쳤는데 터미널창이 아무것도 안뜨는 상황이 발생했다. 1분이 지나도 아무 일이 일어나지 않고 강의장에는 노트북의 팬소음으로 가득차려고 했다.
- 무한루프에 걸렸구나 라고 생각을 한 뒤 ctrl + c 로 강제 종료를 했다. 일단 erase관련 메서드에서 While문이 있는 곳은 "FixUp"부분 밖에 없기에 FixUp을 중점적으로 디버그하기 시작했다.

---
#### 2. BreakPoint => 출력 디버그로 전환 
- 만개의 데이터에서의 무한 루프의 문제는 breakpoint로는 디버그가 어렵다는 것이였다. 정말 노가다로 만개의 데이터 하나하나 돌아가는 것들 다 확인할 수도 없는 노릇이였다.
- 그래서 각 분기분의 여러 출력 요소들을 넣어서 어디서 문제가 되는지를 보았다. 분기중에서도 break가 있는 분기 말고 continue가 있는 부분에 디버그용 출력물을 배치했고, 아무 분기에도 속하지 않는 경우가 있지 않을까 싶어서 While문의 뒤쪽에도 출력 디버그를 배치를 했다.
	![Pasted image 20250820180056.png](/img/user/supporter/image/Pasted%20image%2020250820180056.png)

- 우선, 일단 **간단한 디버그 결과를 통해 유추**할 수 있는 것은 다음과 같았다.
  
	1. *분기에 걸리지 않는 결과는 없었다*
		- 내 코드 로직은 모든 분기를 처리했다.
		- 정상적이라면 While문의 마지막 부분을 절대 도달할 수 없을 것이다.
		- 디버그 출력 결과를 보면 While문의 마지막 부분은 절대 도달하지 않는 것을 볼 수 있었다. 
		- 즉, **어느 Case에도 들지 않아서 무한 루프가 생기는 경우는 아니였던 것으로 예측**할 수 있다.
		  
	2. *2개의 분기처리의 계속된 반복* 
		- 출력 결과 "문제아 1", "문제아 3"이라고 배치해 놓은 출력문이 계속 반복됐다. 그 문제아들은 아래와 같다.
			```c
			//  Doubly Black이 왼쪽일 경우 
			if (p->left == db_node){
			
			//✅아래의 두 경우 
			// Case 0. 형제가 Red인 경우 : 색변화 + left_rotate 후 brotehr 초기화
			if (brother->color == RBTREE_RED){
				p->color = RBTREE_RED;
				brother->color = RBTREE_BLACK;
				left_rotate(t, p);
				printf("문제아 1");
				continue;
			}
			
			// Case 3. brotehr의 왼쪽 자식 Red, 오른쪽 자식 Black
			if (brother->left->color == RBTREE_RED && brother->right->color == RBTREE_BLACK){
				// Case 1 을 유도하도록만
				brother->color = RBTREE_RED;
				brother->left->color = RBTREE_BLACK;
				printf("문제아 3");
				right_rotate(t, brother);

				continue;
			}
			}
			```
		- 이제 어디가 문제인지 확인하긴 했는데, 로직을 뜯어봐도 그렇게 큰 문제는 없어보인다. 아마 예외 케이스가 있는 것 같은데 이건 좀 더 자세히 디버그해야 할 것 같다.

---
#### 3. 문제아들 집중 출력 디버깅 
```c
// Case 0. 형제가 Red인 경우 : 색변화 + left_rotate 후 brotehr 초기화
if (brother->color == RBTREE_RED){
	p->color = RBTREE_RED;
	brother->color = RBTREE_BLACK;
	//brother = brother->left; // 새로운 형제로
	left_rotate(t, p);
	printf("문제아 1");
	continue;
}


// Case 3. brotehr의 왼쪽 자식 Red, 오른쪽 자식 Black
if (brother->left->color == RBTREE_RED && brother->right->color == RBTREE_BLACK){
	printf("brother.key = %d\n", brother->key);    
	// Case 1 을 유도하도록만
	brother->color = RBTREE_RED;
	brother->left->color = RBTREE_BLACK;
	right_rotate(t, brother);
	printf("문제아 3");
	printf("문제아 3 : new Brother 색 = %s\n", color_str[p->right->color]);
	printf("문제아 3 : new Brother의 Key = %d\n", p->right->key)
	printf("문제아 3 : old brother 색 = %s\n", color_str[brother->color]);
	printf("문제아 3 : old brother의 Key = %d\n", p->right->right->key);

```

> 출력 결과 : 아래 결과가 계속해서 반복됐다.
```text
문제아 1========================앞쪽=========================
db_node.key = 1995473543
parent.key = 1995497538
brother.key = 0
문제아 3문제아 3 : new Brother 색 = RED
문제아 3 : new Brother의 Key = 0
문제아 3 : old brother 색 = RED
문제아 3 : old brother의 Key = 0
========================앞쪽=========================
db_node.key = 1995473543
parent.key = 1995497538
문제아 1========================앞쪽=========================
db_node.key = 1995473543
parent.key = 1995497538
brother.key = 0
문제아 3문제아 3 : new Brother 색 = RED
문제아 3 : new Brother의 Key = 0
문제아 3 : old brother 색 = RED
문제아 3 : old brother의 Key = 0
```
분석 
- 일단 3번의 의도된 흐름은 아래의 사진과 같다.
	![Pasted image 20250820175449.png](/img/user/supporter/image/Pasted%20image%2020250820175449.png)
- 근데 지금 출력 결과를 보면 old_brother, new_brother의 key 둘 다 0인 것을 알 수 있다. 
- 흠... nil_node이구나로 넘어갈 수 있겠지만 색깔이 RED??
- 뭐가 문제지... 생각을 하다가 **내 로직의 특징을 통해 이해가 됏다**
	- RB_Tree의 삭제 구현에서는 doubly_black의 노드가 nil노드인 경우도 처리해야 한다. 만약 nil node의 부모를 원칙처럼 nil 노드로 한다면 앞쪽의 `doubly_black->parent` 접근 시 큰 버그가 발생한다. 
		
	- 이로 인해, 나는 초반에 nil_node의 부모를 nil 노드가 아닌 다른 노드로도 허용을 했다. 
	![Pasted image 20250820180436.png](/img/user/supporter/image/Pasted%20image%2020250820180436.png)
	- 그리고 이 fixup로직이 끝나면 아래와 같이 nil노드의 색, 부모를 초기화했는데 이 로직이 너를 **안일하게 했다.**
		```c
		  t->nil->parent = t->nil;
		  t->nil->color = RBTREE_BLACK;
		```
	- 이 상태에서 **여러 분기들이 whil문 안에서 상호작용하다보면 nil 노드가 Red인 상태에서 진행이 되어 오류가 발생**했던 것이다.

이 문제를 해결하고자 while문이 시작하면 nil노드의 부모와 색을 초기화하는 로직을 꼭 넣게 되었다, 
![Pasted image 20250820180554.png](/img/user/supporter/image/Pasted%20image%2020250820180554.png)
이렇게 하니 "ALL PASS"라는 문장 발견!!!

> **RB_Tree 삭제 구현 시 로직은 물론이고 버그 잡을 때도 AI 안쓰고 문제를 해결하니** 보람찼다(심지어 책, 수도코드도 안보고 오직 아래의 영상으로만 해결)

삭제 참고 영상 : https://www.youtube.com/watch?v=6drLl777k-E&t=2107s
